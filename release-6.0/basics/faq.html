<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Frequently Asked Questions Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="solution.html">Solution Handling</a></li><li><a class="toctext" href="plot.html">Plot Functions</a></li><li><a class="toctext" href="integrator.html">Integrator Interface</a></li><li><a class="toctext" href="problem.html">Problem interface</a></li><li class="current"><a class="toctext" href="faq.html">Frequently Asked Questions</a><ul class="internal"><li><a class="toctext" href="#Performance-1">Performance</a></li><li><a class="toctext" href="#Complicated-Models-1">Complicated Models</a></li><li><a class="toctext" href="#Numerical-Error-1">Numerical Error</a></li><li><a class="toctext" href="#Autodifferentiation-and-Dual-Numbers-1">Autodifferentiation and Dual Numbers</a></li></ul></li><li><a class="toctext" href="compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../analysis/global_sensitivity.html">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/neural_networks.html">Neural Networks</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href="faq.html">Frequently Asked Questions</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/basics/faq.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Frequently Asked Questions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Frequently-Asked-Questions-1" id="Frequently-Asked-Questions-1">Frequently Asked Questions</a></h1><p>This page is a compilation of frequently asked questions and answers.</p><h2><a class="nav-anchor" href="#Performance-1" id="Performance-1">Performance</a></h2><h4><a class="nav-anchor" href="#Do-you-support-GPUs?-Multithreading?-Distributed-computation?-1" id="Do-you-support-GPUs?-Multithreading?-Distributed-computation?-1">Do you support GPUs? Multithreading? Distributed computation?</a></h4><p>Yes. The <code>*</code>DiffEq.jl libraries (OrdinaryDiffEq.jl, StochasticDiffEq.jl, and DelayDiffEq.jl) are all written to be generic to the array and number types. This means they will adopt the implementation that is given by the array type. The in-place algorithms internally utilize Julia's broadcast (with some exceptions due to a Julia bug for now, see <a href="https://github.com/JuliaDiffEq/OrdinaryDiffEq.jl/issues/106">this issue</a>) and Julia's <code>A_mul_B!</code> in-place matrix multiplication function. The out-of-place algorithms utilize standard arithmetical functions. Both additionally utilize the user's norm specified via the common interface options and, if a stiff solver, ForwardDiff/DiffEqDiffTools for the Jacobian calculation, and Base linear factorizations for the linear solve. For your type, you may likely need to give a <a href="http://docs.juliadiffeq.org/latest/basics/common_solver_opts.html#Advanced-Adaptive-Stepsize-Control-1">better form of the norm</a>, <a href="http://docs.juliadiffeq.org/latest/features/performance_overloads.html">Jacobian</a>, or <a href="http://docs.juliadiffeq.org/latest/features/linear_nonlinear.html">linear solve calculations</a> to fully utilize parallelism.</p><p>GPUArrays.jl, ArrayFire.jl, DistributedArrays.jl have been tested and work in various forms, where the last one is still not recommended for common use yet.</p><p>The next question is whether it matters. Generally, your system has to be large for parallelism to matter. Using a multithreaded array for broadcast we find helpful around <code>N&gt;1000</code>, though the Sundials manual says <code>N&gt;100,000</code>. For high order Runge-Kutta methods it's likely lower than the Sundials estimate because of more operations packed into each internal step, but as always that will need more benchmarks to be precise and will depend on the problem being solved. GPUs generally require some intensive parallel operation in the user's <code>f</code> function to be viable, for example a matrix multiplication for a stencil computation in a PDE. If you're simply solving some ODE element-wise on a big array it likely won't do much or it will slow things down just due to how GPUs work. DistributedArrays require parallel linear solves to really matter, and thus are only recommended when you have a problem that cannot fit into memory or are using a stiff solver with a Krylov method for the linear solves.</p><h4><a class="nav-anchor" href="#My-ODE-is-solving-really-slow...-what-do-I-do?-1" id="My-ODE-is-solving-really-slow...-what-do-I-do?-1">My ODE is solving really slow... what do I do?</a></h4><p>First, check for bugs. These solvers go through a ton of convergence tests and so if there's a solver issue, it's either just something to do with how numerical methods work or it's a user-error (generally the latter, though check the later part of the FAQ on normal numerical errors). User-errors in the <code>f</code> function causing a divergence of the solution is the most common reason for reported slow codes.</p><p>If you have no bugs, great! The standard tricks for optimizing Julia code then apply. What you want to do first is make sure your function does not allocate. If your system is small (<code>&lt;=100</code> ODEs/SDEs/DDEs/DAEs?), then you should set your system up to use <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>. This is demonstrated <a href="http://docs.juliadiffeq.org/latest/tutorials/ode_example.html#Example-3:-Using-Other-Types-for-Systems-of-Equations-1">in the ODE tutorial</a> with static matrices. Static vectors/arrays are stack-allocated, and thus creating new arrays is free and the compiler doesn't have to heap-allocate any of the temporaries (that's the expensive part!). These have specialized super fast dispatches for arithmetic operations and extra things like QR-factorizations, and thus they are preferred when possible. However, they lose efficiency if they grow too large.</p><p>For anything larger, you should use the <code>in-place</code> syntax <code>f(du,u,p,t)</code> and make sure that your function doesn't allocate. Assuming you know of a <code>u0</code>, you should be able to do:</p><pre><code class="language-julia">du = similar(u0)
@time f(du,u0,p,t)</code></pre><p>and see close to zero allocations and close to zero memory allocated. If you see more, then you might have a type-instability or have temporary arrays. To find type-instabilities, you should do:</p><pre><code class="language-julia">@code_warntype f(du,u,p,t)</code></pre><p>and read the printout to see if there's any types that aren't inferred by the compiler, and fix them. If you have any global variables, you should make them <code>const</code>. As for allocations, some common things that allocate are:</p><ul><li>Array slicing, like <code>u[1:5]</code>. Instead, use <code>@view u[1:5]</code></li><li>Matrix multiplication with <code>*</code>. Instead of <code>A*b</code>, use <code>A_mul_B!(c,A,b)</code> for some pre-allocated cache vector <code>c</code>.</li><li>Non-broadcasted expressions. Every expression on arrays should <code>.=</code> into another array, or it should be re-written to loop and do computations with scalar (or static array) values.</li></ul><p>For an example of optimizing a function resulting from a PDE discretization, see <a href="http://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/">this blog post</a>.</p><h4><a class="nav-anchor" href="#The-stiff-solver-takes-forever-to-take-steps-for-my-PDE-discretization!-Why?-1" id="The-stiff-solver-takes-forever-to-take-steps-for-my-PDE-discretization!-Why?-1">The stiff solver takes forever to take steps for my PDE discretization! Why?</a></h4><p>The solvers for stiff solvers require solving a nonlinear equation each step. In order to do so, they have to do a few Newton steps. By default, these methods assume that the Jacobian is dense, automatically calculate the Jacobian for you, and do a dense factorization. However, in many cases you may want to use alternatives that are more tuned for your problem.</p><p>First of all, when available, it's recommended that you pass a function for computing your Jacobian. This is discussed in the <a href="http://docs.juliadiffeq.org/latest/features/performance_overloads.html#Declaring-Explicit-Jacobians-1">performance overloads</a> section. Jacobians are especially helpful for Rosenbrock methods.</p><p>Secondly, if your Jacobian isn't dense, you shouldn't use a dense Jacobian! In the Sundials algorithm you can set <code>linear_solver=:Band</code> for banded Jacobians for example. More support is coming for this soon.</p><p>But lastly, you shouldn't use a dense factorization for large sparse matrices. Instead, if you're using  a <code>*DiffEq</code> library you should <a href="http://docs.juliadiffeq.org/latest/features/linear_nonlinear.html">specify a linear solver</a>. For Sundials.jl, you should change the <code>linear_solver</code> option. See <a href="http://docs.juliadiffeq.org/latest/solvers/ode_solve.html#Sundials.jl-1">the ODE solve Sundials portion</a> for details on that. Right now, Sundials.jl is the recommended method for stiff problems with large sparse Jacobians. <code>linear_solver=:Band</code> should be used if your Jacobian is banded and you can specify the band sizes. If you only know the Jacobian is sparse, <code>linear_solver=:GMRES</code> is a good option. Once again, a good reference for how to handle PDE discretizations can be found <a href="http://www.stochasticlifestyle.com/solving-systems-stochastic-pdes-using-gpus-julia/">at this blog post</a>.</p><h2><a class="nav-anchor" href="#Complicated-Models-1" id="Complicated-Models-1">Complicated Models</a></h2><h4><a class="nav-anchor" href="#Can-I-switch-my-ODE-function-in-the-middle-of-integration?-1" id="Can-I-switch-my-ODE-function-in-the-middle-of-integration?-1">Can I switch my ODE function in the middle of integration?</a></h4><p>There are a few ways to do this. The simplest way is to just have a parameter to switch between the two. For example:</p><pre><code class="language-julia">function f(du,u,p,t)
  if p == 0
    du[1] = 2u[1]
  else
    du[1] = -2u[1]
  end
  du[2] = -u[2]
end</code></pre><p>Then in a callback you can make the <code>affect!</code> function modify <code>integrator.prob.p</code>. For example, we can make it change when <code>u[2]&lt;0.5</code> via:</p><pre><code class="language-julia">condition(t,u,integrator) = u[2] - 0.5
affect!(integrator) = integrator.prob.p = 1</code></pre><p>Then it will change betweeen the two ODE choices for <code>du1</code> at that moment. Another way to do this is to make the ODE functions all be the same type via FunctionWrappers.jl, but that is unnecessary. With the way that modern processors work, there exists branch prediction and thus execution of a conditional is free if it's predictable which branch will be taken. In this case, almost every call to <code>f</code> takes the <code>p==0</code> route until the callback, at which point it is almost always the <code>else</code> route. Therefore the processor will effectively get rid of the computational cost associated with this, so you're likely over-optimizing if you're going further (unless this change happens every step, but even then this is probably the cheapest part of the computation...).</p><h2><a class="nav-anchor" href="#Numerical-Error-1" id="Numerical-Error-1">Numerical Error</a></h2><h4><a class="nav-anchor" href="#The-solver-doesn&#39;t-obey-physical-law-X-(e.g.-conservation-of-energy)-1" id="The-solver-doesn&#39;t-obey-physical-law-X-(e.g.-conservation-of-energy)-1">The solver doesn't obey physical law X (e.g. conservation of energy)</a></h4><p>Yes, this is because the numerical solution of the ODE is not the exact solution. There are a few ways that you can handle this problem. One way is to get a more exact solution. Thus instead of</p><pre><code class="language-julia">sol = solve(prob,alg)</code></pre><p>use</p><pre><code class="language-julia">sol = solve(prob,alg,abstol=1e-10,reltol=1e-10)</code></pre><p>Of course, there's always a tradeoff between accuracy and efficiency, so play around to find out what's right for your problem.</p><p>Another thing you can do is use a callback. There are some <a href="http://docs.juliadiffeq.org/latest/features/callback_library.html">premade callbacks in the callback library</a> which handle these sorts of things like projecting to manifolds and preserving positivity.</p><h5><a class="nav-anchor" href="#The-symplectic-integrator-doesn&#39;t-conserve-energy?-1" id="The-symplectic-integrator-doesn&#39;t-conserve-energy?-1">The symplectic integrator doesn't conserve energy?</a></h5><p>Yes, symplectic integrators do not exactly conserve energy. It is a common misconception that they do. What symplectic integrators actually do is solve for a trajectory which rests on a symplectic manifold that is perturbed from the true solution's manifold by the truncation error. This means that symplectic integrators do not experience (very much) long time drift, but their orbit is not exactly the same as the true solution in phase space and thus you will see differences in energy that tend to look periodic. There is a small drift which grows linearly and is related to floating point error, but this drift is much less than standard methods. This is why symplectic methods are recommended for long time integration.</p><p>For conserving energy, there are a few things you can do. First of all, the energy error is related to the integration error, so simply solving with higher accuracy will reduce the error. The results in the <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">DiffEqBenchmarks</a> show that using a <code>DPRKN</code> method with low tolerance can be a great choice. Another thing you can do is use <a href="http://docs.juliadiffeq.org/latest/features/callback_library.html">the ManifoldProjection callback from the callback library</a>.</p><h4><a class="nav-anchor" href="#How-do-I-get-to-zero-error?-1" id="How-do-I-get-to-zero-error?-1">How do I get to zero error?</a></h4><p>You can't. For floating point numbers, you shouldn't use below <code>abstol=1e-14</code> and <code>reltol=1e-14</code>. If you need lower than that, use arbitrary precision numbers like BigFloats or <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">ArbFloats.jl</a>.</p><h2><a class="nav-anchor" href="#Autodifferentiation-and-Dual-Numbers-1" id="Autodifferentiation-and-Dual-Numbers-1">Autodifferentiation and Dual Numbers</a></h2><h4><a class="nav-anchor" href="#Are-the-native-Julia-solvers-compatible-with-autodifferentiation?-1" id="Are-the-native-Julia-solvers-compatible-with-autodifferentiation?-1">Are the native Julia solvers compatible with autodifferentiation?</a></h4><p>Yes! However, you should first look into <a href="http://docs.juliadiffeq.org/latest/analysis/sensitivity.html">sensitivity analysis</a> as a (possibly in the future) more efficient method for calculating derivatives of the solution and functionals of the solution.</p><p>But if you still want to do it the naive way, here's how you do it. If the algorithm does not use adaptive time stepping, then you simply need to make the initial condition have elements of Dual numbers. If the algorithm uses Dual numbers, you need to make sure that time is also given by Dual numbers. A quick explanation of this is because changing the value of the initial condition will change the error in the steps, thus causing different steps to be taken changing the time values.</p><p>To show this in action, let's say we want to find the Jacobian of solution of the Lotka-Volterra equation at <code>t=10</code> with respect to the parameters.</p><pre><code class="language-julia">function func(du,u,p,t)
  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]
  du[2] = -3 * u[2] + u[1]*u[2]
end
function f(p)
  prob = ODEProblem(func,eltype(p).([1.0,1.0]),eltype(p).((0.0,10.0)),p)
  solve(prob,Tsit5(),save_everystep=false)[end]
end</code></pre><p>This function takes in new parameters and spits out the solution at the end. We make the inital condition <code>eltype(p).([1.0,1.0])</code> so that way it's typed to be Dual numbers whenever <code>p</code> is an array of <code>Dual</code> numbers, and we do the same for the timespan. Then we can take the Jacobian via ForwardDiff.jl:</p><pre><code class="language-julia">using ForwardDiff
ForwardDiff.jacobian(f,[1.5,1.0])

2Ã2 Array{Float64,2}:
  2.20214   0.189782
 -6.2273   -0.700188</code></pre><p>and compare it to Calculus.jl:</p><pre><code class="language-julia">Calculus.jacobian(f,[1.5,1.0],:central)

2Ã2 Array{Float64,2}:
  2.20214   0.189782
 -6.2273   -0.700188</code></pre><h4><a class="nav-anchor" href="#I-get-Dual-number-errors-when-I-solve-my-ODE-with-Rosenbrock-or-SDIRK-methods...?-1" id="I-get-Dual-number-errors-when-I-solve-my-ODE-with-Rosenbrock-or-SDIRK-methods...?-1">I get Dual number errors when I solve my ODE with Rosenbrock or SDIRK methods...?</a></h4><p>This is because you're using a cache which is not compatible with autodifferentiaion via ForwardDiff.jl. For example, if we use the ODE function:</p><pre><code class="language-julia">const tmp = zeros(4)
const A = rand(4,4)
function f(du,u,p,t)
  A_mul_B!(tmp,A,u)
  du .= tmp .+ u
end</code></pre><p>Here we use a cached temporary array in order to avoid the allocations of matrix multiplication. When autodifferentiation occurs, the element type of <code>u</code> is <code>Dual</code> numbers, so <code>A*u</code> produces <code>Dual</code> numbers, so the error arises when it tries to write into <code>tmp</code>. There are two ways to avoid this. The first way, the easy way, is to just turn off autodifferentiation with the <code>autodiff=false</code> option in the solver. Every solver which uses autodifferentiation has this option. Thus we'd solve this with:</p><pre><code class="language-julia">prob = ODEProblem(f,rand(4),(0.0,1.0))
sol = solve(prob,Rosenbrock23(autodiff=false))</code></pre><p>and it will use a numerical differentiation fallback (DiffEqDiffTools.jl) to calculate Jacobians.</p><p>** Warning: Advanced **</p><p>The more difficult way is to create a Dual cache which dispatches for the cache choice based on the element type of <code>u</code>. This is done by the following:</p><pre><code class="language-julia">using ForwardDiff
struct MyTag end
immutable DiffCache{T&lt;:AbstractArray, S&lt;:AbstractArray}
    du::T
    dual_du::S
end

function DiffCache{chunk_size}(T, size, ::Type{Val{chunk_size}})
    DiffCache(zeros(T, size...), zeros(ForwardDiff.Dual{nothing,T,chunk_size}, size...))
end

DiffCache(u::AbstractArray) = DiffCache(eltype(u),size(u),Val{ForwardDiff.pickchunksize(length(u))})

get_tmp{T&lt;:ForwardDiff.Dual}(dc::DiffCache, ::Type{T}) = dc.dual_du
get_tmp(dc::DiffCache, T) = dc.du</code></pre><p>Now we can get a cache that by dispatch either gives a cache array of <code>Dual</code> numbers or just floating point numbers:</p><pre><code class="language-julia">const dual_cache = DiffCache(rand(4)) # Build the cache, this must match your IC
du = get_tmp(dual_cache,typeof(rand(4))) # Gives a Array{Float64}
dual_du = get_tmp(dual_cache,typeof(ForwardDiff.Dual(0.2,3.0))) # Gives Array{Dual}</code></pre><p>Note that you have to make sure that your chunk size matches the choice in the ODE solver (by default, it uses <code>ForwardDiff.pickchunksize(length(u))</code> as well, so you only need to change this if you explicitly set <code>chunksize = ...</code>). Now we can setup and solve our ODE using this cache:</p><pre><code class="language-julia">function f(du,u,p,t)
  # Get du from cache
  tmp = get_tmp(dual_cache,eltype(u))
  # Fix tag
  _tmp = reinterpret(eltype(u),tmp)
  A_mul_B!(_tmp,A,u)
  du .= _tmp .+ u
end
prob = ODEProblem(f,rand(4),(0.0,1.0))
sol = solve(prob,Rosenbrock23())</code></pre><p>Small explanation is in order. <code>tmp = get_tmp(dual_cache,eltype(u))</code> makes <code>tmp</code> match <code>u</code> in terms of <code>Dual</code> or not, but it doesn't necessarily match the tag. So now we <code>reinterpret</code> our <code>Dual</code> array to put the right tag on there. Note that this simply changes type information and thus does not create any temporary arrays. Once we do that, our cached array is now typed correctly to hold the result of <code>A_mul_B!</code>.</p><footer><hr/><a class="previous" href="problem.html"><span class="direction">Previous</span><span class="title">Problem interface</span></a><a class="next" href="compatibility_chart.html"><span class="direction">Next</span><span class="title">Solver Compatibility Chart</span></a></footer></article></body></HTML>