<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Noise Processes Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/features/noise_process/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li class="current"><a class="toctext" href="noise_process.html">Noise Processes</a><ul class="internal"><li><a class="toctext" href="#Using-Noise-Processes-1">Using Noise Processes</a></li><li><a class="toctext" href="#Noise-Process-Types-1">Noise Process Types</a></li><li><a class="toctext" href="#Non-Standard-Noise-Processes-1">Non-Standard Noise Processes</a></li><li><a class="toctext" href="#Examples-Using-Non-Standard-Noise-Processes-1">Examples Using Non-Standard Noise Processes</a></li></ul></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="noise_process.html">Noise Processes</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/noise_process.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Noise Processes</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Noise-Processes-1" id="Noise-Processes-1">Noise Processes</a></h1><p>Noise processes are essential in continuous stochastic modeling. The <code>NoiseProcess</code> types are distributionally-exact, meaning they are not solutions of stochastic differential equations and instead are directly generated according to their analytical distributions. These processes are used as the noise term in the SDE and RODE solvers. Additionally, the noise processes themselves can be simulated and solved using the DiffEq common interface (including the Monte Carlo interface).</p><p>This page first describes how to use noise processes in SDEs, and analyze/simulate them directly noise processes. Then it describes the standard noise processes which are available. Processes like <code>WienerProcess</code>, <code>CorrelatedWienerProcess</code>, <code>GeometricBrownianMotionProcess</code>, <code>BrownianBridgeProcess</code> and <code>OrnsteinUhlenbeckProcess</code> are pre-defined. Then it is shown how one can define the distributions for a new <code>NoiseProcess</code>.</p><p>In addition to the <code>NoiseProcess</code> type, more general <code>AbstractNoiseProcess</code>es are defined. The <code>NoiseGrid</code> allows you to define a noise process from a set of pre-calculated points (the "normal" way). The <code>NoiseApproximation</code> allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations.</p><p>The <code>NoiseWrapper</code> allows one to wrap a <code>NoiseProcess</code> from a previous simulation to re-use it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example solving with a smaller <code>dt</code>) in a distributionally-exact manner. It is demonstrated how the <code>NoiseWrapper</code> can be used to wrap the <code>NoiseProcess</code> of one SDE/RODE solution in order to re-use the same noise process in another simulation.</p><p>Lastly, the <code>NoiseFunction</code> allows you to use any function of time as the noise process. Together, this functionality allows you to define any colored noise process and use this efficiently and accurately in your simulations.</p><h2><a class="nav-anchor" href="#Using-Noise-Processes-1" id="Using-Noise-Processes-1">Using Noise Processes</a></h2><h3><a class="nav-anchor" href="#Passing-a-Noise-Process-to-a-Problem-Type-1" id="Passing-a-Noise-Process-to-a-Problem-Type-1">Passing a Noise Process to a Problem Type</a></h3><p><code>AbstractNoiseProcess</code>es can be passed directly to the problem types to replace the standard Wiener process (Brownian motion) with your choice of noise. To do this, simply construct the noise and pass it to the <code>noise</code> keyword argument:</p><pre><code class="language-julia">Î¼ = 1.0
Ï = 2.0
W = GeometricBrownianMotionProcess(Î¼,Ï,0.0,1.0,1.0)
# ...
# Define f,g,u0,tspan for a SDEProblem
# ...
prob = SDEProblem(f,g,u0,tspan,noise=W)</code></pre><h3><a class="nav-anchor" href="#Basic-Interface-1" id="Basic-Interface-1">Basic Interface</a></h3><p>The <code>NoiseProcess</code> acts like a DiffEq solution. For some noise process <code>W</code>, you can get its <code>i</code>th timepoint like <code>W[i]</code> and the associated time <code>W.t[i]</code>. If the <code>NoiseProcess</code> has a bridging distribution defined, it can be interpolated to arbitrary time points using <code>W(t)</code>. Note that every interpolated value is saved to the <code>NoiseProcess</code> so that way it can stay distributionally correct. A plot recipe is provided which plots the timeseries.</p><h3><a class="nav-anchor" href="#Direct-Simulation-of-the-Noise-Process-1" id="Direct-Simulation-of-the-Noise-Process-1">Direct Simulation of the Noise Process</a></h3><p>Since the <code>NoiseProcess</code> types are distribution-exact and do not require the stochastic differential equation solvers, many times one would like to directly simulate trajectories from these proecesses. The <code>NoiseProcess</code> has a <code>NoiseProcessProblem</code> type:</p><pre><code class="language-julia">NoiseProblem(noise,tspan)</code></pre><p>for which <code>solve</code> works. For example, we can simulate a distributionally-exact Geometric Brownian Motion solution by:</p><pre><code class="language-julia">Î¼ = 1.0
Ï = 2.0
W = GeometricBrownianMotionProcess(Î¼,Ï,0.0,1.0,1.0)
prob = NoiseProblem(W,(0.0,1.0))
sol = solve(prob;dt=0.1)</code></pre><p><code>solve</code> requires the <code>dt</code> is given, the solution it returns is a <code>NoiseProcess</code> which has stepped through the timespan. Because this follows the common interface, all of the normal functionality works. For example, we can use the Monte Carlo functionality as follows:</p><pre><code class="language-julia">monte_prob = MonteCarloProblem(prob)
sol = solve(monte_prob;dt=0.1,num_monte=100)</code></pre><p>simulates 100 Geometric Brownian Motions.</p><h3><a class="nav-anchor" href="#Direct-Interface-1" id="Direct-Interface-1">Direct Interface</a></h3><p>Most of the time, a <code>NoiseProcess</code> is received from the solution of a stochastic or random differential equation, in which case <code>sol.W</code> gives the <code>NoiseProcess</code> and it is already defined along some timeseries. In other cases, <code>NoiseProcess</code> types are directly simulated (see below). However, <code>NoiseProcess</code> types can also be directly acted on. The basic functionality is given by <code>calculate_step!</code> to calculate a future time point, and <code>accept_step!</code> to accept the step. If steps are rejected, the Rejection Sampling with Memory algorithm is applied to keep the solution distributionally exact. This kind of stepping is done via:</p><pre><code class="language-julia">W = WienerProcess(0.0,1.0,1.0)
dt = 0.1
W.dt = dt
setup_next_step!(W)
for i in 1:10
  accept_step!(W,dt)
end</code></pre><h2><a class="nav-anchor" href="#Noise-Process-Types-1" id="Noise-Process-Types-1">Noise Process Types</a></h2><p>This section describes the available <code>NoiseProcess</code> types.</p><h3><a class="nav-anchor" href="#Wiener-Process-(White-Noise)-1" id="Wiener-Process-(White-Noise)-1">Wiener Process (White Noise)</a></h3><p>The <code>WienerProcess</code>, also known as Gaussian white noise, Brownian motion, or the noise in the Langevin equation, is the stationary process with distribution <code>N(0,t)</code>. The constructor is:</p><pre><code class="language-julia">WienerProcess(t0,W0,Z0=nothing)
WienerProcess!(t0,W0,Z0=nothing)</code></pre><h3><a class="nav-anchor" href="#Correlated-Noise-1" id="Correlated-Noise-1">Correlated Noise</a></h3><p>One can define a <code>CorrelatedWienerProcess</code> which is a Wiener process with correlations between the Wiener processes. The constructor is:</p><pre><code class="language-julia">CorrelatedWienerProcess(Î,t0,W0,Z0=nothing)
CorrelatedWienerProcess!(Î,t0,W0,Z0=nothing)</code></pre><p>where <code>Î</code> is the constant covariance matrix.</p><h3><a class="nav-anchor" href="#Geometric-Brownian-Motion-1" id="Geometric-Brownian-Motion-1">Geometric Brownian Motion</a></h3><p>A <code>GeometricBrownianMotion</code> process is a Wiener process with constant drift <code>Î¼</code> and constant diffusion <code>Ï</code>. I.e. this is the solution of the stochastic differential equation</p><div>\[dX_t = \mu X_t dt + \sigma X_t dW_t\]</div><p>The <code>GeometricBrownianMotionProcess</code> is distribution exact (meaning, not a numerical solution of the stochastic differential equation, and instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:</p><pre><code class="language-julia">GeometricBrownianMotionProcess(Î¼,Ï,t0,W0,Z0=nothing)
GeometricBrownianMotionProcess!(Î¼,Ï,t0,W0,Z0=nothing)</code></pre><h3><a class="nav-anchor" href="#Brownian-Bridge-1" id="Brownian-Bridge-1">Brownian Bridge</a></h3><p>A <code>BrownianBridge</code> process is a Wiener process with a pre-defined start and end value. This process is distribution exact and back be back interpolated exactly as well. The constructor is:</p><pre><code class="language-julia">BrownianBridge(t0,tend,W0,Wend,Z0=nothing,Zend=nothing)
BrownianBridge!(t0,tend,W0,Wend,Z0=nothing,Zend=nothing)</code></pre><p>where <code>W(t0)=Wâ</code>, <code>W(tend)=Wend</code>, and likewise for the <code>Z</code> process if defined.</p><h3><a class="nav-anchor" href="#Ornstein-Uhlenbeck-1" id="Ornstein-Uhlenbeck-1">Ornstein-Uhlenbeck</a></h3><p>One can define a <code>Ornstein-Uhlenbeck</code> process which is a Wiener process defined by the stochastic differential equation</p><div>\[dX_t = \theta (\mu - X_t) dt + \sigma X_t dW_t\]</div><p>The <code>OrnsteinUhlenbeckProcess</code> is distribution exact (meaning, not a numerical solution of the stochastic differential equation, and instead follows the exact distribution properties). The constructor is:</p><pre><code class="language-julia">OrnsteinUhlenbeckProcess(Î,Î¼,Ï,t0,W0,Z0=nothing)
OrnsteinUhlenbeckProcess!(Î,Î¼,Ï,t0,W0,Z0=nothing)</code></pre><h3><a class="nav-anchor" href="#Direct-Construction-of-a-NoiseProcess-1" id="Direct-Construction-of-a-NoiseProcess-1">Direct Construction of a NoiseProcess</a></h3><p>A <code>NoiseProcess</code> is a type defined as</p><pre><code class="language-julia">NoiseProcess(t0,W0,Z0,dist,bridge;
             iip=DiffEqBase.isinplace(dist,3),
             rswm = RSWM(),save_everystep=true,timeseries_steps=1)</code></pre><ul><li><p><code>t0</code> is the first timepoint</p></li><li><p><code>W0</code> is the first value of the process.</p></li><li><p><code>Z0</code> is the first value of the psudo-process. This is necessary for higher order algorithms. If it's not needed, set to <code>nothing</code>.</p></li><li><p><code>dist</code> the distribution for the steps over time.</p></li><li><p><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</p></li><li><p><code>save_everystep</code> whether to save every step of the Brownian timeseries.</p></li><li><p><code>timeseries_steps</code> number of points to skip between each timeseries save.</p></li></ul><p>The signature for the <code>dist</code> is</p><pre><code class="language-julia">dist!(rand_vec,W,dt)</code></pre><p>for inplace functions, and</p><pre><code class="language-julia">rand_vec = dist(W,dt)</code></pre><p>otherwise. The signature for <code>bridge</code> is</p><pre><code class="language-julia">bridge!(rand_vec,W,W0,Wh,q,h)</code></pre><p>and the out of place syntax is</p><pre><code class="language-julia">rand_vec = bridge!(W,W0,Wh,q,h)</code></pre><p>Here, <code>W</code> is the noise process, <code>W0</code> is the left side of the current interval, <code>Wh</code> is the right side of the current interval, <code>h</code> is the interval length, and <code>q</code> is the proportion from the left where the interpolation is occuring.</p><h3><a class="nav-anchor" href="#Direct-Construction-Example-1" id="Direct-Construction-Example-1">Direct Construction Example</a></h3><p>The easiest way to show how to directly construct a <code>NoiseProcess</code> is by example. Here we will show how to directly construct a <code>NoiseProcess</code> which generates Gaussian white noise.</p><p>This is the noise process which uses <code>randn!</code>. A special dispatch is added for complex numbers for <code>(randn()+im*randn())/sqrt(2)</code>. This function is <code>DiffEqBase.wiener_randn</code> (or with <code>!</code> respectively).</p><p>The first function that must be defined is the noise distribution. This is how to generate <span>$W(t+dt)$</span> given that we know <span>$W(x)$</span> for <span>$xâ[tâ,t]$</span>. For Gaussian white noise, we know that</p><div>\[W(dt) â¼ N(0,dt)\]</div><p>for <span>$W(0)=0$</span> which defines the stepping distribution. Thus its noise distribution function is:</p><pre><code class="language-julia">function WHITE_NOISE_DIST(W,dt)
  if typeof(W.dW) &lt;: AbstractArray
    return sqrt(abs(dt))*wiener_randn(size(W.dW))
  else
    return sqrt(abs(dt))*wiener_randn(typeof(W.dW))
  end
end</code></pre><p>for the out of place versions, and for the inplace versions</p><pre><code class="language-julia">function INPLACE_WHITE_NOISE_DIST(rand_vec,W,dt)
  wiener_randn!(rand_vec)
  rand_vec .*= sqrt(abs(dt))
end</code></pre><p>Optionally, we can provide a bridging distribution. This is the distribution of <span>$W(qh)$</span> for <span>$qâ[0,1]$</span> given that we know <span>$W(0)=0$</span> and <span>$W(h)=Wâ$</span>. For Brownian motion, this is known as the Brownian Bridge, and is well known to have the distribution:</p><div>\[W(qh) â¼ N(qWâ,(1-q)qh)\]</div><p>Thus we have the out-of-place and in-place versions as:</p><pre><code class="language-julia">function WHITE_NOISE_BRIDGE(W,W0,Wh,q,h)
  sqrt((1-q)*q*abs(h))*wiener_randn(typeof(W.dW))+q*Wh
end
function INPLACE_WHITE_NOISE_BRIDGE(rand_vec,W,W0,Wh,q,h)
  wiener_randn!(rand_vec)
  rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*Wh
end</code></pre><p>These functions are then placed in a noise process:</p><pre><code class="language-julia">NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE;kwargs)
NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE;kwargs)</code></pre><p>Notice that we can optionally provide an alternative adaptive algorithm for the timestepping rejections. <code>RSWM()</code> defaults to the Rejection Sampling with Memory 3 algorithm (RSwM3).</p><p>Note that the standard constructors are simply:</p><pre><code class="language-julia">WienerProcess(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE;kwargs)
WienerProcess!(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE;kwargs)</code></pre><p>These will generate a Wiener process, which can be stepped with <code>step!(W,dt)</code>, and interpolated as <code>W(t)</code>.</p><h2><a class="nav-anchor" href="#Non-Standard-Noise-Processes-1" id="Non-Standard-Noise-Processes-1">Non-Standard Noise Processes</a></h2><p>In addition to the mathematically-defined noise processes above, there exist more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations.</p><h3><a class="nav-anchor" href="#NoiseWrapper-1" id="NoiseWrapper-1">NoiseWrapper</a></h3><p>This produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to re-use a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.</p><p>To wrap a noise process, simply use:</p><pre><code class="language-julia">NoiseWrapper(W::NoiseProcess)</code></pre><h3><a class="nav-anchor" href="#NoiseFunction-1" id="NoiseFunction-1">NoiseFunction</a></h3><p>This allows you to use any arbitrary function <code>W(t)</code> as a <code>NoiseProcess</code>. This will use the function lazily, only caching values required to minimize function calls, but not store the entire noise array. This requires an initial time point <code>t0</code> in the domain of <code>W</code>. A second function is needed if the desired SDE algorithm requires multiple processes.</p><pre><code class="language-julia">NoiseFunction(t0,W,Z=nothing;noise_prototype=W(t0))</code></pre><p>Additionally, one can use an in-place function <code>W(out1,out2,t)</code> for more efficient generation of the arrays for multi-dimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the <code>noise_prototype</code> needs to be set.</p><h3><a class="nav-anchor" href="#NoiseGrid-1" id="NoiseGrid-1">NoiseGrid</a></h3><p>A noise grid builds a noise process from arrays of points. For example, you can generate your desired noise process as an array <code>W</code> with timepoints <code>t</code>, and use the constructor:</p><pre><code class="language-julia">NoiseGrid(t,W,Z=nothing)</code></pre><p>to build the associated noise process. This process comes with a linear interpolation of the given points, and thus the grid does not have to match the grid of integration. Thus this can be used for adaptive solutions as well. However, one must make note that the fidelity of the noise process is linked to how fine the noise grid is determined: if the noise grid is sparse on points compared to the integration, then its distributional properties may be slightly perturbed by the linear interpolation. Thus its suggested that the grid size at least approximately match the number of time steps in the integration to ensure accuracy.</p><p>For a one-dimensional process, <code>W</code> should be an <code>AbstractVector</code> of <code>Number</code>s. For multi-dimensional processes, <code>W</code> should be an <code>AbstractVector</code> of the <code>noise_prototype</code>.</p><h3><a class="nav-anchor" href="#NoiseApproximation-1" id="NoiseApproximation-1">NoiseApproximation</a></h3><p>In many cases, one would like to define a noise process directly by a stochastic differential equation which does not have an analytical solution. Of course, this will not be distributionally-exact and how well the properties match depends on how well the differential equation is integrated, but in many cases this can be used as a good approximation when other methods are much more difficult.</p><p>A <code>NoiseApproximation</code> is defined by a <code>DEIntegrator</code>. The constructor for a <code>NoiseApproximation</code> is:</p><pre><code class="language-julia">NoiseApproximation(source1::DEIntegrator,source2::Union{DEIntegrator,Void}=nothing)</code></pre><p>The <code>DEIntegrator</code> should have a final time point of integration far enough such that it will not halt during the integration. For ease of use, you can use a final time point as <code>Inf</code>. Note that the time points do not have to match the time points of the future integration since the interpolant of the SDE solution will be used. Thus the limiting factor is error tolerance and not hitting specific points.</p><h2><a class="nav-anchor" href="#Examples-Using-Non-Standard-Noise-Processes-1" id="Examples-Using-Non-Standard-Noise-Processes-1">Examples Using Non-Standard Noise Processes</a></h2><h3><a class="nav-anchor" href="#NoiseGrid-2" id="NoiseGrid-2">NoiseGrid</a></h3><p>In this example, we will show you how to define your own version of Brownian motion using an array of pre-calculated points. In normal usage you should use <code>WienerProcess</code> instead since this will have distributionally-exact interpolations while the noise grid uses linear interpolations, but this is a nice example of the workflow.</p><p>To define a <code>NoiseGrid</code> you need to have a set of time points and a set of values for the process. Let's define a Brownian motion on <code>(0.0,1.0)</code> with a <code>dt=0.001</code>. To do this,</p><pre><code class="language-julia">dt = 0.001
t = 0:dt:1
brownian_values = cumsum([0;[sqrt(dt)*randn() for i in 1:length(t)-1]])</code></pre><p>Now we build the <code>NoiseGrid</code> using these values:</p><pre><code class="language-julia">W = NoiseGrid(t,brownian_values)</code></pre><p>We can then pass <code>W</code> as the <code>noise</code> argument of an <code>SDEProblem</code> to use it in an SDE.</p><h3><a class="nav-anchor" href="#NoiseWrapper-Example-1" id="NoiseWrapper-Example-1">NoiseWrapper Example</a></h3><p>In this example, we will solve an SDE three times:</p><ul><li><p>First to generate a noise process</p></li><li><p>Second with the same timesteps to show the values are the same</p></li><li><p>Third with half-sized timsteps</p></li></ul><p>First we will generate a noise process by solving an SDE:</p><pre><code class="language-julia">using StochasticDiffEq,  DiffEqBase, DiffEqNoiseProcess
f1(t,u) = 1.01u
g1(t,u) = 1.01u
dt = 1//2^(4)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0))
sol1 = solve(prob1,EM(),dt=dt)</code></pre><p>Now we wrap the noise into a NoiseWrapper and solve the same problem:</p><pre><code class="language-julia">W2 = NoiseWrapper(sol1.W)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W2)
sol2 = solve(prob1,EM(),dt=dt)</code></pre><p>We can test</p><pre><code class="language-julia">@test sol1.u â sol2.u</code></pre><p>to see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller <code>dt</code>:</p><pre><code class="language-julia">W3 = NoiseWrapper(sol1.W)
prob2 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W3)

dt = 1//2^(5)
sol3 = solve(prob2,EM(),dt=dt)</code></pre><p>We can plot the results to see what this looks like:</p><pre><code class="language-julia">using Plots
plot(sol1)
plot!(sol2)
plot!(sol3)</code></pre><p><img alt="noise_process" src="../assets/noise_process.png"/></p><p>In this plot, <code>sol2</code> covers up <code>sol1</code> because they hit essentially the same values. You can see that <code>sol3</code> its similar to the others, because it's using the same underlying noise process just sampled much finer.</p><p>To double check, we see that:</p><pre><code class="language-julia">plot(sol1.W)
plot!(sol2.W)
plot!(sol3.W)</code></pre><p><img alt="coupled_wiener" src="../assets/coupled_wiener.png"/></p><p>the coupled Wiener processes coincide at every other time point, and the intermediate timepoints were calculated according to a Brownian bridge.</p><h3><a class="nav-anchor" href="#Adaptive-NoiseWrapper-Example-1" id="Adaptive-NoiseWrapper-Example-1">Adaptive NoiseWrapper Example</a></h3><p>Here we will show that the same noise can be used with the adaptive methods using the <code>NoiseWrapper</code>. <code>SRI</code> and <code>SRIW1</code> use slightly different error estimators, and thus give slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:</p><pre><code class="language-julia">prob = SDEProblem(f1,g1,ones(2),(0.0,1.0))
sol4 = solve(prob,SRI(),abstol=1e-8)

W2 = NoiseWrapper(sol4.W)
prob2 = SDEProblem(f1,g1,ones(2),(0.0,1.0),noise=W2)
sol5 = solve(prob2,SRIW1(),abstol=1e-8)

using Plots
plot(sol4)
plot!(sol5)</code></pre><p><img alt="SRI_SRIW1_diff" src="../assets/SRI_SRIW1_diff.png"/></p><h3><a class="nav-anchor" href="#NoiseApproximation-Example-1" id="NoiseApproximation-Example-1">NoiseApproximation Example</a></h3><p>In this example we will show how to use the <code>NoiseApproximation</code> in order to build our own Geometric Brownian Motion from its stochastic differential equation definition. In normal usage, you should use the <code>GeometricBrownianMotionProcess</code> instead since that is more efficient and distributionally-exact.</p><p>First, let's define the <code>SDEProblem</code>. Here will use a timespan <code>(0.0,Inf)</code> so that way the noise can be used over an indefinite integral.</p><pre><code class="language-julia">const Î¼ = 1.5
const Ï = 1.2
f(t,u) = Î¼*u
g(t,u) = Ï*u
prob = SDEProblem(f,g,1.0,(0.0,Inf))</code></pre><p>Now we build the noise process by building the integrator and sending that integrator to the <code>NoiseApproximation</code> constructor:</p><pre><code class="language-julia">integrator = init(prob,SRIW1())
W = NoiseApproximation(integrator)</code></pre><p>We can use this noise process like any other noise process. For example, we can now build a geometric Brownian motion whose noise process is colored noise that itself is a geometric Brownian motion:</p><pre><code class="language-julia">prob = SDEProblem(f,g,1.0,(0.0,Inf),noise=W)</code></pre><p>The possibilities are endless.</p><h3><a class="nav-anchor" href="#NoiseFunction-Example-1" id="NoiseFunction-Example-1">NoiseFunction Example</a></h3><p>The <code>NoiseFunction</code> is pretty simple: pass a function. As a silly example, we can use <code>exp</code> as a noise process by doing:</p><pre><code class="language-julia">f(t) = exp(t)
W = NoiseFunction(0.0,f)</code></pre><p>If it's multi-dimensional and an in-place function is used, the <code>noise_prototype</code> must be given. For example:</p><pre><code class="language-julia">f(out,t) = (out.=exp(t))
W = NoiseFunction(0.0,f,noise_prototype=rand(4))</code></pre><p>This allows you to put arbitrarily weird noise into SDEs and RODEs. Have fun.</p><footer><hr/><a class="previous" href="diffeq_operator.html"><span class="direction">Previous</span><span class="title">DiffEqOperators</span></a><a class="next" href="linear_nonlinear.html"><span class="direction">Next</span><span class="title">Specifying (Non)Linear Solvers</span></a></footer></article></body></HTML>