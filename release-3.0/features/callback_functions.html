<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Event Handling and Callback Functions Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/features/callback_functions/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="noise_process.html">Noise Processes</a></li><li><a class="toctext" href="linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li class="current"><a class="toctext" href="callback_functions.html">Event Handling and Callback Functions</a><ul class="internal"><li><a class="toctext" href="#Introduction-to-Callback-Functions-1">Introduction to Callback Functions</a></li><li><a class="toctext" href="#The-Callback-Types-1">The Callback Types</a></li><li><a class="toctext" href="#Using-Callbacks-1">Using Callbacks</a></li><li><a class="toctext" href="#DiscreteCallback-Examples-1">DiscreteCallback Examples</a></li><li><a class="toctext" href="#ContinuousCallback-Examples-1">ContinuousCallback Examples</a></li></ul></li><li><a class="toctext" href="callback_library.html">Callback Library</a></li><li><a class="toctext" href="monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="mesh.html">Meshes</a></li><li><a class="toctext" href="progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Additional Features</li><li><a href="callback_functions.html">Event Handling and Callback Functions</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/features/callback_functions.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Event Handling and Callback Functions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Event-Handling-and-Callback-Functions-1" id="Event-Handling-and-Callback-Functions-1">Event Handling and Callback Functions</a></h1><h2><a class="nav-anchor" href="#Introduction-to-Callback-Functions-1" id="Introduction-to-Callback-Functions-1">Introduction to Callback Functions</a></h2><p>DifferentialEquations.jl allows for using callback functions to inject user code into the solver algorithms. It allows for safely and accurately applying events and discontinuities. Multiple callbacks can be chained together, and these callback types can be used to build libraries of extension behavior.</p><h2><a class="nav-anchor" href="#The-Callback-Types-1" id="The-Callback-Types-1">The Callback Types</a></h2><p>The callback types are defined as follows. There are two callback types: the <code>ContinuousCallback</code> and the <code>DiscreteCallback</code>. The <code>ContinuousCallback</code> is applied when a continuous condition function hits zero. This type of callback implements what is known in other problem solving environments as an Event. A <code>DiscreteCallback</code> is applied when its <code>condition</code> function is <code>true</code>.</p><h3><a class="nav-anchor" href="#ContinuousCallbacks-1" id="ContinuousCallbacks-1">ContinuousCallbacks</a></h3><pre><code class="language-julia">ContinuousCallback(condition,affect!,affect_neg!=affect!;
                   rootfind = true,
                   initialize = (c,t,u,integrator) -&gt; nothing,
                   save_positions = (true,true),
                   interp_points=10,
                   abstol=1e-12,reltol=0
                   idxs=nothing)</code></pre><p>The arguments are defined as follows:</p><ul><li><p><code>condition</code>: This is a function <code>condition(t,u,integrator)</code> for declaring when the callback should be used. A callback is initiated if the condition hits <code>0</code> within the time interval.</p></li><li><p><code>affect!</code>: This is the function <code>affect!(integrator)</code> where one is allowed to modify the current state of the integrator. If you do not pass an <code>affect_neg!</code> function, it is called when <code>condition</code> is found to be <code>0</code> (at a root) and the cross is either an upcrossing (from negative to positive) or a downcrossing (from positive to negative). You need to explicitly pass <code>nothing</code> as the <code>affect_neg!</code> argument if it should only be called at upcrossings, e.g. <code>ContinuousCallback(condition, affect!, nothing)</code>. For more information on what can be done, see the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> manual page. Modifications to <code>u</code> are safe in this function.</p></li><li><p><code>affect_neg!</code>: This is the function <code>affect_neg!(integrator)</code> where one is allowed to modify the current state of the integrator. This is called when <code>condition</code> is found to be <code>0</code> (at a root) and the cross is an downcrossing (from positive to negative). For more information on what can be done, see the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> manual page. Modifications to <code>u</code> are safe in this function.</p></li><li><p><code>rootfind</code>: This is a boolean for whether to rootfind the event location. If this is set to <code>true</code>, the solution will be backtracked to the point where <code>condition==0</code>. Otherwise the systems and the <code>affect!</code> will occur at <code>t+dt</code>.</p></li><li><p><code>interp_points</code>: The number of interpolated points to check the condition. The condition is found by checking whether any interpolation point / endpoint has a different sign. If <code>interp_points=0</code>, then conditions will only be noticed if the sign of <code>condition</code> is different at <code>t</code> than at <code>t+dt</code>. This behavior is not robust when the solution is oscillatory, and thus it's recommended that one use some interpolation points (they're cheap to compute!). <code>0</code> within the time interval.</p></li><li><p><code>save_positions</code>: Boolean tuple for whether to save before and after the <code>affect!</code>. This saving will occur just before and after the event, only at event times, and does not depend on options like <code>saveat</code>, <code>save_everystep</code>, etc. (i.e. if <code>saveat=[1.0,2.0,3.0]</code>, this can still add a save point at <code>2.1</code> if true). For discontinuous changes like a modification to <code>u</code> to be handled correctly (without error), one should set <code>save_positions=(true,true)</code>.</p></li><li><p><code>idxs</code>: The components which will be interpolated into the condition. Defaults to <code>nothing</code> which means <code>u</code> will be all components.</p></li><li><p><code>initialize</code>: This is a function (c,t,u,integrator) which can be used to initialize the state of the callback <code>c</code>. It should modify the argument <code>c</code> and the return is ignored.</p></li></ul><p>Additionally, keyword arguments for <code>abstol</code> and <code>reltol</code> can be used to specify a tolerance from zero for the rootfinder: if the starting condition is less than the tolerance from zero, then no root will be detected. This is to stop repeat events happening just after a previously rootfound event. The default has <code>abstol=1e-14</code> and <code>reltol=0</code>.</p><h3><a class="nav-anchor" href="#DiscreteCallback-1" id="DiscreteCallback-1">DiscreteCallback</a></h3><pre><code class="language-julia">DiscreteCallback(condition,affect!;
                 save_positions=(true,true),
                 initialize = (c,t,u,integrator) -&gt; nothing)</code></pre><ul><li><p><code>condition</code>: This is a function <code>condition(t,u,integrator)</code> for declaring when the callback should be used. A callback is initiated if the condition evaluates to <code>true</code>.</p></li><li><p><code>affect!</code>: This is the function <code>affect!(integrator)</code> where one is allowed to modify the current state of the integrator. For more information on what can be done, see the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> manual page.</p></li><li><p><code>save_positions</code>: Boolean tuple for whether to save before and after the <code>affect!</code>. This saving will occur just before and after the event, only at event times, and does not depend on options like <code>saveat</code>, <code>save_everystep</code>, etc. (i.e. if <code>saveat=[1.0,2.0,3.0]</code>, this can still add a save point at <code>2.1</code> if true). For discontinuous changes like a modification to <code>u</code> to be handled correctly (without error), one should set <code>save_positions=(true,true)</code>.</p></li><li><p><code>initialize</code>: This is a function (c,t,u,integrator) which can be used to initialize the state of the callback <code>c</code>. It should modify the argument <code>c</code> and the return is ignored.</p></li></ul><h3><a class="nav-anchor" href="#CallbackSet-1" id="CallbackSet-1">CallbackSet</a></h3><p>Multiple callbacks can be chained together to form a <code>CallbackSet</code>. A <code>CallbackSet</code> is constructed by passing the constructor <code>ContinuousCallback</code>, <code>DiscreteCallback</code>, or other <code>CallbackSet</code> instances:</p><pre><code class="language-julia">CallbackSet(cb1,cb2,cb3)</code></pre><p>You can pass as many callbacks as you like. When the solvers encounter multiple callbacks, the following rules apply:</p><ul><li><p><code>ContinuousCallback</code>s are applied before <code>DiscreteCallback</code>s. (This is because they often implement event-finding that will backtrack the timestep to smaller than <code>dt</code>).</p></li><li><p>For <code>ContinuousCallback</code>s, the event times are found by rootfinding and only the first <code>ContinuousCallback</code> affect is applied.</p></li><li><p>The <code>DiscreteCallback</code>s are then applied in order. Note that the ordering only matters for the conditions: if a previous callback modifies <code>u</code> in such a way that the next callback no longer evaluates condition to <code>true</code>, its <code>affect</code> will not be applied.</p></li></ul><h2><a class="nav-anchor" href="#Using-Callbacks-1" id="Using-Callbacks-1">Using Callbacks</a></h2><p>The callback type is then sent to the solver (or the integrator) via the <code>callback</code> keyword argument:</p><pre><code class="language-julia">sol = solve(prob,alg,callback=cb)</code></pre><p>You can supply <code>nothing</code>, a single <code>DiscreteCallback</code> or <code>ContinuousCallback</code>, or a <code>CallbackSet</code>.</p><h3><a class="nav-anchor" href="#Note-About-Saving-1" id="Note-About-Saving-1">Note About Saving</a></h3><p>When a callback is supplied, the default saving behavior is turned off. This is because otherwise events would "double save" one of the values. To re-enable the standard saving behavior, one must have the first <code>save_positions</code> value be true for at least one callback.</p><h3><a class="nav-anchor" href="#Modifying-the-Stepping-Within-A-Callback-1" id="Modifying-the-Stepping-Within-A-Callback-1">Modifying the Stepping Within A Callback</a></h3><p>A common issue with callbacks is that they cause a large discontinuous change, and so it may be wise to pull down <code>dt</code> after such a change. To control the timestepping from a callback, please see <a href="../basics/integrator.html#Stepping-Controls-1">the timestepping controls in the integrator interface</a>. Specifically, <code>set_proposed_dt!</code> is used to set the next stepsize, and <code>terminate!</code> can be used to cause the simulation to stop.</p><h2><a class="nav-anchor" href="#DiscreteCallback-Examples-1" id="DiscreteCallback-Examples-1">DiscreteCallback Examples</a></h2><h3><a class="nav-anchor" href="#Example-1:-AutoAbstol-1" id="Example-1:-AutoAbstol-1">Example 1: AutoAbstol</a></h3><p>MATLAB's Simulink has the option for <a href="https://www.mathworks.com/help/simulink/gui/absolute-tolerance.html">an automatic absolute tolerance</a>. In this example we will implement a callback which will add this behavior to any JuliaDiffEq solver which implments the <code>integrator</code> and callback interface.</p><p>The algorithm is as follows. The default value is set to start at <code>1e-6</code>, though we will give the user an option for this choice. Then as the simulation progresses, at each step the absolute tolerance is set to the maximum value that has been reached so far times the relative tolerance. This is the behavior that we will implement in <code>affect!</code>.</p><p>Since the effect is supposed to occur every timestep, we use the trivial condition:</p><pre><code class="language-julia">condition = function (t,u,integrator)
    true
end</code></pre><p>which always returns true. For our effect we will overload the call on a type. This type will have a value for the current maximum. By doing it this way, we can store the current state for the running maximum. The code is as follows:</p><pre><code class="language-julia">type AutoAbstolAffect{T}
  curmax::T
end
# Now make `affect!` for this:
function (p::AutoAbstolAffect)(integrator)
  p.curmax = max(p.curmax,integrator.u)
  integrator.opts.abstol = p.curmax * integrator.opts.reltol
  u_modified!(integrator,false)
end</code></pre><p>This makes <code>affect!(integrator)</code> use an internal mutating value <code>curmax</code> to update the absolute tolerance of the integrator as the algorithm states.</p><p>Lastly, we can wrap it in a nice little constructor:</p><pre><code class="language-julia">function AutoAbstol(save=true;init_curmax=1e-6)
  affect! = AutoAbstolAffect(init_curmax)
  condtion = (t,u,integrator) -&gt; true
  save_positions = (save,false)
  DiscreteCallback(condtion,affect!,save_positions=save_positions)
end</code></pre><p>This creates the <code>DiscreteCallback</code> from the <code>affect!</code> and <code>condition</code> functions that we implemented. Now</p><pre><code class="language-julia">cb = AutoAbstol(save=true;init_curmax=1e-6)</code></pre><p>returns the callback that we created. We can then solve an equation using this by simply passing it with the <code>callback</code> keyword argument. Using the integrator interface rather than the solve interface, we can step through one by one to watch the absolute tolerance increase:</p><pre><code class="language-julia">integrator = init(prob,BS3(),callback=cb)
at1 = integrator.opts.abstol
step!(integrator)
at2 = integrator.opts.abstol
@test at1 &lt; at2
step!(integrator)
at3 = integrator.opts.abstol
@test at2 &lt; at3</code></pre><p>Note that this example is contained in <a href="https://github.com/JuliaDiffEq/DiffEqCallbacks.jl">DiffEqCallbacks.jl</a>, a library of useful callbacks for JuliaDiffEq solvers.</p><h3><a class="nav-anchor" href="#Example-2:-A-Control-Problem-1" id="Example-2:-A-Control-Problem-1">Example 2: A Control Problem</a></h3><p>Another example of a <code>DiscreteCallback</code> is the <a href="http://docs.juliadiffeq.org/latest/features/diffeq_arrays.html#Example:-A-Control-Problem-1">control problem demonstrated on the DiffEq-specific arrays page</a>.</p><h2><a class="nav-anchor" href="#ContinuousCallback-Examples-1" id="ContinuousCallback-Examples-1">ContinuousCallback Examples</a></h2><h3><a class="nav-anchor" href="#Example-1:-Bouncing-Ball-1" id="Example-1:-Bouncing-Ball-1">Example 1: Bouncing Ball</a></h3><p>Let's look at the bouncing ball. <code>@ode_def</code> from <a href="https://github.com/JuliaDiffEq/ParameterizedFunctions.jl">ParameterizedFunctions.jl</a> was to define the problem, where the first variable <code>y</code> is the height which changes by <code>v</code> the velocity, where the velocity is always changing at <code>-g</code> which is the gravitational constant. This is the equation:</p><pre><code class="language-julia">f = @ode_def_bare BallBounce begin
  dy =  v
  dv = -g
end g=9.81</code></pre><p>All we have to do in order to specify the event is to have a function which should always be positive with an event occurring at 0. For now at least that's how it's specified. If a generalization is needed we can talk about this (but it needs to be "root-findable"). For here it's clear that we just want to check if the ball's height ever hits zero:</p><pre><code class="language-julia">function condition(t,u,integrator) # Event when event_f(t,u) == 0
  u[1]
end</code></pre><p>Notice that here we used the values <code>u</code> instead of the value from the <code>integrator</code>. This is because the values <code>t,u</code> will be appropriately modified at the interpolation points, allowing for the rootfinding behavior to occur.</p><p>Now we have to say what to do when the event occurs. In this case we just flip the velocity (the second variable)</p><pre><code class="language-julia">function affect!(integrator)
  integrator.u[2] = -integrator.u[2]
end</code></pre><p>The callback is thus specified by:</p><pre><code class="language-julia">cb = ContinuousCallback(condition,affect!)</code></pre><p>Then you can solve and plot:</p><pre><code class="language-julia">u0 = [50.0,0.0]
tspan = (0.0,15.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,Tsit5(),callback=cb)
plot(sol)</code></pre><p><img alt="BallBounce" src="../assets/ballbounce.png"/></p><p>As you can see from the resulting image, DifferentialEquations.jl is smart enough to use the interpolation to hone in on the time of the event and apply the event back at the correct time. Thus one does not have to worry about the adaptive timestepping "overshooting" the event as this is handled for you. Notice that the event macro will save the value(s) at the discontinuity.</p><h4><a class="nav-anchor" href="#Tweaking-the-Defaults-to-Specialized-Event-Detection-To-Your-Problem-1" id="Tweaking-the-Defaults-to-Specialized-Event-Detection-To-Your-Problem-1">Tweaking the Defaults to Specialized Event Detection To Your Problem</a></h4><p>Event detection is by nature a difficult issue due to floating point problems. The defaults given by DifferentialEquations.jl works pretty well for most problems where events are well-spaced, but if the events are close to each other (relative to the stepsize), the defaults may need to be tweaked.</p><p>The bouncing ball is a good example of this behavior. Let's see what happens if we change the timespan to be very long:</p><pre><code class="language-julia">u0 = [50.0,0.0]
tspan = (0.0,100.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,Tsit5(),callback=cb)
plot(sol,plotdensity=10000)</code></pre><p><img alt="ball_miss" src="../assets/ball_miss.png"/></p><p>To see why the event was missed, let's see the timesteps:</p><pre><code class="language-julia">println(sol.t)
# [0.0,0.000101935,0.00112128,0.0113148,0.11325,1.1326,3.19275,3.19275,100.0]</code></pre><p>The last timestep was huge! The reason why this happened is because the bouncing ball's solution between discontinuities is only quadratic, and thus a second order method (<code>Tsit5()</code>) can integrate it exactly. This means that the error is essentially zero, and so it will grow <code>dt</code> by <code>qmax</code> every step (for almost all problems this is not an issue that will come up, but it makes this into a good test example).</p><p>One way we can help with event detection is by giving a reasonable limit to the timestep. By default it will allow stepping the size of the whole interval. Let's capt it at 10:</p><pre><code class="language-julia">u0 = [50.0,0.0]
tspan = (0.0,100.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,Tsit5(),callback=cb,dtmax=10)
plot(sol,plotdensity=10000)</code></pre><p><img alt="bounce_long" src="../assets/bounce_long.png"/></p><p>If we don't want to constrain the timestep, we can instead change the <code>interp_points</code>. <code>interp_points</code> is the number of interpolation points used to check for an event. By default it is 10. Here's a little illustration of what's going on when the timestep is unconstrained. To check if there's an event in <code>[3.1925,100.0]</code>, it will check if the sign is different at any timepoint in <code>linspace(3.1925,100.0,interp_points)</code> using an interpolation (cheap, low cost, not function evaluation). Because <code>3.1925</code> was a previous event (and thus too close to zero, as seen by the callback's <code>abstol</code> and <code>reltol</code>), it will ignore the sign there (in order to prevent repeat events) and thus check if the sign changes on <code>[13.94,100.0]</code> where <code>13.94</code> is the first point in the <code>linspace</code>. However, the ball has already gone negative by this point, and thus there is no sign change which means it cannot detect the event.</p><p>This is why, in most cases, increasing the <code>interp_points</code> will help with event detection (another case where this will show up is if the problem is highly oscillatory and you need to detect events inside the interval). Thus we can solve the problem without constraining the timestep by:</p><pre><code class="language-julia">cb = ContinuousCallback(condition,affect!,interp_points=100000)
u0 = [50.0,0.0]
tspan = (0.0,100.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,Tsit5(),callback=cb)
plot(sol,plotdensity=10000)</code></pre><p>Note that the <code>interp_points</code> only has to be that high because the problem is odd in a way that causes large timesteps. Decreasing the <code>interp_points</code> a bit shows another issue that can occur:</p><pre><code class="language-julia">cb = ContinuousCallback(condition,affect!,interp_points=1000)
u0 = [50.0,0.0]
tspan = (0.0,100.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,Tsit5(),callback=cb)
plot(sol,plotdensity=10000)</code></pre><p>In this case there are many events, and it steps working at around <code>t=54.2768</code>:</p><pre><code class="language-julia">println(sol.t)
# [0.0,0.000101935,0.00112128,0.0113148,0.11325,1.1326,3.19275,3.19275,9.57826,9.57826,15.9638,15.9638,22.3493,22.3493,28.7348,28.7348,35.1203,35.1203,41.5058,41.5058,47.8913,47.8913,54.2768,54.2768,54.2768,54.2768,100.0]</code></pre><p>The reason because of a repeat event at <code>t=54.2768</code>. Not that every time an event occurs, there are by default two saves (as denoted by the <code>save_positions</code> keyword argument), and so the four repeat of this timepoint denotes a double event. We can see why this occurred by printing out the value:</p><pre><code class="language-julia">println(sol[24])
# [-1.50171e-12,31.3209]</code></pre><p>This value is not exactly zero due to floating point errors, and "the faster" the changes the larger this error (this is one reason for using higher precision numbers when necessary). Recall that by default, the <code>abstol</code> for an event is <code>1e-12</code>, and so this does not recognize <code>t=54.2768</code> as being a zero, and instead sees it as a negative timepoint. Thus since it's position just soon after, it will see there's a negative -&gt; positive event, flipping the sign once more, and then continuing to fall below the ground.</p><p>To fix this, we can increase the tolerance a bit. For this problem, we can safely say that anything below <code>1e-10</code> can be considered zero. Thus we modify the callback:</p><pre><code class="language-julia">cb = ContinuousCallback(condition,affect!,interp_points=1000,abstol=1e-10)
u0 = [50.0,0.0]
tspan = (0.0,100.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,Tsit5(),callback=cb)
plot(sol,plotdensity=10000)</code></pre><p>and it once again detects properly.</p><p>The short of it is: the defaults may need to be tweaked for your given problem, and usually the answer is increasing the number of interpolation points, or if you are noticing multi-events at a single timepoint, changing the tolerances. If these fail, constraining the timestep is another option. For most problems the defaults should be fine, but these steps will be necessary for "fast" problems or highly oscillatory problems.</p><h3><a class="nav-anchor" href="#Example-2:-Terminating-an-Integration-1" id="Example-2:-Terminating-an-Integration-1">Example 2: Terminating an Integration</a></h3><p>In many cases you might want to terminate an integration when some condition is satisfied. To terminate an integration, use <code>terminate!(integrator)</code> as the <code>affect!</code> in a callback.</p><p>In this example we will solve the differential equation:</p><pre><code class="language-julia">u0 = [1.,0.]
function fun2(t,u,du)
   du[2] = -u[1]
   du[1] = u[2]
end
tspan = (0.0,10.0)
prob = ODEProblem(fun2,u0,tspan)</code></pre><p>which has cosine and -sine as the solutions respectively. We wish to solve until the sine part, <code>u[2]</code> becomes positive. There are two things we may be looking for.</p><p>A <code>DiscreteCallback</code> will cause this to halt at the first step such that the condition is satisfied. For example, we could use:</p><pre><code class="language-julia">condition(t,u,integrator) = u[2]&gt;0
affect!(integrator) = terminate!(integrator)
cb = DiscreteCallback(condition,affect!)
sol = solve(prob,Tsit5(),callback=cb)</code></pre><p><img alt="discrete_terminate" src="../assets/discrete_terminate.png"/></p><p>However, in many cases we wish to halt exactly at the point of time that the condition is satisfied. To do that, we use a continuous callback. The condition must thus be a function which is zero at the point we want to halt. Thus we use the following:</p><pre><code class="language-julia">condition(t,u,integrator) = u[2]
affect!(integrator) = terminate!(integrator)
cb = ContinuousCallback(condition,affect!)
sol = solve(prob,Tsit5(),callback=cb)</code></pre><p><img alt="simple_terminate" src="../assets/simple_terminate.png"/></p><p>Note that this uses rootfinding to approximate the "exact" moment of the crossing. Analytically we know the value is <code>pi</code>, and here the integration terminates at</p><pre><code class="language-julia">sol.t[end] # 3.1415902502224307</code></pre><p>Using a more accurate integration increases the accuracy of this prediction:</p><pre><code class="language-julia">sol = solve(prob,Vern8(),callback=cb,reltol=1e-12,abstol=1e-12)
sol.t[end] # 3.1415926535896035
#Ï = 3.141592653589703...</code></pre><p>Now say we wish to find the when the first period is over, i.e. we want to ignore the upcrossing and only stop on the downcrossing. We do this by ignoring the <code>affect!</code> and only passing an <code>affect!</code> for the second:</p><pre><code class="language-julia">condition(t,u,integrator) = u[2]
affect!(integrator) = terminate!(integrator)
cb = ContinuousCallback(condition,nothing,affect!)
sol = solve(prob,Tsit5(),callback=cb)</code></pre><p><img alt="downcrossing_terminate" src="../assets/downcrossing_terminate.png"/></p><p>Notice that passing only one <code>affect!</code> is the same as <code>ContinuousCallback(condition,affect!,affect!)</code>, i.e. both upcrossings and downcrossings will activate the event. Using <code>ContinuousCallback(condition,affect!,nothing)</code>will thus be the same as above because the first event is an upcrossing.</p><h3><a class="nav-anchor" href="#Example-3:-Growing-Cell-Population-1" id="Example-3:-Growing-Cell-Population-1">Example 3: Growing Cell Population</a></h3><p>Another interesting issue is with models of changing sizes. The ability to handle such events is a unique feature of DifferentialEquations.jl! The problem we would like to tackle here is a cell population. We start with 1 cell with a protein <code>X</code> which increases linearly with time with rate parameter <code>Î±</code>. Since we are going to be changing the size of the population, we write the model in the general form:</p><pre><code class="language-julia">const Î± = 0.3
function f(t,u,du)
  for i in 1:length(u)
    du[i] = Î±*u[i]
  end
end</code></pre><p>Our model is that, whenever the protein <code>X</code> gets to a concentration of 1, it triggers a cell division. So we check to see if any concentrations hit 1:</p><pre><code class="language-julia">function condition(t,u,integrator) # Event when event_f(t,u) == 0
  1-maximum(u)
end</code></pre><p>Again, recall that this function finds events as when <code>condition==0</code>, so <code>1-maximum(u)</code> is positive until a cell has a concentration of <code>X</code> which is 1, which then triggers the event. At the event, we have that the cell splits into two cells, giving a random amount of protein to each one. We can do this by resizing the cache (adding 1 to the length of all of the caches) and setting the values of these two cells at the time of the event:</p><pre><code class="language-julia">function affect!(integrator)
  u = integrator.u
  resize!(integrator,length(u)+1)
  maxidx = findmax(u)[2]
  Î = rand()
  u[maxidx] = Î
  u[end] = 1-Î
  nothing
end</code></pre><p>As noted in the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a>, <code>resize!(integrator,length(integrator.u)+1)</code> is used to change the length of all of the internal caches (which includes <code>u</code>) to be their current length + 1, growing the ODE system. Then the following code sets the new protein concentrations. Now we can solve:</p><pre><code class="language-julia">callback = ContinuousCallback(condition,affect!)
u0 = [0.2]
tspan = (0.0,10.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob,callback=callback)</code></pre><p>The plot recipes do not have a way of handling the changing size, but we can plot from the solution object directly. For example, let's make a plot of how many cells there are at each time. Since these are discrete values, we calculate and plot them directly:</p><pre><code class="language-julia">plot(sol.t,map((x)-&gt;length(x),sol[:]),lw=3,
     ylabel="Number of Cells",xlabel="Time")</code></pre><p><img alt="NumberOfCells" src="../assets/numcells.png"/></p><p>Now let's check-in on a cell. We can still use the interpolation to get a nice plot of the concentration of cell 1 over time. This is done with the command:</p><pre><code class="language-julia">ts = linspace(0,10,100)
plot(ts,map((x)-&gt;x[1],sol.(ts)),lw=3,
     ylabel="Amount of X in Cell 1",xlabel="Time")</code></pre><p><img alt="Cell1" src="../assets/cell1.png"/></p><p>Notice that every time it hits 1 the cell divides, giving cell 1 a random amount of <code>X</code> which then grows until the next division.</p><p>Note that one macro which was not shown in this example is <code>deleteat!</code> on the caches. For example, to delete the second cell, we could use:</p><pre><code class="language-julia">deleteat!(integrator,2)</code></pre><p>This allows you to build sophisticated models of populations with births and deaths.</p><footer><hr/><a class="previous" href="linear_nonlinear.html"><span class="direction">Previous</span><span class="title">Specifying (Non)Linear Solvers</span></a><a class="next" href="callback_library.html"><span class="direction">Next</span><span class="title">Callback Library</span></a></footer></article></body></HTML>