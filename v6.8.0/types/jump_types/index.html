<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Jump Problems Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview');
</script><link href="https://docs.juliadiffeq.org/stable/types/jump_types/index.html" rel="canonical"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../../"><img alt="DifferentialEquations.jl logo" class="logo" src="../../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../../search/" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="toctext" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="toctext" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="toctext" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="toctext" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="toctext" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="toctext" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="toctext" href="../../basics/solution/">Solution Handling</a></li><li><a class="toctext" href="../../basics/plot/">Plot Functions</a></li><li><a class="toctext" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="toctext" href="../../basics/problem/">Problem Interface</a></li><li><a class="toctext" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="toctext" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../discrete_types/">Discrete Problems</a></li><li><a class="toctext" href="../ode_types/">ODE Problems</a></li><li><a class="toctext" href="../dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../split_ode_types/">Split ODE Problems</a></li><li><a class="toctext" href="../steady_state_types/">Steady State Problems</a></li><li><a class="toctext" href="../bvp_types/">BVP Problems</a></li><li><a class="toctext" href="../sde_types/">SDE Problems</a></li><li><a class="toctext" href="../rode_types/">RODE Problems</a></li><li><a class="toctext" href="../dde_types/">DDE Problems</a></li><li><a class="toctext" href="../dae_types/">DAE Problems</a></li><li class="current"><a class="toctext" href="">Jump Problems</a><ul class="internal"><li><a class="toctext" href="#Types-of-Jumps:-Regular,-Variable,-Constant-Rate-and-Mass-Action-1">Types of Jumps: Regular, Variable, Constant Rate and Mass Action</a></li><li><a class="toctext" href="#Defining-a-Jump-Problem-1">Defining a Jump Problem</a></li><li><a class="toctext" href="#Constant-Rate-Jump-Aggregators-1">Constant Rate Jump Aggregators</a></li><li><a class="toctext" href="#Constant-Rate-Jump-Aggregators-Requiring-Dependency-Graphs-1">Constant Rate Jump Aggregators Requiring Dependency Graphs</a></li><li><a class="toctext" href="#Recommendations-for-Constant-Rate-Jumps-1">Recommendations for Constant Rate Jumps</a></li></ul></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="toctext" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="toctext" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="toctext" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="toctext" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="toctext" href="../../solvers/jump_solve/">Jump Problem Solvers</a></li><li><a class="toctext" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="toctext" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="toctext" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="toctext" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="toctext" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="toctext" href="../../features/noise_process/">Noise Processes</a></li><li><a class="toctext" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../../features/callback_library/">Callback Library</a></li><li><a class="toctext" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="toctext" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="toctext" href="../../features/progress_bar/">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="toctext" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="toctext" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="toctext" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="toctext" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="toctext" href="../../models/physical/">Physical Models</a></li><li><a class="toctext" href="../../models/financial/">Financial Models</a></li><li><a class="toctext" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="toctext" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="toctext">APIs</span><ul><li><span class="toctext">DiffEqBase API</span><ul><li><a class="toctext" href="../../apis/diffeqbase/overview/">Overview</a></li><li><a class="toctext" href="../../apis/diffeqbase/functions/">DE functions</a></li><li><a class="toctext" href="../../apis/diffeqbase/problems/">Problems</a></li><li><a class="toctext" href="../../apis/diffeqbase/solutions/">Solutions</a></li><li><a class="toctext" href="../../apis/diffeqbase/solvers/">Solvers</a></li><li><a class="toctext" href="../../apis/diffeqbase/de_types/">DE types</a></li><li><a class="toctext" href="../../apis/diffeqbase/operators/">Operators</a></li><li><a class="toctext" href="../../apis/diffeqbase/callbacks/">Callbacks</a></li><li><a class="toctext" href="../../apis/diffeqbase/interpolation/">Interpolation</a></li><li><a class="toctext" href="../../apis/diffeqbase/ensembles/">Ensembles</a></li><li><a class="toctext" href="../../apis/diffeqbase/data_arrays/">Data arrays</a></li><li><a class="toctext" href="../../apis/diffeqbase/noise/">Noise processes</a></li><li><a class="toctext" href="../../apis/diffeqbase/utility/">Utility</a></li></ul></li><li><a class="toctext" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Problem Types</li><li><a href="">Jump Problems</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/types/jump_types.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Jump Problems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Jump-Problems-1" id="Jump-Problems-1">Jump Problems</a></h1><h3><a class="nav-anchor" href="#Mathematical-Specification-of-an-problem-with-jumps-1" id="Mathematical-Specification-of-an-problem-with-jumps-1">Mathematical Specification of an problem with jumps</a></h3><p>Jumps are defined as a Poisson process which changes states at some <code>rate</code>. When there are multiple possible jumps, the process is a compound Poisson process. On their own, a jump equation is continuous-time Markov Chain where the time to the next jump is exponentially distributed as calculated by the rate. This type of process, known in biology as "Gillespie discrete stochastic simulations" and modeled by the Chemical Master Equation (CME), is the same thing as adding jumps to a <code>DiscreteProblem</code>. However, any differential equation can be extended by jumps as well. For example, we have an ODE with jumps, denoted by</p><div>\[\frac{du}{dt} = f(u,p,t) + Î£ c_i(u,p,t)dp_i\]</div><p>where <span>$dp_i$</span> is a Poisson counter of rate <span>$\lambda_i(u,p,t)$</span>. Extending a stochastic differential equation to have jumps is commonly known as a Jump Diffusion, and is denoted by</p><div>\[\frac{du}{dt} = f(u,p,t) + Î£gáµ¢(u,t)dWâ± + Î£ c_i(u,p,t)dp_i\]</div><h2><a class="nav-anchor" href="#Types-of-Jumps:-Regular,-Variable,-Constant-Rate-and-Mass-Action-1" id="Types-of-Jumps:-Regular,-Variable,-Constant-Rate-and-Mass-Action-1">Types of Jumps: Regular, Variable, Constant Rate and Mass Action</a></h2><p>A <code>RegularJump</code> is a set of jumps that do not make structural changes to the underlying equation. These kinds of jumps only change values of the dependent variable (<code>u</code>) and thus can be treated in an inexact manner. Other jumps, such as those which change the size of <code>u</code>, require exact handling which is also known as time-adaptive jumping. These can only be specified as a <code>ConstantRateJump</code>, <code>MassActionJump</code>, or a <code>VariableRateJump</code>.</p><p>We denote a jump as variable rate if its rate function is dependent on values which may change between constant rate jumps. For example, if there are multiple jumps whose rates only change when one of them occur, than that set of jumps is a constant rate jump. If a jump's rate depends on the differential equation, time, or by some value which changes outside of any constant rate jump, then it is denoted as variable.</p><p>A <code>MassActionJump</code> is a specialized representation for a collection of constant rate jumps that can each be interpreted as a standard mass action reaction. For systems comprised of many mass action reactions, using the <code>MassActionJump</code> type will offer improved performance. Note, only one <code>MassActionJump</code> should be defined per <code>JumpProblem</code>; it is then responsible for handling all mass action reaction type jumps. For systems with both mass action jumps and non-mass action jumps, one can create one <code>MassActionJump</code> to handle the mass action jumps, and create a number of <code>ConstantRateJumps</code> to handle the non-mass action jumps.</p><p><code>RegularJump</code>s are optimized for regular jumping algorithms like tau-leaping and hybrid algorithms. <code>ConstantRateJump</code>s and <code>MassActionJump</code>s are optimized for SSA algorithms. <code>ConstantRateJump</code>s, <code>MassActionJump</code>s and <code>VariableRateJump</code>s can be added to standard DiffEq algorithms since they are simply callbacks, while <code>RegularJump</code>s require special algorithms. </p><h4><a class="nav-anchor" href="#Defining-a-Regular-Jump-1" id="Defining-a-Regular-Jump-1">Defining a Regular Jump</a></h4><p>The constructor for a <code>RegularJump</code> is:</p><pre><code class="language-julia">RegularJump(rate,c,c_prototype;mark_dist = nothing,constant_c = false)</code></pre><ul><li><code>rate(out,u,p,t)</code> is the function which computes the rate for every regular jump process</li><li><code>c(dc,u,p,t,mark)</code> is the current Stoichiometry matrix for each jump process</li><li><code>dc</code> is the cache array to be used for <code>dc</code></li><li><code>mark_dist</code> is the distribution for the mark</li><li><code>constant_c</code> denotes whether the Stoichiometry matrix <code>c</code> is constant</li></ul><p><code>dc</code> is an <code>n x m</code> matrix, where <code>n</code> is the number of Poisson processes and <code>m</code> is the number of dependent variables (should match <code>length(u)</code>). <code>rate</code> is a vector equation which should compute the rates in to <code>out</code> which is a length <code>n</code> vector.</p><h4><a class="nav-anchor" href="#Defining-a-Constant-Rate-Jump-1" id="Defining-a-Constant-Rate-Jump-1">Defining a Constant Rate Jump</a></h4><p>The constructor for a <code>ConstantRateJump</code> is:</p><pre><code class="language-julia">ConstantRateJump(rate,affect!)</code></pre><ul><li><code>rate(u,p,t)</code> is a function which calculates the rate given the time and the state.</li><li><code>affect!(integrator)</code> is the effect on the equation, using the integrator interface.</li></ul><h4><a class="nav-anchor" href="#Defining-a-Mass-Action-Jump-1" id="Defining-a-Mass-Action-Jump-1">Defining a Mass Action Jump</a></h4><p>The constructor for a <code>MassActionJump</code> is:</p><pre><code class="language-julia">MassActionJump(rate_consts, reactant_stoich, net_stoich; scale_rates = true)</code></pre><ul><li><code>rate_consts</code> is a vector of the rate constants for each reaction.</li><li><code>reactant_stoich</code> is a vector whose <code>k</code>th entry is the reactant stoichiometry of the <code>k</code>th reaction. The reactant stoichiometry for an individual reaction is assumed to be represented as a vector of <code>Pair</code>s, mapping species id to stoichiometric coefficient.</li><li><code>net_stoich</code> is assumed to have the same type as <code>reactant_stoich</code>; a vector whose <code>k</code>th entry is the net stoichiometry of the <code>k</code>th reaction. The net stoichiometry for an individual reaction is again represented as a vector of <code>Pair</code>s, mapping species id to the net change in the species when the reaction occurs.</li><li><code>scale_rates</code> is an optional parameter that specifies whether the rate constants correspond to stochastic rate constants in the sense used by Gillespie, and hence need to be rescaled. <em>The default, <code>scale_rates=true</code>, corresponds to rescaling the passed in rate constants.</em> See below.</li></ul><p><strong>Notes for Mass Action Jumps</strong></p><ul><li>When using <code>MassActionJump</code> the default behavior is to assume rate constants correspond to stochastic rate constants in the sense used by Gillespie (J. Comp. Phys., 1976, 22 (4)). This means that for a reaction such as <span>$2A \overset{k}{\rightarrow} B$</span>, the jump rate function constructed by <code>MassActionJump</code> would be <code>k*A*(A-1)/2!</code>. For a trimolecular reaction like <span>$3A \overset{k}{\rightarrow} B$</span> the rate function would be <code>k*A*(A-1)*(A-2)/3!</code>. To <em>avoid</em> having the reaction rates rescaled (by <code>1/2</code> and <code>1/6</code> for these two examples), one can pass the <code>MassActionJump</code> constructor the optional named parameter <code>scale_rates=false</code>, i.e. use<pre><code class="language-julia">MassActionJump(rates, reactant_stoich, net_stoich; scale_rates = false)</code></pre></li><li>Zero order reactions can be passed as <code>reactant_stoich</code>s in one of two ways. Consider the <span>$\varnothing \overset{k}{\rightarrow} A$</span> reaction with rate <code>k=1</code>:<pre><code class="language-julia">k = [1.]
reactant_stoich = [[0 =&gt; 1]]
net_stoich = [[1 =&gt; 1]]
jump = MassActionJump(k, reactant_stoich, net_stoich)</code></pre>Alternatively one can create an empty vector of pairs to represent the reaction:<pre><code class="language-julia">k = [1.]
reactant_stoich = [Vector{Pair{Int,Int}}()]
net_stoich = [[1 =&gt; 1]]
jump = MassActionJump(k, reactant_stoich, net_stoich)</code></pre></li><li>For performance reasons, it is recommended to order species indices in stoichiometry vectors from smallest to largest. That is <pre><code class="language-julia">reactant_stoich = [[1 =&gt; 2, 3 =&gt; 1, 4 =&gt; 2], [2 =&gt; 2, 3 =&gt; 2]]</code></pre>is preferred over<pre><code class="language-julia">reactant_stoich = [[3 =&gt; 1, 1 =&gt; 2, 4 = &gt; 2], [3 =&gt; 2, 2 =&gt; 2]]</code></pre></li></ul><h4><a class="nav-anchor" href="#Defining-a-Variable-Rate-Jump-1" id="Defining-a-Variable-Rate-Jump-1">Defining a Variable Rate Jump</a></h4><p>The constructor for a <code>VariableRateJump</code> is:</p><pre><code class="language-julia">VariableRateJump(rate,affect!;
                   idxs = nothing,
                   rootfind=true,
                   save_positions=(true,true),
                   interp_points=10,
                   abstol=1e-12,reltol=0)</code></pre><p>Note that this is the same as defining a <code>ContinuousCallback</code>, except that instead of the <code>condition</code> function, you provide a <code>rate(u,p,t)</code> function for the <code>rate</code> at a given time and state.</p><h2><a class="nav-anchor" href="#Defining-a-Jump-Problem-1" id="Defining-a-Jump-Problem-1">Defining a Jump Problem</a></h2><p>To define a <code>JumpProblem</code>, you must first define the basic problem. This can be a <code>DiscreteProblem</code> if there is no differential equation, or an ODE/SDE/DDE/DAE if you would like to augment a differential equation with jumps. Denote this previously defined problem as <code>prob</code>. Then the constructor for the jump problem is:</p><pre><code class="language-julia">JumpProblem(prob,aggregator::Direct,jumps::JumpSet;
            save_positions = typeof(prob) &lt;: AbstractDiscreteProblem ? (false,true) : (true,true))</code></pre><p>The aggregator is the method for aggregating the constant jumps. These are defined below. <code>jumps</code> is a <code>JumpSet</code> which is just a gathering of jumps. Instead of passing a <code>JumpSet</code>, one may just pass a list of jumps themselves. For example:</p><pre><code class="language-julia">JumpProblem(prob,aggregator,jump1,jump2)</code></pre><p>and the internals will automatically build the <code>JumpSet</code>. <code>save_positions</code> is the <code>save_positions</code> argument built by the aggregation of the constant rate jumps.</p><p>Note that a <code>JumpProblem</code>/<code>JumpSet</code> can only have 1 <code>RegularJump</code> (since a <code>RegularJump</code> itself describes multiple processes together). Similarly, it can only have one <code>MassActionJump</code> (since it also describes multiple processes together).</p><h2><a class="nav-anchor" href="#Constant-Rate-Jump-Aggregators-1" id="Constant-Rate-Jump-Aggregators-1">Constant Rate Jump Aggregators</a></h2><p>Constant rate jump aggregators are the methods by which constant rate jumps, including <code>MassActionJump</code>s, are lumped together. This is required in all algorithms for both speed and accuracy. The current methods are:</p><ul><li><code>Direct</code>: the Gillespie Direct method SSA.</li><li><em><code>DirectCR</code></em>: The Composition-Rejection Direct method of Slepoy et al. For large networks and linear chain-type networks it will often give better performance than <code>Direct</code>. (Requires dependency graph, see below.)</li><li><code>DirectFW</code>: the Gillespie Direct method SSA with <code>FunctionWrappers</code>. This aggregator uses a different internal storage format for collections of <code>ConstantRateJumps</code>. </li><li><code>FRM</code>: the Gillespie first reaction method SSA. <code>Direct</code> should generally offer better performance and be preferred to <code>FRM</code>.</li><li><code>FRMFW</code>: the Gillespie first reaction method SSA with <code>FunctionWrappers</code>.</li><li><em><code>NRM</code></em>: The Gibson-Bruck Next Reaction Method. For some reaction network structures  this may offer better performance than <code>Direct</code> (for example, large, linear chains of reactions). (Requires dependency graph, see below.) </li><li><em><code>RSSA</code></em>: The Rejection SSA (RSSA) method of Thanh et al. For very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)</li><li><em><code>SortingDirect</code></em>: The Sorting Direct Method of McCollum et al. It will usually offer performance as good as <code>Direct</code>, and for some systems can offer substantially better performance. (Requires dependency graph, see below.)</li></ul><p>To pass the aggregator, pass the instantiation of the type. For example:</p><pre><code class="language-julia">JumpProblem(prob,Direct(),jump1,jump2)</code></pre><p>will build a problem where the constant rate jumps are solved using Gillespie's Direct SSA method.</p><h2><a class="nav-anchor" href="#Constant-Rate-Jump-Aggregators-Requiring-Dependency-Graphs-1" id="Constant-Rate-Jump-Aggregators-Requiring-Dependency-Graphs-1">Constant Rate Jump Aggregators Requiring Dependency Graphs</a></h2><p>Italicized constant rate jump aggregators require the user to pass a dependency graph to <code>JumpProblem</code>. <code>DirectCR</code>, <code>NRM</code> and <code>SortingDirect</code> require a jump-jump dependency graph, passed through the named parameter <code>dep_graph</code>. i.e.</p><pre><code class="language-julia">JumpProblem(prob,DirectCR(),jump1,jump2; dep_graph=your_dependency_graph)</code></pre><p>For systems with only <code>MassActionJump</code>s, or those generated from a <code>DiffEqBiological</code><code>reaction_network</code>, this graph will be auto-generated. Otherwise you must construct the dependency graph manually. Dependency graphs are represented as a <code>Vector{Vector{Int}}</code>, with the <code>i</code>th vector containing the indices of the jumps for which rates must be recalculated when the <code>i</code>th jump occurs.</p><p><code>RSSA</code> requires two different types of dependency graphs, passed through the following <code>JumpProblem</code> kwargs:</p><ul><li><code>vartojumps_map</code> - A <code>Vector{Vector{Int}}</code> mapping each variable index, <code>i</code>, to a set of jump indices. The jump indices correspond to jumps with rate functions that depend on the value of <code>u[i]</code>.</li><li><code>jumptovars_map</code> - A <code>Vector{Vector{Int}}</code>  mapping each jump index to a set of variable indices. The corresponding variables are those that have their value, <code>u[i]</code>, altered when the jump occurs.</li></ul><p>For systems generated from a <code>DiffEqBiological</code><code>reaction_network</code> these will be auto-generated. Otherwise you must explicitly construct and pass in these mappings.</p><h2><a class="nav-anchor" href="#Recommendations-for-Constant-Rate-Jumps-1" id="Recommendations-for-Constant-Rate-Jumps-1">Recommendations for Constant Rate Jumps</a></h2><p>For representing and aggregating constant rate jumps </p><ul><li>Use a <code>MassActionJump</code> to handle all jumps that can be represented as mass action reactions. This will generally offer the fastest performance. </li><li>Use <code>ConstantRateJump</code>s for any remaining jumps.</li><li>For a small number of jumps, &lt; ~10, <code>Direct</code> will often perform as well as the other aggregators.</li><li>For &gt; ~10 jumps <code>SortingDirect</code> will often offer better performance than <code>Direct</code>.</li><li>For large number of jumps with sparse chain like structures and similar jump rates, for example continuous time random walks, <code>DirectCR</code> and then <code>NRM</code> often have the best performance.</li><li>For very large networks, with many updates per jump, <code>RSSA</code> will often substantially outperform the other methods.</li></ul><p>In general, for systems with sparse dependency graphs if <code>Direct</code> is slow, one of <code>SortingDirect</code>, <code>DirectCR</code> or <code>RSSA</code> will usually offer substantially better performance. See <a href="https://github.com/JuliaDiffEq/DiffEqBenchmarks.jl">DiffEqBenchmarks.jl</a> for benchmarks on several example networks.</p><footer><hr/><a class="previous" href="../dae_types/"><span class="direction">Previous</span><span class="title">DAE Problems</span></a><a class="next" href="../../solvers/discrete_solve/"><span class="direction">Next</span><span class="title">Discrete Solvers</span></a></footer></article></body></HTML>