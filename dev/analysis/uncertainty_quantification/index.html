<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Uncertainty Quantification Â· DifferentialEquations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://diffeq.sciml.ai/stable/analysis/uncertainty_quantification/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../global_sensitivity/">Global Sensitivity Analysis</a></li><li class="is-active"><a class="tocitem" href>Uncertainty Quantification</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#ProbInts"><span>ProbInts</span></a></li><li><a class="tocitem" href="#Example-1:-FitzHugh-Nagumo"><span>Example 1: FitzHugh-Nagumo</span></a></li><li><a class="tocitem" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo"><span>Example 2: Adaptive ProbInts on FitzHugh-Nagumo</span></a></li><li><a class="tocitem" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor"><span>Example 3: Adaptive ProbInts on the Lorenz Attractor</span></a></li></ul></li><li><a class="tocitem" href="../neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Analysis Tools</a></li><li class="is-active"><a href>Uncertainty Quantification</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Uncertainty Quantification</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/analysis/uncertainty_quantification.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="uncertainty_quantification"><a class="docs-heading-anchor" href="#uncertainty_quantification">Uncertainty Quantification</a><a id="uncertainty_quantification-1"></a><a class="docs-heading-anchor-permalink" href="#uncertainty_quantification" title="Permalink"></a></h1><p>Uncertainty quantification allows a user to identify the uncertainty associated with the numerical approximation given by DifferentialEquations.jl. This page describes the different methods available for quantifying such uncertainties. Note that this requires one of the native Julia solvers like OrdinaryDiffEq.jl, StochasticDiffEq.jl, or DelayDiffEq.jl.</p><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>This functionality does not come standard with DifferentialEquations.jl. To use this functionality, you must install DiffEqUncertainty.jl:</p><pre><code class="language-julia hljs">]add DiffEqUncertainty
using DiffEqUncertainty</code></pre><h2 id="ProbInts"><a class="docs-heading-anchor" href="#ProbInts">ProbInts</a><a id="ProbInts-1"></a><a class="docs-heading-anchor-permalink" href="#ProbInts" title="Permalink"></a></h2><p>The <a href="https://arxiv.org/abs/1506.04592">ProbInts</a> method for uncertainty quantification involves the transformation of an ODE into an associated SDE where the noise is related to the timesteps and the order of the algorithm. This is implemented into the DiffEq system via a callback function. The first form is:</p><pre><code class="language-julia hljs">ProbIntsUncertainty(Ï,order,save=true)</code></pre><p><code>Ï</code> is the noise scaling factor and <code>order</code> is the order of the algorithm. <code>save</code> is for choosing whether this callback should control the saving behavior. Generally this is true unless one is stacking callbacks in a <code>CallbackSet</code>. It is recommended that <code>Ï</code> is representative of the size of the errors in a single step of the equation.</p><p>If you are using an adaptive algorithm, the callback</p><pre><code class="language-julia hljs">AdaptiveProbIntsUncertainty(order,save=true)</code></pre><p>determines the noise scaling automatically using an internal error estimate.</p><h2 id="Example-1:-FitzHugh-Nagumo"><a class="docs-heading-anchor" href="#Example-1:-FitzHugh-Nagumo">Example 1: FitzHugh-Nagumo</a><a id="Example-1:-FitzHugh-Nagumo-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-FitzHugh-Nagumo" title="Permalink"></a></h2><p>In this example we will determine our uncertainty when solving the FitzHugh-Nagumo model with the <code>Euler()</code> method. We define the FitzHugh-Nagumo model:</p><pre><code class="language-julia hljs">function fitz(du,u,p,t)
  V,R = u
  a,b,c = p
  du[1] = c*(V - V^3/3 + R)
  du[2] = -(1/c)*(V -  a - b*R)
end
u0 = [-1.0;1.0]
tspan = (0.0,20.0)
p = (0.2,0.2,3.0)
prob = ODEProblem(fitz,u0,tspan,p)</code></pre><p>Now we define the <code>ProbInts</code> callback. In this case, our method is the <code>Euler</code> method and thus it is order 1. For the noise scaling, we will try a few different values and see how it changes. For <code>Ï=0.2</code>, we define the callback as:</p><pre><code class="language-julia hljs">cb = ProbIntsUncertainty(0.2,1)</code></pre><p>This is akin to having an error of approximately 0.2 at each step. We now build and solve a <a href="../../features/ensemble/#ensemble">EnsembleProblem</a> for 100 trajectories:</p><pre><code class="language-julia hljs">ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Euler(),trajectories=100,callback=cb,dt=1/10)</code></pre><p>Now we can plot the resulting Monte Carlo solution:</p><pre><code class="language-julia hljs">using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_02.png" alt="uncertainty_02"/></p><p>If we increase the amount of error, we see that some parts of the equation have less uncertainty than others. For example, at <code>Ï=0.5</code>:</p><pre><code class="language-julia hljs">cb = ProbIntsUncertainty(0.5,1)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Euler(),trajectories=100,callback=cb,dt=1/10)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_05.png" alt="uncertainty_05"/></p><p>But at this amount of noise, we can see how we contract to the true solution by decreasing <code>dt</code>:</p><pre><code class="language-julia hljs">cb = ProbIntsUncertainty(0.5,1)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Euler(),trajectories=100,callback=cb,dt=1/100)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_lowh.png" alt="uncertainty_lowh"/></p><h2 id="Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo"><a class="docs-heading-anchor" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo">Example 2: Adaptive ProbInts on FitzHugh-Nagumo</a><a id="Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo-1"></a><a class="docs-heading-anchor-permalink" href="#Example-2:-Adaptive-ProbInts-on-FitzHugh-Nagumo" title="Permalink"></a></h2><p>While the first example is academic and shows how the ProbInts method scales, the fact that one should have some idea of the error in order to calibrate <code>Ï</code> can lead to complications. Thus the more useful method in many cases is the <code>AdaptiveProbIntsUncertainty</code> version. In this version, no <code>Ï</code> is required since this is calculated using an internal error estimate. Thus this gives an accurate representation of the possible error without user input.</p><p>Let&#39;s try this with the order 5 <code>Tsit5()</code> method on the same problem as before:</p><pre><code class="language-julia hljs">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob,Tsit5())
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Tsit5(),trajectories=100,callback=cb)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_adaptive_default.png" alt="uncertainty_adaptive_default"/></p><p>In this case, we see that the default tolerances give us a very good solution. However, if we increase the tolerance a lot:</p><pre><code class="language-julia hljs">cb = AdaptiveProbIntsUncertainty(5)
sol = solve(prob,Tsit5())
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Tsit5(),trajectories=100,callback=cb,abstol=1e-3,reltol=1e-1)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_high_tolerance.png" alt="uncertainty_adaptive_default"/></p><p>we can see that the moments just after the rise can be uncertain.</p><h2 id="Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor"><a class="docs-heading-anchor" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor">Example 3: Adaptive ProbInts on the Lorenz Attractor</a><a id="Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor-1"></a><a class="docs-heading-anchor-permalink" href="#Example-3:-Adaptive-ProbInts-on-the-Lorenz-Attractor" title="Permalink"></a></h2><p>One very good use of uncertainty quantification is on chaotic models. Chaotic equations diverge from the true solution according to the error exponentially. This means that as time goes on, you get further and further from the solution. The <code>ProbInts</code> method can help diagnose how much of the timeseries is reliable.</p><p>As in the previous example, we first define the model:</p><pre><code class="language-julia hljs">function g(du,u,p,t)
 du[1] = p[1]*(u[2]-u[1])
 du[2] = u[1]*(p[2]-u[3]) - u[2]
 du[3] = u[1]*u[2] - p[3]*u[3]
end
u0 = [1.0;0.0;0.0]
tspan = (0.0,30.0)
p = [10.0,28.0,8/3]
prob = ODEProblem(g,u0,tspan,p)</code></pre><p>and then we build the <code>ProbInts</code> type. Let&#39;s use the order 5 <code>Tsit5</code> again.</p><pre><code class="language-julia hljs">cb = AdaptiveProbIntsUncertainty(5)</code></pre><p>Then we solve the <code>MonteCarloProblem</code></p><pre><code class="language-julia hljs">ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Tsit5(),trajectories=100,callback=cb)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_chaos.png" alt="uncertainty_chaos"/></p><p>Here we see that by <code>t</code> about 22 we start to receive strong deviations from the &quot;true&quot; solution. We can increase the amount of time before error explosion by using a higher order method with stricter tolerances:</p><pre><code class="language-julia hljs">tspan = (0.0,40.0)
prob = ODEProblem(g,u0,tspan,p)
cb = AdaptiveProbIntsUncertainty(7)
ensemble_prob = EnsembleProblem(prob)
sim = solve(ensemble_prob,Vern7(),trajectories=100,callback=cb,reltol=1e-6)
using Plots; plotly(); plot(sim,vars=(0,1),linealpha=0.4)</code></pre><p><img src="../../assets/uncertainty_high_order.png" alt="uncertainty_high_order"/></p><p>we see that we can extend the amount of time until we deviate strongly from the &quot;true&quot; solution. Of course, for a chaotic system like the Lorenz one presented here, it is impossible to follow the true solution for long times, due to the fact that the system is chaotic and unavoidable deviations due to the numerical precision of a computer get amplified exponentially.</p><p>However, not all hope is lost. The <a href="http://mathworld.wolfram.com/ShadowingTheorem.html">shadowing theorem</a> is a strong statement for having confidence in numerical evolution of chaotic systems:</p><blockquote><p>Although a numerically computed chaotic trajectory diverges exponentially from the true trajectory with the same initial coordinates, there exists an errorless trajectory with a slightly different initial condition that stays near (&quot;shadows&quot;) the numerically computed one.</p></blockquote><p>For more info on the shadowing theorem, please see the book <em>Chaos in Dynamical Systems</em> by E. Ott.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../global_sensitivity/">Â« Global Sensitivity Analysis</a><a class="docs-footer-nextpage" href="../neural_networks/">Neural Networks Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.5 on <span class="colophon-date" title="Friday 13 August 2021 16:23">Friday 13 August 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
