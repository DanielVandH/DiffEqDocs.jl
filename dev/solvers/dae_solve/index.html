<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DAE Solvers · DifferentialEquations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/DiffEqDocs/stable/solvers/dae_solve/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Large Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../sdde_solve/">SDDE Solvers</a></li><li class="is-active"><a class="tocitem" href>DAE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#dae_solve_full"><span>Full List of Methods</span></a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Reduced Compile Time, Optimizing Runtime, and Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Algorithms</a></li><li class="is-active"><a href>DAE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DAE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/solvers/dae_solve.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DAE-Solvers"><a class="docs-heading-anchor" href="#DAE-Solvers">DAE Solvers</a><a id="DAE-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#DAE-Solvers" title="Permalink"></a></h1><h2 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h2><p>For medium to low accuracy small numbers of DAEs in constant mass matrices form, the  <code>Rosenbrock23</code> and <code>Rodas4</code> methods are good choices which will get good efficiency if the mass matrix is constant. <code>Rosenbrock23</code> is better for low accuracy (error tolerance <code>&lt;1e-4</code>) and <code>Rodas4</code> is better for high accuracy. Another choice at high accuracy is <code>RadauIIA5</code>.</p><p>Non-constant mass matrices are not directly supported: users are advised to transform their problem through substitution to a DAE with constant mass matrices.</p><p>If the problem cannot be defined in mass matrix form, the recommended method for performance is <code>IDA</code> from the Sundials.jl package if you are solving problems with <code>Float64</code>. If Julia types are required, currently <code>DFBDF</code> is the best method but still needs more optimizations.</p><h2 id="dae_solve_full"><a class="docs-heading-anchor" href="#dae_solve_full">Full List of Methods</a><a id="dae_solve_full-1"></a><a class="docs-heading-anchor-permalink" href="#dae_solve_full" title="Permalink"></a></h2><h4 id="Initialization-Schemes"><a class="docs-heading-anchor" href="#Initialization-Schemes">Initialization Schemes</a><a id="Initialization-Schemes-1"></a><a class="docs-heading-anchor-permalink" href="#Initialization-Schemes" title="Permalink"></a></h4><p>For all OrdinaryDiffEq.jl methods, an initialization scheme can be set with a common keyword argument <code>initializealg</code>. The choices are:</p><ul><li><code>BrownFullBasicInit</code>: For Index-1 DAEs implicit DAEs and and semi-explicit DAEs in mass matrix form. Keeps the differential variables constant. Requires <code>du0</code> when used on a <code>DAEProblem</code>.</li><li><code>ShampineCollocationInit</code>: For Index-1 DAEs implicit DAEs and and semi-explicit DAEs in mass matrix form. Changes both the differential and algebraic variables.</li><li><code>NoInit</code>: Explicitly opts-out of DAE initialization.</li></ul><h3 id="OrdinaryDiffEq.jl-(Implicit-ODE)"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-(Implicit-ODE)">OrdinaryDiffEq.jl (Implicit ODE)</a><a id="OrdinaryDiffEq.jl-(Implicit-ODE)-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-(Implicit-ODE)" title="Permalink"></a></h3><p>These methods from OrdinaryDiffEq are for <code>DAEProblem</code> specifications.</p><ul><li><code>DImplicitEuler</code> - 1st order A-L and stiffly stable adaptive implicit Euler</li><li><code>DABDF2</code> - 2nd order A-L stable adaptive BDF method.</li><li><code>DFBDF</code> - A fixed-leading coefficient adaptive-order adaptive-time BDF method, similar to <code>ode15i</code> or <code>IDA</code> in divided differences form.</li></ul><h3 id="OrdinaryDiffEq.jl-(Mass-Matrix)"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-(Mass-Matrix)">OrdinaryDiffEq.jl (Mass Matrix)</a><a id="OrdinaryDiffEq.jl-(Mass-Matrix)-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-(Mass-Matrix)" title="Permalink"></a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The standard Hermite interpolation used for ODE methods in OrdinaryDiffEq.jl is not applicable to the algebraic variables. Thus for the following mass-matrix methods, use the interplation (thus <code>saveat</code>) with caution if the default Hermite interpolation is used. All methods which mention a specialized interpolation (and implicit ODE methods) are safe.</p></div></div><h4 id="Rosenbrock-Methods"><a class="docs-heading-anchor" href="#Rosenbrock-Methods">Rosenbrock Methods</a><a id="Rosenbrock-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-Methods" title="Permalink"></a></h4><ul><li><code>ROS3P</code> - 3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</li><li><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</li><li><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</li><li><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</li><li><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</li><li><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</li><li><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially &quot;anti-L-stable&quot; but efficient.</li><li><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</li><li><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</li><li><code>Rodas4P2</code> - A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Roadas4P and in case of inexact Jacobians a second order W method.</li><li><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method. with a stiff-aware 3rd order interpolant</li></ul><h4 id="Rosenbrock-W-Methods"><a class="docs-heading-anchor" href="#Rosenbrock-W-Methods">Rosenbrock-W Methods</a><a id="Rosenbrock-W-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-W-Methods" title="Permalink"></a></h4><ul><li><code>Rosenbrock23</code> - An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</li><li><code>Rosenbrock32</code> - An Order 3/2 A-Stable Rosenbrock-W method which is good for mildy stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</li><li><code>RosenbrockW6S4OS</code> - A 4th order L-stable Rosenbrock-W method (fixed step only).</li><li><code>ROS34PW1a</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW1b</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW2</code> - A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</li><li><code>ROS34PW3</code> - A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</li></ul><h4 id="FIRK-Methods"><a class="docs-heading-anchor" href="#FIRK-Methods">FIRK Methods</a><a id="FIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#FIRK-Methods" title="Permalink"></a></h4><ul><li><code>RadauIIA5</code> - An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.</li></ul><h4 id="SDIRK-Methods"><a class="docs-heading-anchor" href="#SDIRK-Methods">SDIRK Methods</a><a id="SDIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#SDIRK-Methods" title="Permalink"></a></h4><ul><li><code>ImplicitEuler</code> - Stage order 1. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory. Strong-stability preserving (SSP).</li><li><code>ImplicitMidpoint</code> - Stage order 1. Symplectic. Good for when symplectic integration is required.</li><li><code>Trapezoid</code> - A second order A-stable symmetric ESDIRK method. &quot;Almost symplectic&quot; without numerical dampening. Also known as Crank-Nicolson when applied to PDEs. Adaptive timestepping via divided differences on the memory. Good for highly stiff equations which are non-oscillatory.</li></ul><h4 id="Multistep-Methods"><a class="docs-heading-anchor" href="#Multistep-Methods">Multistep Methods</a><a id="Multistep-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Multistep-Methods" title="Permalink"></a></h4><p>Quasi-constant stepping is the time stepping strategy which matches the classic GEAR, LSODE,  and <code>ode15s</code> integrators. The variable-coefficient methods match the ideas of the classic EPISODE integrator and early VODE designs. The Fixed Leading Coefficient (FLC) methods match the behavior of the classic VODE and Sundials CVODE integrator.</p><ul><li><code>QNDF1</code> - An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter <code>kappa</code> defaults to Shampine&#39;s accuracy-optimal <code>-0.1850</code>.</li><li><code>QBDF1</code> - An adaptive order 1 L-stable BDF method. This is equivalent to implicit Euler but using the BDF error estimator.</li><li><code>ABDF2</code> - An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.</li><li><code>QNDF2</code> - An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.</li><li><code>QBDF2</code> - An adaptive order 2 L-stable BDF method using quasi-constant timesteps.</li><li><code>QNDF</code> - An adaptive order quasi-constant timestep NDF method. Utilizes Shampine&#39;s accuracy-optimal <code>kappa</code> values as defaults (has a keyword argument for a tuple of <code>kappa</code> coefficients).</li><li><code>QBDF</code> - An adaptive order quasi-constant timestep BDF method.</li><li><code>FBDF</code> - A fixed-leading coefficient adaptive-order adaptive-time BDF method, similar to <code>ode15i</code> or <code>CVODE_BDF</code> in divided differences form.</li></ul><h3 id="dae_solve_sundials"><a class="docs-heading-anchor" href="#dae_solve_sundials">Sundials.jl</a><a id="dae_solve_sundials-1"></a><a class="docs-heading-anchor-permalink" href="#dae_solve_sundials" title="Permalink"></a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use Sundials.jl:</p><pre><code class="language-julia hljs">]add Sundials
using Sundials</code></pre><ul><li><code>IDA</code> - This is the IDA method from the Sundials.jl package.</li></ul><p>Note that the constructors for the Sundials algorithms take a main argument:</p><ul><li><p><code>linearsolver</code> - This is the linear solver which is used in the Newton iterations. The choices are:</p><ul><li><code>:Dense</code> - A dense linear solver.</li><li><code>:Band</code> - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via <code>jac_upper</code> and <code>jac_lower</code>.</li><li><code>:LapackDense</code> - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than <code>:Dense</code> on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li><code>:LapackBand</code> - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than <code>:Band</code> on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li><code>:GMRES</code> - A GMRES method. Recommended first choice Krylov method</li><li><code>:BCG</code> - A Biconjugate gradient method.</li><li><code>:PCG</code> - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li><code>:TFQMR</code> - A TFQMR method.</li><li><code>:KLU</code> - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the <code>ODEProblem</code> type.</li></ul></li></ul><p>Example:</p><pre><code class="language-julia hljs">IDA() # Newton + Dense solver
IDA(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
IDA(linear_solver=:BCG) # Biconjugate gradient method                                   </code></pre><p>All of the additional options are available. The constructor is:</p><pre><code class="language-julia hljs">IDA(;linear_solver=:Dense,jac_upper=0,jac_lower=0,krylov_dim=0,
    max_order = 5,
    max_error_test_failures = 7,
    max_nonlinear_iters = 3,
    nonlinear_convergence_coefficient = 0.33,
    nonlinear_convergence_coefficient_ic = 0.0033,
    max_num_steps_ic = 5,
    max_num_jacs_ic = 4,
    max_num_iters_ic = 10,
    max_num_backs_ic = 100,
    use_linesearch_ic = true,
    max_convergence_failures = 10,
    init_all = false,
    prec = nothing, psetup = nothing)</code></pre><p>See <a href="https://computing.llnl.gov/sites/default/files/ida_guide-5.7.0.pdf">the Sundials manual</a> for details on the additional options. The option <code>init_all</code> controls the initial condition consistency routine. If the initial conditions are inconsistent (i.e. they do not satisfy the implicit equation), <code>init_all=false</code> means that the algebraic variables and derivatives will be modified in order to satisfy the DAE. If <code>init_all=true</code>, all initial conditions will be modified to satisfy the DAE.</p><p>Note that here <code>prec</code> is a (left) preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>resid</code>: the current residual</li><li><code>u</code>: the current state</li><li><code>du</code>: the current derivative of the state</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><h3 id="DASKR.jl"><a class="docs-heading-anchor" href="#DASKR.jl">DASKR.jl</a><a id="DASKR.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DASKR.jl" title="Permalink"></a></h3><p>DASKR.jl is not automatically included by DifferentialEquations.jl. To use this algorithm, you will need to install and use the package:</p><pre><code class="language-julia hljs">]add DASKR
using DASKR</code></pre><ul><li><code>daskr</code> - This is a wrapper for the well-known DASKR algorithm.</li></ul><p>All additional options are available. The constructor is:</p><pre><code class="language-julia hljs">function daskr(;linear_solver=:Dense,
                  jac_upper=0,jac_lower=0,max_order = 5,
                  non_negativity_enforcement = 0,
                  non_negativity_enforcement_array = nothing,
                  max_krylov_iters = nothing,
                  num_krylov_vectors = nothing,
                  max_number_krylov_restarts = 5,
                  krylov_convergence_test_constant = 0.05,
                  exclude_algebraic_errors = false)</code></pre><p>Choices for the linear solver are:</p><ul><li><code>:Dense</code></li><li><code>:Banded</code></li><li><code>:SPIGMR</code>, a Krylov method</li></ul><h3 id="DASSL.jl"><a class="docs-heading-anchor" href="#DASSL.jl">DASSL.jl</a><a id="DASSL.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DASSL.jl" title="Permalink"></a></h3><ul><li><code>dassl</code> - A native Julia implementation of the DASSL algorithm.</li></ul><h3 id="ODEInterfaceDiffEq.jl"><a class="docs-heading-anchor" href="#ODEInterfaceDiffEq.jl">ODEInterfaceDiffEq.jl</a><a id="ODEInterfaceDiffEq.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ODEInterfaceDiffEq.jl" title="Permalink"></a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><ul><li><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</li><li><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</li><li><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</li><li><code>rodas</code> - Rosenbrock 4(3) method.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../sdde_solve/">« SDDE Solvers</a><a class="docs-footer-nextpage" href="../benchmarks/">Solver Benchmarks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Thursday 24 November 2022 14:25">Thursday 24 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
