<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Stochastic Differential Equations Â· DifferentialEquations.jl</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://diffeq.sciml.ai/stable/tutorials/sde_example/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DifferentialEquations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../faster_ode_example/">Code Optimization for Differential Equations</a></li><li><a class="tocitem" href="../advanced_ode_example/">Solving Large Stiff Equations</a></li><li class="is-active"><a class="tocitem" href>Stochastic Differential Equations</a><ul class="internal"><li><a class="tocitem" href="#Example-1:-Scalar-SDEs"><span>Example 1: Scalar SDEs</span></a></li><li class="toplevel"><a class="tocitem" href="#Define-a-sparse-matrix-by-making-a-dense-matrix-and-setting-some-values-as-not-zero"><span>Define a sparse matrix by making a dense matrix and setting some values as not zero</span></a></li><li class="toplevel"><a class="tocitem" href="#Make-g-write-the-sparse-matrix-values"><span>Make <code>g</code> write the sparse matrix values</span></a></li><li class="toplevel"><a class="tocitem" href="#Make-g-use-the-sparse-matrix"><span>Make <code>g</code> use the sparse matrix</span></a></li></ul></li><li><a class="tocitem" href="../rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../discrete_stochastic_example/">Continuous-Time Jump Processes and Gillespie Methods</a></li><li><a class="tocitem" href="../jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options (Solve Keyword Arguments)</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">Jacobians, Gradients, etc.</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers and Preconditioners</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Stochastic Differential Equations</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Stochastic Differential Equations</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/tutorials/sde_example.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Stochastic-Differential-Equations"><a class="docs-heading-anchor" href="#Stochastic-Differential-Equations">Stochastic Differential Equations</a><a id="Stochastic-Differential-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Differential-Equations" title="Permalink"></a></h1><p>This tutorial will introduce you to the functionality for solving SDEs. Other introductions can be found by <a href="https://github.com/JuliaDiffEq/SciMLTutorials.jl">checking out SciMLTutorials.jl</a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial assumes you have read the <a href="../ode_example/#ode_example">Ordinary Differential Equations tutorial</a>.</p></div></div><h2 id="Example-1:-Scalar-SDEs"><a class="docs-heading-anchor" href="#Example-1:-Scalar-SDEs">Example 1: Scalar SDEs</a><a id="Example-1:-Scalar-SDEs-1"></a><a class="docs-heading-anchor-permalink" href="#Example-1:-Scalar-SDEs" title="Permalink"></a></h2><p>In this example we will solve the equation</p><p class="math-container">\[du = f(u,p,t)dt + g(u,p,t)dW\]</p><p>where <span>$f(u,p,t)=Î±u$</span> and <span>$g(u,p,t)=Î²u$</span>. We know via Stochastic Calculus that the solution to this equation is</p><p class="math-container">\[u(t,Wâ)=uâ\exp((Î±-\frac{Î²^2}{2})t+Î²Wâ)\]</p><p>To solve this numerically, we define a problem type by giving it the equation and the initial condition:</p><pre><code class="language-julia hljs">using DifferentialEquations
Î±=1
Î²=1
uâ=1/2
f(u,p,t) = Î±*u
g(u,p,t) = Î²*u
dt = 1//2^(4)
tspan = (0.0,1.0)
prob = SDEProblem(f,g,uâ,(0.0,1.0))</code></pre><p>The <code>solve</code> interface is then the same as with ODEs. Here we will use the classic Euler-Maruyama algorithm <code>EM</code> and plot the solution:</p><pre><code class="language-julia hljs">sol = solve(prob,EM(),dt=dt)
using Plots; plotly() # Using the Plotly backend
plot(sol)</code></pre><p><img src="../../assets/basic_sde.png" alt="Basic Solution"/></p><h3 id="Using-Higher-Order-Methods"><a class="docs-heading-anchor" href="#Using-Higher-Order-Methods">Using Higher Order Methods</a><a id="Using-Higher-Order-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Higher-Order-Methods" title="Permalink"></a></h3><p>One unique feature of DifferentialEquations.jl is that higher-order methods for stochastic differential equations are included. For reference, let&#39;s also give the <code>SDEProblem</code> the analytical solution. We can do this by making a test problem. This can be a good way to judge how accurate the algorithms are, or is used to test convergence of the algorithms for methods developers. Thus we define the problem object with:</p><pre><code class="language-julia hljs">f_analytic(uâ,p,t,W) = uâ*exp((Î±-(Î²^2)/2)*t+Î²*W)
ff = SDEFunction(f,g,analytic=f_analytic)
prob = SDEProblem(ff,g,uâ,(0.0,1.0))</code></pre><p>and then we pass this information to the solver and plot:</p><pre><code class="language-julia hljs">#We can plot using the classic Euler-Maruyama algorithm as follows:
sol = solve(prob,EM(),dt=dt)
plot(sol,plot_analytic=true)</code></pre><p><img src="../../assets/introSDEplot.png" alt="SDE Solution"/></p><p>We can choose a higher-order solver for a more accurate result:</p><pre><code class="language-julia hljs">sol = solve(prob,SRIW1(),dt=dt,adaptive=false)
plot(sol,plot_analytic=true)</code></pre><p><img src="../../assets/introSDEplotSRI.png" alt="Better SDE Solution"/></p><p>By default, the higher order methods have adaptivity. Thus one can use</p><pre><code class="language-julia hljs">sol = solve(prob,SRIW1())
plot(sol,plot_analytic=true)</code></pre><p><img src="../../assets/sde_auto_time.png" alt="Better Automatic Solution"/></p><p>Here we allowed the solver to automatically determine a starting <code>dt</code>. This estimate at the beginning is conservative (small) to ensure accuracy. We can instead start the method with a larger <code>dt</code> by passing in a value for the starting <code>dt</code>:</p><pre><code class="language-julia hljs">sol = solve(prob,SRIW1(),dt=dt)
plot(sol,plot_analytic=true)</code></pre><p><img src="../../assets/sde_start_time.png" alt="Better Automatic Solution"/></p><h3 id="Ensemble-Simulations"><a class="docs-heading-anchor" href="#Ensemble-Simulations">Ensemble Simulations</a><a id="Ensemble-Simulations-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-Simulations" title="Permalink"></a></h3><p>Instead of solving single trajectories, we can turn our problem into a <code>EnsembleProblem</code> to solve many trajectories all at once. This is done by the <code>EnsembleProblem</code> constructor:</p><pre><code class="language-julia hljs">ensembleprob = EnsembleProblem(prob)</code></pre><p>The solver commands are defined <a href="../../features/ensemble/#ensemble">at the Parallel Ensemble Simulations page</a>. For example we can choose to have 1000 trajectories via <code>trajectories=1000</code>. In addition, this will automatically parallelize using Julia native parallelism if extra processes are added via <code>addprocs()</code>, but we can change this to use multithreading via <code>EnsembleThreads()</code>. Together, this looks like:</p><pre><code class="language-julia hljs">sol = solve(ensembleprob,EnsembleThreads(),trajectories=1000)
Many more controls are defined at the [Ensemble simulations page](@ref ensemble), 
including analysis tools.
A very simple analysis can be done with the `EnsembleSummary`, which builds
mean/var statistics and has an associated plot recipe. For example, we can get
the statistics at every `0.01` timesteps and plot the average + error using:
</code></pre><p>julia using DifferentialEquations.EnsembleAnalysis summ = EnsembleSummary(sol,0:0.01:1) plot(summ,labels=&quot;Middle 95%&quot;) summ = EnsembleSummary(sol,0:0.01:1;quantiles=[0.25,0.75]) plot!(summ,labels=&quot;Middle 50%&quot;,legend=true)</p><pre><code class="nohighlight hljs">
![sde_tutorial_monte](../assets/sde_tutorial_monte.png)

Additionally we can easily calculate the correlation between the values at `t=0.2`
and `t=0.7` via
</code></pre><p>julia timepoint_meancor(sim,0.2,0.7) # Gives both means and then the correlation coefficient</p><pre><code class="nohighlight hljs">
## Example 2: Systems of SDEs with Diagonal Noise

More generally, an SDE
</code></pre><p>math du = f(u,p,t)dt + g(u,p,t)dW</p><pre><code class="nohighlight hljs">
generalizes to systems of equations is done in the same way as ODEs. Here, `g`
is now a matrix of values. One common case, and the default for DifferentialEquations.jl,
is diagonal noise where `g` is a diagonal matrix. This means that every function in
the system gets a different random number. Instead of handling matrices in this case,
we simply define both `f` and `g` as in-place functions. Thus `f(du,u,p,t)` gives a
vector of `du` which is the deterministic change, and `g(du2,u,p,t)` gives a vector
`du2` for which `du2.*W` is the stochastic portion of the equation.

For example, the Lorenz equation with additive noise has the same deterministic
portion as the Lorenz equations, but adds an additive noise, which is simply
`3*N(0,dt)` where `N` is the normal distribution `dt` is the time step, to each
step of the equation. This is done via:
</code></pre><p>julia function lorenz(du,u,p,t)   du[1] = 10.0(u[2]-u[1])   du[2] = u[1]<em>(28.0-u[3]) - u[2]   du[3] = u[1]</em>u[2] - (8/3)*u[3] end</p><p>function Ï_lorenz(du,u,p,t)   du[1] = 3.0   du[2] = 3.0   du[3] = 3.0 end</p><p>prob<em>sde</em>lorenz = SDEProblem(lorenz,Ï<em>lorenz,[1.0,0.0,0.0],(0.0,10.0)) sol = solve(prob</em>sde_lorenz) plot(sol,vars=(1,2,3))</p><pre><code class="nohighlight hljs">
![stochastic_3d_lorenz](../assets/stochastic_3d_lorenz.png)

Note that it&#39;s okay for the noise function to mix terms. For example
</code></pre><p>julia function Ï_lorenz(du,u,p,t)   du[1] = sin(u[3])<em>3.0   du[2] = u[2]</em>u[1]*3.0   du[3] = 3.0 end</p><pre><code class="nohighlight hljs">
is a valid noise function, which will once again give diagonal noise by `du2.*W`.

## Example 3: Systems of SDEs with Scalar Noise

In this example we&#39;ll solve a system of SDEs with scalar noise. This means that
the same noise process is applied to all SDEs. First we need to define a
scalar noise process
[using the Noise Process interface](@ref noise_process).
Since we want a `WienerProcess` that starts at `0.0` at time `0.0`, we use the
command `W = WienerProcess(0.0,0.0,0.0)` to define the Brownian motion we want,
and then give this to the `noise` option in the `SDEProblem`. For a full example,
let&#39;s solve a linear SDE with scalar noise using a high order algorithm:
</code></pre><p>julia f(du,u,p,t) = (du .= u) g(du,u,p,t) = (du .= u) u0 = rand(4,2)</p><p>W = WienerProcess(0.0,0.0,0.0) prob = SDEProblem(f,g,u0,(0.0,1.0),noise=W) sol = solve(prob,SRIW1())</p><pre><code class="nohighlight hljs">
![Scalar Noise](../assets/matrix_sde_scalar_noise.png)

## Example 4: Systems of SDEs with Non-Diagonal Noise

In the previous examples we had diagonal noise, that is a vector of random numbers
`dW` whose size matches the output of `g` where the noise is applied element-wise,
and scalar noise where a single random variable is applied to all dependent variables.
However, a more general type of noise allows for the terms to linearly mixed via `g`
being a matrix.

(Note that nonlinear mixings are not SDEs but fall under the more general class of
random ordinary differential equations (RODEs) which have a
[separate set of solvers](@ref rode_example).

Let&#39;s define a problem with four Wiener processes and two dependent random variables.
In this case, we will want the output of `g` to be a 2x4 matrix, such that the solution
is `g(u,p,t)*dW`, the matrix multiplication. For example, we can do the following:
</code></pre><p>julia f(du,u,p,t) = du .= 1.01u function g(du,u,p,t)   du[1,1] = 0.3u[1]   du[1,2] = 0.6u[1]   du[1,3] = 0.9u[1]   du[1,4] = 0.12u[1]   du[2,1] = 1.2u[2]   du[2,2] = 0.2u[2]   du[2,3] = 0.3u[2]   du[2,4] = 1.8u[2] end prob = SDEProblem(f,g,ones(2),(0.0,1.0),noise<em>rate</em>prototype=zeros(2,4))</p><pre><code class="nohighlight hljs">In our `g` we define the functions for computing the values of the matrix.
We can now think of the SDE that this solves as the system of equations
</code></pre><p>math du<em>1 = f</em>1(u,p,t)dt + g<em>{11}(u,p,t)dW</em>1 + g<em>{12}(u,p,t)dW</em>2 + g<em>{13}(u,p,t)dW</em>3 + g<em>{14}(u,p,t)dW</em>4 \
du<em>2 = f</em>2(u,p,t)dt + g<em>{21}(u,p,t)dW</em>1 + g<em>{22}(u,p,t)dW</em>2 + g<em>{23}(u,p,t)dW</em>3 + g<em>{24}(u,p,t)dW</em>4</p><pre><code class="nohighlight hljs">
meaning that for example `du[1,1]` and `du[2,1]` correspond to stochastic changes with
the same random number in the first and second SDEs.


!!! note
    This problem can only be solved my SDE methods which are compatible with non-diagonal
    noise. This is discussed [in the SDE solvers page](@ref sde_solve).

The matrix itself is determined by the keyword argument `noise_rate_prototype` in the `SDEProblem`
constructor. This is a prototype for the type that `du` will be in `g`. This can
be any `AbstractMatrix` type. Thus for example, we can define the problem as
</code></pre><p>julia</p><h1 id="Define-a-sparse-matrix-by-making-a-dense-matrix-and-setting-some-values-as-not-zero"><a class="docs-heading-anchor" href="#Define-a-sparse-matrix-by-making-a-dense-matrix-and-setting-some-values-as-not-zero">Define a sparse matrix by making a dense matrix and setting some values as not zero</a><a id="Define-a-sparse-matrix-by-making-a-dense-matrix-and-setting-some-values-as-not-zero-1"></a><a class="docs-heading-anchor-permalink" href="#Define-a-sparse-matrix-by-making-a-dense-matrix-and-setting-some-values-as-not-zero" title="Permalink"></a></h1><p>A = zeros(2,4) A[1,1] = 1 A[1,4] = 1 A[2,4] = 1 A=sparse(A)</p><h1 id="Make-g-write-the-sparse-matrix-values"><a class="docs-heading-anchor" href="#Make-g-write-the-sparse-matrix-values">Make <code>g</code> write the sparse matrix values</a><a id="Make-g-write-the-sparse-matrix-values-1"></a><a class="docs-heading-anchor-permalink" href="#Make-g-write-the-sparse-matrix-values" title="Permalink"></a></h1><p>function g(du,u,p,t)   du[1,1] = 0.3u[1]   du[1,4] = 0.12u[2]   du[2,4] = 1.8u[2] end</p><h1 id="Make-g-use-the-sparse-matrix"><a class="docs-heading-anchor" href="#Make-g-use-the-sparse-matrix">Make <code>g</code> use the sparse matrix</a><a id="Make-g-use-the-sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Make-g-use-the-sparse-matrix" title="Permalink"></a></h1><p>prob = SDEProblem(f,g,ones(2),(0.0,1.0),noise<em>rate</em>prototype=A)</p><pre><code class="nohighlight hljs">
and now `g(u,p,t)` writes into a sparse matrix, and `g(u,p,t)*dW` is sparse matrix
multiplication.

## Example 4: Colored Noise

Colored noise can be defined [using the Noise Process interface](@ref noise_process).
In that portion of the docs, it is shown how to define your own noise process
`my_noise`, which can be passed to the SDEProblem
</code></pre><p>julia SDEProblem(f,g,u0,tspan,noise=my_noise)</p><pre><code class="nohighlight hljs">
Note that general colored noise problems are only compatible with the `EM` and `EulerHeun` methods.
This is discussed [in the SDE solvers page](@ref sde_solve).

### Example: Spatially-Colored Noise in the Heston Model

Let&#39;s define the Heston equation from financial mathematics:
</code></pre><p>math dS = Î¼Sdt + \sqrt{v}SdW<em>1 \
dv = Îº(Î-v)dt + Ï\sqrt{v}dW</em>2 \
dW<em>1 dW</em>2 = Ï dt</p><pre><code class="nohighlight hljs">
In this problem, we have a diagonal noise problem given by:
</code></pre><p>julia function f(du,u,p,t)   du[1] = Î¼<em>u[1]   du[2] = Îº</em>(Î-u[2]) end function g(du,u,p,t)   du[1] = âu[2]<em>u[1]   du[2] = Î</em>âu[2] end</p><pre><code class="nohighlight hljs">
However, our noise has a correlation matrix for some constant `Ï`. Choosing `Ï=0.2`:
</code></pre><p>julia Î = [1 Ï;Ï 1]</p><pre><code class="nohighlight hljs">
To solve this, we can define a `CorrelatedWienerProcess` which starts at zero (`W(0)=0`)
via:
</code></pre><p>julia heston_noise = CorrelatedWienerProcess!(Î,tspan[1],zeros(2),zeros(2))</p><pre><code class="nohighlight hljs">
This is then used to build the SDE:
</code></pre><p>julia SDEProblem(f,g,u0,tspan,noise=heston_noise) ```</p><p>Of course, to fully define this problem we need to define our constants. Constructors for making common models like this easier to define can be found in the modeling toolkits. For example, the <code>HestonProblem</code> is pre-defined as part of the <a href="../../models/financial/#financial_models">financial modeling tools</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../advanced_ode_example/">Â« Solving Large Stiff Equations</a><a class="docs-footer-nextpage" href="../rode_example/">Random Ordinary Differential Equations Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Wednesday 8 June 2022 02:06">Wednesday 8 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
