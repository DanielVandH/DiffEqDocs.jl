<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Noise Processes Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link rel="canonical" href="https://diffeq.sciml.ai/stable/features/noise_process/"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DifferentialEquations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">DifferentialEquations.jl: Scientific Machine Learning (SciML) Enabled Simulation and Estimation</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/sdae_types/">SDAE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/sdde_types/">SDDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../../solvers/discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../../solvers/ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/nonautonomous_linear_ode/">Non-autonomous Linear ODE / Lie Group ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../../solvers/steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../../solvers/bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../../solvers/jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../../solvers/sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdae_solve/">SDAE Solvers</a></li><li><a class="tocitem" href="../../solvers/rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../../solvers/dde_solve/">DDE Solvers</a></li><li><a class="tocitem" href="../../solvers/sdde_solve/">SDDE Solvers</a></li><li><a class="tocitem" href="../../solvers/dae_solve/">DAE Solvers</a></li><li><a class="tocitem" href="../../solvers/benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../diffeq_operator/">DiffEqOperators</a></li><li class="is-active"><a class="tocitem" href>Noise Processes</a><ul class="internal"><li><a class="tocitem" href="#Using-Noise-Processes"><span>Using Noise Processes</span></a></li><li><a class="tocitem" href="#Noise-Process-Types"><span>Noise Process Types</span></a></li><li><a class="tocitem" href="#Non-Standard-Noise-Processes"><span>Non-Standard Noise Processes</span></a></li><li><a class="tocitem" href="#Examples-Using-Non-Standard-Noise-Processes"><span>Examples Using Non-Standard Noise Processes</span></a></li></ul></li><li><a class="tocitem" href="../linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../callback_library/">Callback Library</a></li><li><a class="tocitem" href="../ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/chemical_reactions/">Chemical Reactions</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Additional Features</a></li><li class="is-active"><a href>Noise Processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Noise Processes</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/features/noise_process.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="noise_process"><a class="docs-heading-anchor" href="#noise_process">Noise Processes</a><a id="noise_process-1"></a><a class="docs-heading-anchor-permalink" href="#noise_process" title="Permalink"></a></h1><p>Noise processes are essential in continuous stochastic modeling. The <code>NoiseProcess</code> types are distributionally-exact, meaning they are not solutions of stochastic differential equations and instead are directly generated according to their analytical distributions. These processes are used as the noise term in the SDE and RODE solvers. Additionally, the noise processes themselves can be simulated and solved using the DiffEq common interface (including the Monte Carlo interface).</p><p>This page first describes how to use noise processes in SDEs, and analyze/simulate noise processes directly. Then it describes the standard noise processes which are available. Processes like <code>WienerProcess</code>, <code>CorrelatedWienerProcess</code>, <code>GeometricBrownianMotionProcess</code>, <code>BrownianBridgeProcess</code> and <code>OrnsteinUhlenbeckProcess</code> are pre-defined. Then it is shown how one can define the distributions for a new <code>NoiseProcess</code>.</p><p>In addition to the <code>NoiseProcess</code> type, more general <code>AbstractNoiseProcess</code>es are defined. The <code>NoiseGrid</code> allows you to define a noise process from a set of pre-calculated points (the &quot;normal&quot; way). The <code>NoiseApproximation</code> allows you to define a new noise process as the solution to some stochastic differential equation. While these methods are only approximate, they are more general and allow the user to easily define their own colored noise to use in simulations.</p><p>The <code>NoiseWrapper</code> allows one to wrap a <code>NoiseProcess</code> from a previous simulation to re-use it in a new simulation in a way that follows the same stochastic trajectory (even if different points are hit, for example solving with a smaller <code>dt</code>) in a distributionally-exact manner. It is demonstrated how the <code>NoiseWrapper</code> can be used to wrap the <code>NoiseProcess</code> of one SDE/RODE solution in order to re-use the same noise process in another simulation.</p><p>The <code>VirtualBrownianTree</code> allows one to trade speed for O(1) memory usage. Instead of storing Brownian motion increments, the <code>VirtualBrownianTree</code> samples recursively from the midpoint <code>tmid</code> of Brownian bridges, using a splittable PRNG. The recursion terminates when the query time agrees within some tolerance with <code>tmid</code> or when the maximum depth of the tree is reached.</p><p>Lastly, the <code>NoiseFunction</code> allows you to use any function of time as the noise process. Together, this functionality allows you to define any colored noise process and use this efficiently and accurately in your simulations.</p><h2 id="Using-Noise-Processes"><a class="docs-heading-anchor" href="#Using-Noise-Processes">Using Noise Processes</a><a id="Using-Noise-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Noise-Processes" title="Permalink"></a></h2><h3 id="Passing-a-Noise-Process-to-a-Problem-Type"><a class="docs-heading-anchor" href="#Passing-a-Noise-Process-to-a-Problem-Type">Passing a Noise Process to a Problem Type</a><a id="Passing-a-Noise-Process-to-a-Problem-Type-1"></a><a class="docs-heading-anchor-permalink" href="#Passing-a-Noise-Process-to-a-Problem-Type" title="Permalink"></a></h3><p><code>AbstractNoiseProcess</code>es can be passed directly to the problem types to replace the standard Wiener process (Brownian motion) with your choice of noise. To do this, simply construct the noise and pass it to the <code>noise</code> keyword argument:</p><pre><code class="language-julia">Î¼ = 1.0
Ï = 2.0
W = GeometricBrownianMotionProcess(Î¼,Ï,0.0,1.0,1.0)
# ...
# Define f,g,u0,tspan for a SDEProblem
# ...
prob = SDEProblem(f,g,u0,tspan,noise=W)</code></pre><h3 id="Basic-Interface"><a class="docs-heading-anchor" href="#Basic-Interface">Basic Interface</a><a id="Basic-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Interface" title="Permalink"></a></h3><p>The <code>NoiseProcess</code> acts like a DiffEq solution. For some noise process <code>W</code>, you can get its <code>i</code>th timepoint like <code>W[i]</code> and the associated time <code>W.t[i]</code>. If the <code>NoiseProcess</code> has a bridging distribution defined, it can be interpolated to arbitrary time points using <code>W(t)</code>. Note that every interpolated value is saved to the <code>NoiseProcess</code> so that way it can stay distributionally correct. A plot recipe is provided which plots the timeseries.</p><h3 id="Direct-Simulation-of-the-Noise-Process"><a class="docs-heading-anchor" href="#Direct-Simulation-of-the-Noise-Process">Direct Simulation of the Noise Process</a><a id="Direct-Simulation-of-the-Noise-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Simulation-of-the-Noise-Process" title="Permalink"></a></h3><p>Since the <code>NoiseProcess</code> types are distribution-exact and do not require the stochastic differential equation solvers, many times one would like to directly simulate trajectories from these proecesses. The <code>NoiseProcess</code> has a <code>NoiseProcessProblem</code> type:</p><pre><code class="language-julia">NoiseProblem(noise,tspan)</code></pre><p>for which <code>solve</code> works. For example, we can simulate a distributionally-exact Geometric Brownian Motion solution by:</p><pre><code class="language-julia">Î¼ = 1.0
Ï = 2.0
W = GeometricBrownianMotionProcess(Î¼,Ï,0.0,1.0,1.0)
prob = NoiseProblem(W,(0.0,1.0))
sol = solve(prob;dt=0.1)</code></pre><p><code>solve</code> requires the <code>dt</code> is given, the solution it returns is a <code>NoiseProcess</code> which has stepped through the timespan. Because this follows the common interface, all of the normal functionality works. For example, we can use the Monte Carlo functionality as follows:</p><pre><code class="language-julia">monte_prob = MonteCarloProblem(prob)
sol = solve(monte_prob;dt=0.1,num_monte=100)</code></pre><p>simulates 100 Geometric Brownian Motions.</p><h3 id="Direct-Interface"><a class="docs-heading-anchor" href="#Direct-Interface">Direct Interface</a><a id="Direct-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Interface" title="Permalink"></a></h3><p>Most of the time, a <code>NoiseProcess</code> is received from the solution of a stochastic or random differential equation, in which case <code>sol.W</code> gives the <code>NoiseProcess</code> and it is already defined along some timeseries. In other cases, <code>NoiseProcess</code> types are directly simulated (see below). However, <code>NoiseProcess</code> types can also be directly acted on. The basic functionality is given by <code>calculate_step!</code> to calculate a future time point, and <code>accept_step!</code> to accept the step. If steps are rejected, the Rejection Sampling with Memory algorithm is applied to keep the solution distributionally exact. This kind of stepping is done via:</p><pre><code class="language-julia">W = WienerProcess(0.0,1.0,1.0)
dt = 0.1
W.dt = dt
u = nothing; p = nothing # for state-dependent distributions
calculate_step!(W,dt,u,p)
for i in 1:10
  accept_step!(W,dt,u,p)
end</code></pre><h2 id="Noise-Process-Types"><a class="docs-heading-anchor" href="#Noise-Process-Types">Noise Process Types</a><a id="Noise-Process-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Noise-Process-Types" title="Permalink"></a></h2><p>This section describes the available <code>NoiseProcess</code> types. Note that all keyword arguments are splatted into the <code>NoiseProcess</code> constructor, and thus options like <code>reset</code> are available on the pre-built processes.</p><h3 id="Wiener-Process"><a class="docs-heading-anchor" href="#Wiener-Process">Wiener Process</a><a id="Wiener-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Wiener-Process" title="Permalink"></a></h3><p>The <code>WienerProcess</code>, also known as Brownian motion, or the noise in the Langevin equation, is the stationary process with white noise increments and a distribution <code>N(0,dt)</code>. The constructor is:</p><pre><code class="language-julia">WienerProcess(t0,W0,Z0=nothing;kwargs...)
WienerProcess!(t0,W0,Z0=nothing;kwargs...)</code></pre><h3 id="Real-Wiener-Process"><a class="docs-heading-anchor" href="#Real-Wiener-Process">Real Wiener Process</a><a id="Real-Wiener-Process-1"></a><a class="docs-heading-anchor-permalink" href="#Real-Wiener-Process" title="Permalink"></a></h3><p>The <code>RealWienerProcess</code> is a Brownian motion that is forced to be real-valued. While the normal <code>WienerProcess</code> becomes complex valued if <code>W0</code> is complex, this verion is real valued for when you want to, for example, solve an SDE defined by complex numbers where the noise is in the reals.</p><pre><code class="language-julia">RealWienerProcess(t0,W0,Z0=nothing;kwargs...)
RealWienerProcess!(t0,W0,Z0=nothing;kwargs...)</code></pre><h3 id="Correlated-Noise"><a class="docs-heading-anchor" href="#Correlated-Noise">Correlated Noise</a><a id="Correlated-Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Correlated-Noise" title="Permalink"></a></h3><p>One can define a <code>CorrelatedWienerProcess</code> which is a Wiener process with correlations between the Wiener processes. The constructor is:</p><pre><code class="language-julia">CorrelatedWienerProcess(Î,t0,W0,Z0=nothing;kwargs...)
CorrelatedWienerProcess!(Î,t0,W0,Z0=nothing;kwargs...)</code></pre><p>where <code>Î</code> is the constant covariance matrix.</p><h3 id="Geometric-Brownian-Motion"><a class="docs-heading-anchor" href="#Geometric-Brownian-Motion">Geometric Brownian Motion</a><a id="Geometric-Brownian-Motion-1"></a><a class="docs-heading-anchor-permalink" href="#Geometric-Brownian-Motion" title="Permalink"></a></h3><p>A <code>GeometricBrownianMotion</code> process is a Wiener process with constant drift <code>Î¼</code> and constant diffusion <code>Ï</code>. I.e. this is the solution of the stochastic differential equation</p><p class="math-container">\[dX_t = \mu X_t dt + \sigma X_t dW_t\]</p><p>The <code>GeometricBrownianMotionProcess</code> is distribution exact (meaning, not a numerical solution of the stochastic differential equation, and instead follows the exact distribution properties). It can be back interpolated exactly as well. The constructor is:</p><pre><code class="language-julia">GeometricBrownianMotionProcess(Î¼,Ï,t0,W0,Z0=nothing;kwargs...)
GeometricBrownianMotionProcess!(Î¼,Ï,t0,W0,Z0=nothing;kwargs...)</code></pre><h3 id="Brownian-Bridge"><a class="docs-heading-anchor" href="#Brownian-Bridge">Brownian Bridge</a><a id="Brownian-Bridge-1"></a><a class="docs-heading-anchor-permalink" href="#Brownian-Bridge" title="Permalink"></a></h3><p>A <code>BrownianBridge</code> process is a Wiener process with a pre-defined start and end value. This process is distribution exact and back be back interpolated exactly as well. The constructor is:</p><pre><code class="language-julia">BrownianBridge(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)
BrownianBridge!(t0,tend,W0,Wend,Z0=nothing,Zend=nothing;kwargs...)</code></pre><p>where <code>W(t0)=Wâ</code>, <code>W(tend)=Wend</code>, and likewise for the <code>Z</code> process if defined.</p><h3 id="Ornstein-Uhlenbeck"><a class="docs-heading-anchor" href="#Ornstein-Uhlenbeck">Ornstein-Uhlenbeck</a><a id="Ornstein-Uhlenbeck-1"></a><a class="docs-heading-anchor-permalink" href="#Ornstein-Uhlenbeck" title="Permalink"></a></h3><p>One can define a <code>Ornstein-Uhlenbeck</code> process which is a Wiener process defined by the stochastic differential equation</p><p class="math-container">\[dX_t = \theta (\mu - X_t) dt + \sigma dW_t\]</p><p>The <code>OrnsteinUhlenbeckProcess</code> is distribution exact (meaning, not a numerical solution of the stochastic differential equation, and instead follows the exact distribution properties). The constructor is:</p><pre><code class="language-julia">OrnsteinUhlenbeckProcess(Î,Î¼,Ï,t0,W0,Z0=nothing;kwargs...)
OrnsteinUhlenbeckProcess!(Î,Î¼,Ï,t0,W0,Z0=nothing;kwargs...)</code></pre><h3 id="Direct-Construction-of-a-NoiseProcess"><a class="docs-heading-anchor" href="#Direct-Construction-of-a-NoiseProcess">Direct Construction of a NoiseProcess</a><a id="Direct-Construction-of-a-NoiseProcess-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Construction-of-a-NoiseProcess" title="Permalink"></a></h3><p>A <code>NoiseProcess</code> is a type defined as</p><pre><code class="language-julia">NoiseProcess(t0,W0,Z0,dist,bridge;
             iip=SciMLBase.isinplace(dist,3),
             rswm = RSWM(),save_everystep=true,
             rng = Xorshifts.Xoroshiro128Plus(rand(UInt64)),
             reset = true, reseed = true)</code></pre><ul><li><code>t0</code> is the first timepoint</li><li><code>W0</code> is the first value of the process.</li><li><code>Z0</code> is the first value of the pseudo-process. This is necessary for higher order algorithms. If it&#39;s not needed, set to <code>nothing</code>.</li><li><code>dist</code> the distribution for the steps over time.</li><li><code>bridge</code> the bridging distribution. Optional, but required for adaptivity and interpolating at new values.</li><li><code>save_everystep</code> whether to save every step of the Brownian timeseries.</li><li><code>rng</code> the local RNG used for generating the random numbers.</li><li><code>reset</code> whether to reset the process with each solve.</li><li><code>reseed</code> whether to reseed the process with each solve.</li></ul><p>The signature for the <code>dist</code> is</p><pre><code class="language-julia">dist!(rand_vec,W,dt,rng)</code></pre><p>for inplace functions, and</p><pre><code class="language-julia">rand_vec = dist(W,dt,rng)</code></pre><p>otherwise. The signature for <code>bridge</code> is</p><pre><code class="language-julia">bridge!(rand_vec,W,W0,Wh,q,h,rng)</code></pre><p>and the out of place syntax is</p><pre><code class="language-julia">rand_vec = bridge!(W,W0,Wh,q,h,rng)</code></pre><p>Here, <code>W</code> is the noise process, <code>W0</code> is the left side of the current interval, <code>Wh</code> is the right side of the current interval, <code>h</code> is the interval length, and <code>q</code> is the proportion from the left where the interpolation is occuring.</p><h3 id="Direct-Construction-Example"><a class="docs-heading-anchor" href="#Direct-Construction-Example">Direct Construction Example</a><a id="Direct-Construction-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Direct-Construction-Example" title="Permalink"></a></h3><p>The easiest way to show how to directly construct a <code>NoiseProcess</code> is by example. Here we will show how to directly construct a <code>NoiseProcess</code> which generates Gaussian white noise.</p><p>This is the noise process which uses <code>randn!</code>. A special dispatch is added for complex numbers for <code>(randn()+im*randn())/sqrt(2)</code>. This function is <code>DiffEqNoiseProcess.wiener_randn</code> (or with <code>!</code> respectively).</p><p>The first function that must be defined is the noise distribution. This is how to generate <span>$W(t+dt)$</span> given that we know <span>$W(x)$</span> for <span>$xâ[tâ,t]$</span>. For Gaussian white noise, we know that</p><p class="math-container">\[W(dt) â¼ N(0,dt)\]</p><p>for <span>$W(0)=0$</span> which defines the stepping distribution. Thus its noise distribution function is:</p><pre><code class="language-julia">@inline function WHITE_NOISE_DIST(W,dt,rng)
  if typeof(W.dW) &lt;: AbstractArray &amp;&amp; !(typeof(W.dW) &lt;: SArray)
    return @fastmath sqrt(abs(dt))*wiener_randn(rng,W.dW)
  else
    return @fastmath sqrt(abs(dt))*wiener_randn(rng,typeof(W.dW))
  end
end</code></pre><p>for the out of place versions, and for the inplace versions</p><pre><code class="language-julia">function INPLACE_WHITE_NOISE_DIST(rand_vec,W,dt,rng)
  wiener_randn!(rng,rand_vec)
  sqrtabsdt = @fastmath sqrt(abs(dt))
  @. rand_vec *= sqrtabsdt
end</code></pre><p>Optionally, we can provide a bridging distribution. This is the distribution of <span>$W(qh)$</span> for <span>$qâ[0,1]$</span> given that we know <span>$W(0)=0$</span> and <span>$W(h)=Wâ$</span>. For Brownian motion, this is known as the Brownian Bridge, and is well known to have the distribution:</p><p class="math-container">\[W(qh) â¼ N(qWâ,(1-q)qh)\]</p><p>Thus we have the out-of-place and in-place versions as:</p><pre><code class="language-julia">function WHITE_NOISE_BRIDGE(W,W0,Wh,q,h,rng)
  if typeof(W.dW) &lt;: AbstractArray
    return @fastmath sqrt((1-q)*q*abs(h))*wiener_randn(rng,W.dW)+q*Wh
  else
    return @fastmath sqrt((1-q)*q*abs(h))*wiener_randn(rng,typeof(W.dW))+q*Wh
  end
end
function INPLACE_WHITE_NOISE_BRIDGE(rand_vec,W,W0,Wh,q,h,rng)
  wiener_randn!(rng,rand_vec)
  #rand_vec .= sqrt((1.-q).*q.*abs(h)).*rand_vec.+q.*Wh
  sqrtcoeff = @fastmath sqrt((1-q)*q*abs(h))
  @. rand_vec = sqrtcoeff*rand_vec+q*Wh
end</code></pre><p>These functions are then placed in a noise process:</p><pre><code class="language-julia">NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE;kwargs)
NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE;kwargs)</code></pre><p>Notice that we can optionally provide an alternative adaptive algorithm for the timestepping rejections. <code>RSWM()</code> defaults to the Rejection Sampling with Memory 3 algorithm (RSwM3).</p><p>Note that the standard constructors are simply:</p><pre><code class="language-julia">WienerProcess(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,WHITE_NOISE_DIST,WHITE_NOISE_BRIDGE;kwargs)
WienerProcess!(t0,W0,Z0=nothing) = NoiseProcess(t0,W0,Z0,INPLACE_WHITE_NOISE_DIST,INPLACE_WHITE_NOISE_BRIDGE;kwargs)</code></pre><p>These will generate a Wiener process, which can be stepped with <code>step!(W,dt)</code>, and interpolated as <code>W(t)</code>.</p><h2 id="Non-Standard-Noise-Processes"><a class="docs-heading-anchor" href="#Non-Standard-Noise-Processes">Non-Standard Noise Processes</a><a id="Non-Standard-Noise-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Standard-Noise-Processes" title="Permalink"></a></h2><p>In addition to the mathematically-defined noise processes above, there exists more generic functionality for building noise processes from other noise processes, from arbitrary functions, from arrays, and from approximations of stochastic differential equations.</p><h3 id="NoiseWrapper"><a class="docs-heading-anchor" href="#NoiseWrapper">NoiseWrapper</a><a id="NoiseWrapper-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseWrapper" title="Permalink"></a></h3><p>This produces a new noise process from an old one, which will use its interpolation to generate the noise. This allows you to re-use a previous noise process not just with the same timesteps, but also with new (adaptive) timesteps as well. Thus this is very good for doing Multi-level Monte Carlo schemes and strong convergence testing.</p><p>To wrap a noise process, simply use:</p><pre><code class="language-julia">NoiseWrapper(W::NoiseProcess;reset=true)</code></pre><h3 id="NoiseFunction"><a class="docs-heading-anchor" href="#NoiseFunction">NoiseFunction</a><a id="NoiseFunction-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseFunction" title="Permalink"></a></h3><p>This allows you to use any arbitrary function <code>W(t)</code> as a <code>NoiseProcess</code>. This will use the function lazily, only caching values required to minimize function calls, but not store the entire noise array. This requires an initial time point <code>t0</code> in the domain of <code>W</code>. A second function is needed if the desired SDE algorithm requires multiple processes.</p><pre><code class="language-julia">NoiseFunction(t0,W,Z=nothing;noise_prototype=W(t0),reset=true)</code></pre><p>Additionally, one can use an in-place function <code>W(out1,out2,t)</code> for more efficient generation of the arrays for multi-dimensional processes. When the in-place version is used without a dispatch for the out-of-place version, the <code>noise_prototype</code> needs to be set.</p><h3 id="NoiseGrid"><a class="docs-heading-anchor" href="#NoiseGrid">NoiseGrid</a><a id="NoiseGrid-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseGrid" title="Permalink"></a></h3><p>A noise grid builds a noise process from arrays of points. For example, you can generate your desired noise process as an array <code>W</code> with timepoints <code>t</code>, and use the constructor:</p><pre><code class="language-julia">NoiseGrid(t,W,Z=nothing;reset=true)</code></pre><p>to build the associated noise process. This process comes with a linear interpolation of the given points, and thus the grid does not have to match the grid of integration. Thus this can be used for adaptive solutions as well. However, one must make note that the fidelity of the noise process is linked to how fine the noise grid is determined: if the noise grid is sparse on points compared to the integration, then its distributional properties may be slightly perturbed by the linear interpolation. Thus its suggested that the grid size at least approximately match the number of time steps in the integration to ensure accuracy.</p><p>For a one-dimensional process, <code>W</code> should be an <code>AbstractVector</code> of <code>Number</code>s. For multi-dimensional processes, <code>W</code> should be an <code>AbstractVector</code> of the <code>noise_prototype</code>.</p><h3 id="NoiseApproximation"><a class="docs-heading-anchor" href="#NoiseApproximation">NoiseApproximation</a><a id="NoiseApproximation-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseApproximation" title="Permalink"></a></h3><p>In many cases, one would like to define a noise process directly by a stochastic differential equation which does not have an analytical solution. Of course, this will not be distributionally-exact and how well the properties match depends on how well the differential equation is integrated, but in many cases this can be used as a good approximation when other methods are much more difficult.</p><p>A <code>NoiseApproximation</code> is defined by a <code>DEIntegrator</code>. The constructor for a <code>NoiseApproximation</code> is:</p><pre><code class="language-julia">NoiseApproximation(source1::DEIntegrator,source2::Union{DEIntegrator,Nothing}=nothing;reset=true)</code></pre><p>The <code>DEIntegrator</code> should have a final time point of integration far enough such that it will not halt during the integration. For ease of use, you can use a final time point as <code>Inf</code>. Note that the time points do not have to match the time points of the future integration since the interpolant of the SDE solution will be used. Thus the limiting factor is error tolerance and not hitting specific points.</p><h3 id="VirtualBrownianTree"><a class="docs-heading-anchor" href="#VirtualBrownianTree">VirtualBrownianTree</a><a id="VirtualBrownianTree-1"></a><a class="docs-heading-anchor-permalink" href="#VirtualBrownianTree" title="Permalink"></a></h3><p>A <code>VirtualBrownianTree</code> builds the noise process starting from an initial time <code>t0</code>, the first value of the proces <code>W0</code>, and (optionally) the first value <code>Z0</code> for an auxiliary pseudo-process. The constructor is given as</p><pre><code class="language-julia">VirtualBrownianTree(t0,W0,Z0=nothing,dist=WHITE_NOISE_DIST,bridge=VBT_BRIDGE;kwargs...)</code></pre><p>where <code>dist</code> specifies the distribution that is used to generate the end point(s) <code>Wend</code> (<code>Zend</code>) of the noise process for the final time <code>tend</code>. <code>bridge</code> denotes the distribution of the employed Brownian bridge.  Per default <code>tend</code> is fixed to <code>t0+1</code> but can be changed by passing a custom <code>tend</code> as a keyword argument. The following keyword arguments are available:</p><ul><li><code>tend</code> is the end time of the noise process.</li><li><code>Wend</code> is the end value of the noise process.</li><li><code>Zend</code> is the end value of the pseudo-noise process.</li><li><code>atol</code> represents the absolute tolerance determining when the recursion is  terminated.</li><li><code>tree_depth</code> allows one to store a cache of seeds, noise values, and times  to speed up the simulation by reducing the recursion steps.</li><li><code>search_depth</code> maximal search depth for the tree if <code>atol</code> is not reached.</li><li><code>rng</code> the splittable PRNG used for generating the random numbers.  Default: <code>Threefry4x()</code> from the Random123 package.</li></ul><h2 id="Examples-Using-Non-Standard-Noise-Processes"><a class="docs-heading-anchor" href="#Examples-Using-Non-Standard-Noise-Processes">Examples Using Non-Standard Noise Processes</a><a id="Examples-Using-Non-Standard-Noise-Processes-1"></a><a class="docs-heading-anchor-permalink" href="#Examples-Using-Non-Standard-Noise-Processes" title="Permalink"></a></h2><h3 id="NoiseGrid-2"><a class="docs-heading-anchor" href="#NoiseGrid-2">NoiseGrid</a><a class="docs-heading-anchor-permalink" href="#NoiseGrid-2" title="Permalink"></a></h3><p>In this example, we will show you how to define your own version of Brownian motion using an array of pre-calculated points. In normal usage you should use <code>WienerProcess</code> instead since this will have distributionally-exact interpolations while the noise grid uses linear interpolations, but this is a nice example of the workflow.</p><p>To define a <code>NoiseGrid</code> you need to have a set of time points and a set of values for the process. Let&#39;s define a Brownian motion on <code>(0.0,1.0)</code> with a <code>dt=0.001</code>. To do this,</p><pre><code class="language-julia">dt = 0.001
t = 0:dt:1
brownian_values = cumsum([0;[sqrt(dt)*randn() for i in 1:length(t)-1]])</code></pre><p>Now we build the <code>NoiseGrid</code> using these values:</p><pre><code class="language-julia">W = NoiseGrid(t,brownian_values)</code></pre><p>We can then pass <code>W</code> as the <code>noise</code> argument of an <code>SDEProblem</code> to use it in an SDE.</p><h3 id="NoiseWrapper-Example"><a class="docs-heading-anchor" href="#NoiseWrapper-Example">NoiseWrapper Example</a><a id="NoiseWrapper-Example-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseWrapper-Example" title="Permalink"></a></h3><p>In this example, we will solve an SDE three times:</p><ul><li>First to generate a noise process</li><li>Second with the same timesteps to show the values are the same</li><li>Third with half-sized timsteps</li></ul><p>First we will generate a noise process by solving an SDE:</p><pre><code class="language-julia">using StochasticDiffEq,  DiffEqNoiseProcess
f1(u, p, t) = 1.01u
g1(u, p, t) = 1.01u
dt = 1//2^(4)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0))
sol1 = solve(prob1,EM(),dt=dt,save_noise = true)</code></pre><p>Now we wrap the noise into a NoiseWrapper and solve the same problem:</p><pre><code class="language-julia">W2 = NoiseWrapper(sol1.W)
prob1 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W2)
sol2 = solve(prob1,EM(),dt=dt)</code></pre><p>We can test</p><pre><code class="language-julia">@test sol1.u â sol2.u</code></pre><p>to see that the values are essentially equal. Now we can use the same process to solve the same trajectory with a smaller <code>dt</code>:</p><pre><code class="language-julia">W3 = NoiseWrapper(sol1.W)
prob2 = SDEProblem(f1,g1,1.0,(0.0,1.0),noise=W3)

dt = 1//2^(5)
sol3 = solve(prob2,EM(),dt=dt)</code></pre><p>We can plot the results to see what this looks like:</p><pre><code class="language-julia">using Plots
plot(sol1)
plot!(sol2)
plot!(sol3)</code></pre><p><img src="../../assets/noise_process.png" alt="noise_process"/></p><p>In this plot, <code>sol2</code> covers up <code>sol1</code> because they hit essentially the same values. You can see that <code>sol3</code> its similar to the others, because it&#39;s using the same underlying noise process just sampled much finer.</p><p>To double check, we see that:</p><pre><code class="language-julia">plot(sol1.W)
plot!(sol2.W)
plot!(sol3.W)</code></pre><p><img src="../../assets/coupled_wiener.png" alt="coupled_wiener"/></p><p>the coupled Wiener processes coincide at every other time point, and the intermediate timepoints were calculated according to a Brownian bridge.</p><h3 id="Adaptive-NoiseWrapper-Example"><a class="docs-heading-anchor" href="#Adaptive-NoiseWrapper-Example">Adaptive NoiseWrapper Example</a><a id="Adaptive-NoiseWrapper-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptive-NoiseWrapper-Example" title="Permalink"></a></h3><p>Here we will show that the same noise can be used with the adaptive methods using the <code>NoiseWrapper</code>. <code>SRI</code> and <code>SRIW1</code> use slightly different error estimators, and thus give slightly different stepping behavior. We can see how they solve the same 2D SDE differently by using the noise wrapper:</p><pre><code class="language-julia">prob = SDEProblem(f1,g1,ones(2),(0.0,1.0))
sol4 = solve(prob,SRI(),abstol=1e-8, save_noise = true)

W2 = NoiseWrapper(sol4.W)
prob2 = SDEProblem(f1,g1,ones(2),(0.0,1.0),noise=W2)
sol5 = solve(prob2,SRIW1(),abstol=1e-8)

using Plots
plot(sol4)
plot!(sol5)</code></pre><p><img src="../../assets/SRI_SRIW1_diff.png" alt="SRI_SRIW1_diff"/></p><h3 id="NoiseApproximation-Example"><a class="docs-heading-anchor" href="#NoiseApproximation-Example">NoiseApproximation Example</a><a id="NoiseApproximation-Example-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseApproximation-Example" title="Permalink"></a></h3><p>In this example we will show how to use the <code>NoiseApproximation</code> in order to build our own Geometric Brownian Motion from its stochastic differential equation definition. In normal usage, you should use the <code>GeometricBrownianMotionProcess</code> instead since that is more efficient and distributionally-exact.</p><p>First, let&#39;s define the <code>SDEProblem</code>. Here will use a timespan <code>(0.0,Inf)</code> so that way the noise can be used over an indefinite integral.</p><pre><code class="language-julia">const Î¼ = 1.5
const Ï = 1.2
f(u, p, t) = Î¼*u
g(u, p, t) = Ï*u
prob = SDEProblem(f,g,1.0,(0.0,Inf))</code></pre><p>Now we build the noise process by building the integrator and sending that integrator to the <code>NoiseApproximation</code> constructor:</p><pre><code class="language-julia">integrator = init(prob,SRIW1())
W = NoiseApproximation(integrator)</code></pre><p>We can use this noise process like any other noise process. For example, we can now build a geometric Brownian motion whose noise process is colored noise that itself is a geometric Brownian motion:</p><pre><code class="language-julia">prob = SDEProblem(f,g,1.0,(0.0,Inf),noise=W)</code></pre><p>The possibilities are endless.</p><h3 id="VirtualBrownianTree-Example"><a class="docs-heading-anchor" href="#VirtualBrownianTree-Example">VirtualBrownianTree Example</a><a id="VirtualBrownianTree-Example-1"></a><a class="docs-heading-anchor-permalink" href="#VirtualBrownianTree-Example" title="Permalink"></a></h3><p>In this example, we define a multi-dimensional Brownian process based on a <code>VirtualBrownianTree</code> with a minimal <code>tree_depth=0</code> such that memory consumption is minimized.</p><pre><code class="language-julia">  W0 = zeros(10)
  W = VirtualBrownianTree(0.0,W0; tree_depth=0)

  prob = NoiseProblem(W,(0.0,1.0))
  sol = solve(prob;dt=1/10)</code></pre><p>Using a look-up cache by increasing <code>tree_depth</code> can significantly reduce the runtime. Thus, the <code>VirtualBrownianTree</code> allows for trading off speed for memory in a simple manner.</p><h3 id="NoiseFunction-Example"><a class="docs-heading-anchor" href="#NoiseFunction-Example">NoiseFunction Example</a><a id="NoiseFunction-Example-1"></a><a class="docs-heading-anchor-permalink" href="#NoiseFunction-Example" title="Permalink"></a></h3><p>The <code>NoiseFunction</code> is pretty simple: pass a function. As a silly example, we can use <code>exp</code> as a noise process by doing:</p><pre><code class="language-julia">f(t) = exp(t)
W = NoiseFunction(0.0,f)</code></pre><p>If it&#39;s multi-dimensional and an in-place function is used, the <code>noise_prototype</code> must be given. For example:</p><pre><code class="language-julia">f(out,t) = (out.=exp(t))
W = NoiseFunction(0.0,f,noise_prototype=rand(4))</code></pre><p>This allows you to put arbitrarily weird noise into SDEs and RODEs. Have fun.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../diffeq_operator/">Â« DiffEqOperators</a><a class="docs-footer-nextpage" href="../linear_nonlinear/">Specifying (Non)Linear Solvers Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 May 2021 11:03">Thursday 20 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
