<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>SDE Solvers Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/solvers/sde_solve/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="bvp_solve.html">BVP Solvers</a></li><li class="current"><a class="toctext" href="sde_solve.html">SDE Solvers</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Mass-Matrices-and-Stochastic-DAEs-1">Mass Matrices and Stochastic DAEs</a></li><li><a class="toctext" href="#Special-Noise-Forms-1">Special Noise Forms</a></li><li><a class="toctext" href="#Special-Keyword-Arguments-1">Special Keyword Arguments</a></li><li class="toplevel"><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li><li><a class="toctext" href="#StochasticDiffEq.jl-1">StochasticDiffEq.jl</a></li><li><a class="toctext" href="#StochasticCompositeAlgorithm-1">StochasticCompositeAlgorithm</a></li><li><a class="toctext" href="#BridgeDiffEq.jl-1">BridgeDiffEq.jl</a></li></ul></li><li><a class="toctext" href="rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Algorithms</li><li><a href="sde_solve.html">SDE Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/solvers/sde_solve.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>SDE Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#SDE-Solvers-1" id="SDE-Solvers-1">SDE Solvers</a></h1><h2><a class="nav-anchor" href="#Recommended-Methods-1" id="Recommended-Methods-1">Recommended Methods</a></h2><p>For most Ito diagonal and scalar noise problems where a good amount of accuracy is required and mild stiffness may be an issue, the <code>SRIW1</code> algorithm should do well. If the problem has additive noise, then <code>SRA1</code> will be the optimal algorithm. For commutative noise, <code>RKMilCommute</code> is a strong order 1.0 method which utilizes the commutivity property to greatly speed up the Wiktorsson approximation and can choose between Ito and Stratonovich. For non-commutative noise, <code>EM</code> and <code>EulerHeun</code> are the choices (for Ito and Stratonovich interpretations respectively).</p><p>For stiff problems with diagonal noise, <code>ImplicitRKMil</code> is the most efficient method and can choose between Ito and Stratonovich. If the noise is non-diagonal, <code>ImplicitEM</code> and <code>ImplicitEulerHeun</code> are for Ito and Stratonovich respectively. For each of these methods, the parameter <code>theta</code> can be chosen. The default is <code>theta=1/2</code> which will not dampen numerical oscillations and thus is symmetric (and almost symplectic) and will lead to less error when noise is sufficiently small. However, <code>theta=1/2</code> is not L-stable in the drift term, and thus one can receive more stability (L-stability in the drift term) with <code>theta=1</code>, but with a tradeoff of error efficiency in the low noise case. In addition, the option <code>symplectic=true</code> will turns these methods into an implicit Midpoint extension which is symplectic in distribution but has an accuracy tradeoff.</p><h2><a class="nav-anchor" href="#Mass-Matrices-and-Stochastic-DAEs-1" id="Mass-Matrices-and-Stochastic-DAEs-1">Mass Matrices and Stochastic DAEs</a></h2><p>The <code>ImplicitRKMil</code>, <code>ImplicitEM</code>, and <code>ImplicitEulerHeun</code> methods can solve stochastic equations with mass matrices (including stochastic DAEs written in mass matrix form) when either <code>symplectic=true</code> or <code>theta=1</code>.</p><h2><a class="nav-anchor" href="#Special-Noise-Forms-1" id="Special-Noise-Forms-1">Special Noise Forms</a></h2><p>Some solvers are for specialized forms of noise. Diagonal noise is the default setup. Non-diagonal noise is specified via setting <code>noise_rate_prototype</code> to a matrix in the <code>SDEProblem</code> type. A special form of non-diagonal noise, commutative noise, occurs when the noise satisfies the following condition:</p><div>\[\sum_{i=1}^d g_{i,j_1}(t,u) \frac{\partial g_{k,j_2}}{\partial x_i} = \sum_{i=1}^d g_{i,j_2}(t,x) \frac{\partial g_{k,j_1}}{\partial x_i}\]</div><p>for every <span>$j_1,j_2$</span> and <span>$k$</span>. Additive noise is when <span>$g(t,u)=g(t)$</span>, i.e. is independent of <code>u</code>. Multiplicative noise is <span>$g_i(t,u)=a_i u$</span>.</p><h2><a class="nav-anchor" href="#Special-Keyword-Arguments-1" id="Special-Keyword-Arguments-1">Special Keyword Arguments</a></h2><ul><li><p><code>save_noise</code>: Determines whether the values of <code>W</code> are saved whenever the timeseries is saved. Defaults to true.</p></li><li><p><code>delta</code>: The <code>delta</code> adaptivity parameter for the natural error estimator. Determines the balance between drift and diffusion error. For more details, see <a href="http://chrisrackauckas.com/assets/Papers/ChrisRackauckas-AdaptiveSRK.pdf">the publication</a>.</p></li></ul><h1><a class="nav-anchor" href="#Full-List-of-Methods-1" id="Full-List-of-Methods-1">Full List of Methods</a></h1><h2><a class="nav-anchor" href="#StochasticDiffEq.jl-1" id="StochasticDiffEq.jl-1">StochasticDiffEq.jl</a></h2><p>Each of the StochasticDiffEq.jl solvers come with a linear interpolation. Orders are given in terms of strong order.</p><h3><a class="nav-anchor" href="#Nonstiff-Methods-1" id="Nonstiff-Methods-1">Nonstiff Methods</a></h3><ul><li><p><code>EM</code>- The Euler-Maruyama method. Strong Order 0.5 in the Ito sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.â </p></li><li><p><code>EulerHeun</code> - The Euler-Heun method. Strong Order 0.5 in the Stratonovich sense. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.â </p></li><li><p><code>RKMil</code> - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method. Defaults to solving the Ito problem, but <code>RKMil(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. Only handles scalar and diagonal noise.â </p></li><li><p><code>RKMilCommute</code> - An explicit Runge-Kutta discretization of the strong Order 1.0 Milstein method for commutative noise problems. Defaults to solving the Ito problem, but <code>RKMilCommute(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem.â </p></li><li><p><code>SRA</code> - The strong Order 1.5 methods for additive Ito and Stratonovich SDEs due to Rossler. Default tableau is for SRA1. Can handle non-diagonal and scalar additive noise.</p></li><li><p><code>SRI</code> - The strong Order 1.5 methods for diagonal/scalar Ito SDEs due to Rossler. Default tableau is for SRIW1.</p></li><li><p><code>SRIW1</code> - An optimized version of SRIW1. Strong Order 1.5 for diagonal/scalar Ito SDEs.â </p></li><li><p><code>SRA1</code> - An optimized version of SRA1. Strong Order 1.5 for additive Ito and Stratonovich SDEs. Can handle non-diagonal and scalar additive noise.â </p></li></ul><p>Example usage:</p><pre><code class="language-julia">sol = solve(prob,SRIW1())</code></pre><h3><a class="nav-anchor" href="#Tableau-Controls-1" id="Tableau-Controls-1">Tableau Controls</a></h3><p>For <code>SRA</code> and <code>SRI</code>, the following option is allowed:</p><ul><li><p><code>tableau</code>: The tableau for an <code>:SRA</code> or <code>:SRI</code> algorithm. Defaults to SRIW1 or SRA1.</p></li></ul><h3><a class="nav-anchor" href="#Stiff-Methods-1" id="Stiff-Methods-1">Stiff Methods</a></h3><ul><li><p><code>ImplicitEM</code> - An order 0.5 Ito implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.</p></li><li><p><code>ImplicitEulerHeun</code> - An order 0.5 Stratonovich implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Can handle all forms of noise, including non-diagonal, scalar, and colored noise.</p></li><li><p><code>ImplicitRKMil</code> - An order 1.0 implicit method. This is a theta method which defaults to <code>theta=1/2</code> or the Trapezoid method on the drift term. Defaults to solving the Ito problem, but <code>ImplicitRKMil(interpretation=:Stratonovich)</code> makes it solve the Stratonovich problem. This method defaults to <code>symplectic=false</code>, but when true and <code>theta=1/2</code> this is the implicit Midpoint method on the drift term and is symplectic in distribution. Handles diagonal and scalar noise.</p></li></ul><h4><a class="nav-anchor" href="#Note-about-mass-matrices-1" id="Note-about-mass-matrices-1">Note about mass matrices</a></h4><p>These methods interpret the mass matrix equation as:</p><div>\[Mu' = f(t,u)dt + Mg(t,u)dW_t\]</div><p>i.e. with no mass matrix inversion applied to the <code>g</code> term. Thus these methods apply noise per dependent variable instead of on the combinations of the dependent variables and this is designed for phenomenological noise on the dependent variables (like multiplicative or additive noise)</p><h2><a class="nav-anchor" href="#StochasticCompositeAlgorithm-1" id="StochasticCompositeAlgorithm-1">StochasticCompositeAlgorithm</a></h2><p>One unique feature of StochasticDiffEq.jl is the <code>StochasticCompositeAlgorithm</code>, which allows you to, with very minimal overhead, design a multimethod which switches between chosen algorithms as needed. The syntax is <code>StochasticCompositeAlgorithm(algtup,choice_function)</code> where <code>algtup</code> is a tuple of StochasticDiffEq.jl algorithms, and <code>choice_function</code> is a function which declares which method to use in the following step. For example, we can design a multimethod which uses <code>EM()</code> but switches to <code>RKMil()</code> whenever <code>dt</code> is too small:</p><pre><code class="language-julia">choice_function(integrator) = (Int(integrator.dt&lt;0.001) + 1)
alg_switch = StochasticCompositeAlgorithm((EM(),RKMil()),choice_function)</code></pre><p>The <code>choice_function</code> takes in an <code>integrator</code> and thus all of the features available in the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> can be used in the choice function.</p><h2><a class="nav-anchor" href="#BridgeDiffEq.jl-1" id="BridgeDiffEq.jl-1">BridgeDiffEq.jl</a></h2><p>Bridge.jl is a set of fixed timestep algorithms written in Julia. These methods are made and optimized for out-of-place functions on immutable (static vector) types. Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use BridgeDiffEq.jl:</p><pre><code class="language-julia">Pkg.clone("https://github.com/JuliaDiffEq/BridgeDiffEq.jl")
using BridgeDiffEq</code></pre><ul><li><p><code>BridgeEuler</code> - Strong order 0.5 Euler-Maruyama method for Ito equations.â </p></li><li><p><code>BridgeHeun</code> - Strong order 0.5 Euler-Heun method for Stratonovich equations.â </p></li><li><p><code>BridgeSRK</code> - Strong order 1.0 derivative-free stochastic Runge-Kutta method for scalar (<code>&lt;:Number</code>) Ito equations.â </p></li></ul><h4><a class="nav-anchor" href="#Notes-1" id="Notes-1">Notes</a></h4><p>â : Does not step to the interval endpoint. This can cause issues with discontinuity detection, and <a href="features/diffeq_arrays.html">discrete variables need to be updated appropriately</a>.</p><footer><hr/><a class="previous" href="bvp_solve.html"><span class="direction">Previous</span><span class="title">BVP Solvers</span></a><a class="next" href="rode_solve.html"><span class="direction">Next</span><span class="title">RODE Solvers</span></a></footer></article></body></HTML>