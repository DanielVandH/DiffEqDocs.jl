<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>ODE Solvers Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/solvers/ode_solve/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="discrete_solve.html">Discrete Solvers</a></li><li class="current"><a class="toctext" href="ode_solve.html">ODE Solvers</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Translations-from-MATLAB/Python/R-1">Translations from MATLAB/Python/R</a></li><li class="toplevel"><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li><li><a class="toctext" href="#OrdinaryDiffEq.jl-1">OrdinaryDiffEq.jl</a></li><li><a class="toctext" href="#Sundials.jl-1">Sundials.jl</a></li><li><a class="toctext" href="#ODE.jl-1">ODE.jl</a></li><li><a class="toctext" href="#ODEInterface.jl-1">ODEInterface.jl</a></li><li><a class="toctext" href="#LSODA.jl-1">LSODA.jl</a></li><li><a class="toctext" href="#List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></li></ul></li><li><a class="toctext" href="refined_ode_solve.html">Refined ODE Solvers</a></li><li><a class="toctext" href="steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Algorithms</li><li><a href="ode_solve.html">ODE Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/d7651ffe5951aa2a9ca0796fada7c4d97f2dcba9/docs/src/solvers/ode_solve.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ODE Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#ODE-Solvers-1" id="ODE-Solvers-1">ODE Solvers</a></h1><p><code>solve(prob::ODEProblem,alg;kwargs)</code></p><p>Solves the ODE defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2><a class="nav-anchor" href="#Recommended-Methods-1" id="Recommended-Methods-1">Recommended Methods</a></h2><p>It is suggested that you try choosing an algorithm using the <code>alg_hints</code> keyword argument. However, in some cases you may want something specific, or you may just be curious. This guide is to help you choose the right algorithm.</p><h3><a class="nav-anchor" href="#Non-Stiff-Problems-1" id="Non-Stiff-Problems-1">Non-Stiff Problems</a></h3><p>For non-stiff problems, the native OrdinaryDiffEq.jl algorithms are vastly more efficient than the other choices. For most non-stiff problems, we recommend <code>Tsit5</code>. When more robust error control is required, <code>BS5</code> is a good choice. For fast solving at higher tolerances, we recommend <code>BS3</code>. For high accuracy but with the range of <code>Float64</code> (<code>~1e-8-1e-12</code>), we recommend <code>Vern6</code>, <code>Vern7</code>, or <code>Vern8</code> as efficient choices.</p><p>For high accuracy non-stiff solving (<code>BigFloat</code> and tolerances like <code>&lt;1e-12</code>), we recommend the <code>Vern9</code> method. If a high-order method is needed with a high order interpolant, then you should choose <code>Vern9</code> which is Order 9 with an Order 9 interpolant. If you need extremely high accuracy (<code>&lt;1e-30</code>?) and do not need an interpolant, try the <code>Feagin12</code> or <code>Feagin14</code> methods. Note that the Feagin methods are the only high-order optimized methods which do not include a high-order interpolant (they do include a 3rd order Hermite interpolation if needed). Note that these high order RK methods are more robust than the high order Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods. However, the <code>CVODE_Adams</code> method can be a good choice for high accuracy when the system of equations is very large (<code>&gt;10,000</code> ODEs?) or the function calculation is very expensive.</p><h3><a class="nav-anchor" href="#Stiff-Problems-1" id="Stiff-Problems-1">Stiff Problems</a></h3><p>For stiff problems at high tolerances (<code>&gt;1e-2</code>?) it is recommended that you use <code>Rosenbrock23</code>. At medium tolerances (<code>&gt;1e-8</code>?) it is recommended you use <code>Rodas4</code> or <code>Rodas4P</code> (the former is slightly more efficient but the later is much more reliable). As native DifferentialEquations.jl solvers, many Julia numeric types (such as BigFloats, <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">ArbFloats</a>, or <a href="https://github.com/stevengj/DecFP.jl">DecFP</a>) will work. When the equation is defined via the <code>@ode_def</code> macro, this will be the most efficient. For faster solving at low tolerances (<code>&lt;1e-9</code>) but when <code>Vector{Float64}</code> is used, use <code>radau</code>. High precision numbers are also compatible with <code>Trapezoid</code> which is a symplectic integrator. Notice that <code>Rodas4</code> loses accuracy on discretizations of nonlinear parabolic PDEs, and thus it's suggested you replace it with <code>Rodas4P</code> in those situations. For asymtopically large systems of ODEs (<code>N&gt;10000</code>?) where <code>f</code> is very costly and the complex eigenvalues are minimal (low oscillations), in that case <code>CVODE_BDF</code> will be the most efficient but requires <code>Vector{Float64}</code>.</p><h2><a class="nav-anchor" href="#Translations-from-MATLAB/Python/R-1" id="Translations-from-MATLAB/Python/R-1">Translations from MATLAB/Python/R</a></h2><p>For users familiar with MATLAB/Python/R, good translations of the standard library methods are as follows:</p><ul><li><p><code>ode23</code> â&gt; <code>BS3()</code></p></li><li><p><code>ode45</code>/<code>dopri5</code> â&gt; <code>DP5()</code>, though in most cases <code>Tsit5()</code> is more efficient</p></li><li><p><code>ode23s</code> â&gt; <code>Rosenbrock23()</code>, though in most cases <code>Rodas4()</code> is more efficient</p></li><li><p><code>ode113</code> â&gt; <code>CVODE_Adams()</code>, though in many cases <code>Vern7()</code> is more efficient</p></li><li><p><code>dop853</code> â&gt; <code>DP8()</code>, though in most cases <code>Vern7()</code> is more efficient</p></li><li><p><code>ode15s</code>/<code>vode</code> â&gt; <code>CVODE_BDF()</code>, though in many cases <code>Rodas4()</code> or <code>radau()</code> are more efficient</p></li><li><p><code>ode23t</code> â&gt; <code>Trapezoid()</code></p></li><li><p><code>lsoda</code> â&gt; <code>lsoda()</code> (requires <code>Pkg.add("LSODA"); using LSODA</code>)</p></li><li><p><code>ode15i</code> â&gt; <code>IDA()</code>, though in many cases <code>Rodas4()</code> can handle the DAE and is significantly more efficient</p></li></ul><h1><a class="nav-anchor" href="#Full-List-of-Methods-1" id="Full-List-of-Methods-1">Full List of Methods</a></h1><p>Choose one of these methods with the <code>alg</code> keyword in <code>solve</code>.</p><h2><a class="nav-anchor" href="#OrdinaryDiffEq.jl-1" id="OrdinaryDiffEq.jl-1">OrdinaryDiffEq.jl</a></h2><p>Unless otherwise specified, the OrdinaryDiffEq algorithms all come with a 3rd order Hermite polynomial interpolation. The algorithms denoted as having a "free" interpolation means that no extra steps are required for the interpolation. For the non-free higher order interpolating functions, the extra steps are computed lazily (i.e. not during the solve).</p><p>The OrdinaryDiffEq.jl algorithms achieve the highest performance for non-stiff equations while being the most generic: accepting the most Julia-based types, allow for sophisticated event handling, etc. They are recommended for all non-stiff problems. For stiff problems, the algorithms are currently not as high of order or as well-optimized as the ODEInterface.jl or Sundials.jl algorithms, and thus if the problem is on arrays of Float64, they are recommended. However, the stiff methods from OrdinaryDiffEq.jl are able to handle a larger generality of number types (arbitrary precision, etc.) and thus are recommended for stiff problems on non-Float64 numbers.</p><h3><a class="nav-anchor" href="#Runge-Kutta-Methods-for-Non-Stiff-Equations-1" id="Runge-Kutta-Methods-for-Non-Stiff-Equations-1">Runge-Kutta Methods for Non-Stiff Equations</a></h3><ul><li><p><code>Euler</code>- The canonical forward Euler method.</p></li><li><p><code>Midpoint</code> - The second order midpoint method.</p></li><li><p><code>RK4</code> - The canonical Runge-Kutta Order 4 method.</p></li><li><p><code>BS3</code> - Bogacki-Shampine 3/2 method.</p></li><li><p><code>DP5</code> - Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant)</p></li><li><p><code>Tsit5</code> - Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant)</p></li><li><p><code>BS5</code> - Bogacki-Shampine 5/4 Runge-Kutta method. (5th order interpolant)</p></li><li><p><code>Vern6</code> - Verner's "Most Efficient" 6/5 Runge-Kutta method. (6th order interpolant)</p></li><li><p><code>Vern7</code> - Verner's "Most Efficient" 7/6 Runge-Kutta method. (7th order interpolant)</p></li><li><p><code>TanYam7</code> - Tanaka-Yamashita 7 Runge-Kutta method.</p></li><li><p><code>DP8</code> - Hairer's 8/5/3 adaption of the Dormand-Prince 8   method Runge-Kutta method. (7th order interpolant)</p></li><li><p><code>TsitPap8</code> - Tsitouras-Papakostas 8/7 Runge-Kutta method.</p></li><li><p><code>Vern8</code> - Verner's "Most Efficient" 8/7 Runge-Kutta method. (8th order interpolant)</p></li><li><p><code>Vern9</code> - Verner's "Most Efficient" 9/8 Runge-Kutta method. (9th order interpolant)</p></li><li><p><code>Feagin10</code> - Feagin's 10th-order Runge-Kutta method.</p></li><li><p><code>Feagin12</code> - Feagin's 12th-order Runge-Kutta method.</p></li><li><p><code>Feagin14</code> - Feagin's 14th-order Runge-Kutta method.</p></li></ul><p>Example usage:</p><pre><code class="language-julia">alg = Tsit5()
solve(prob,alg)  </code></pre><h3><a class="nav-anchor" href="#Strong-Stability-Presurving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1" id="Strong-Stability-Presurving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1">Strong-Stability Presurving Runge-Kutta Methods for Hyperbolic PDEs (Conservation Laws)</a></h3><ul><li><p><code>SSPRK22</code> - The two-stage, second order strong stability preserving (SSP) method of Shu and Osher. (free 2nd order SSP interpolant)</p></li><li><p><code>SSPRK33</code> - The three-stage, third order strong stability preserving (SSP) method of Shu and Osher. (free 2nd order SSP interpolant)</p></li><li><p><code>SSPRK432</code> - A  3/2 adaptive strong stability preserving (SSP) method with five stages. (free 2nd order SSP interpolant)</p></li><li><p><code>SSPRK104</code> - The ten-stage, fourth order strong stability preserving method of Ketcheson. (free 3rd order Hermite interpolant)</p></li></ul><h3><a class="nav-anchor" href="#Methods-for-Stiff-Equations-1" id="Methods-for-Stiff-Equations-1">Methods for Stiff Equations</a></h3><ul><li><p><code>ImplicitEuler</code> - A 1st order implicit solver. Unconditionally stable.</p></li><li><p><code>Trapezoid</code> - A second order unconditionally stable symplectic implicit solver. Good for highly stiff.</p></li><li><p><code>Rosenbrock23</code> - An Order 2/3 L-Stable fast solver which is good for mildy stiff equations with oscillations at low tolerances.</p></li><li><p><code>Rosenbrock32</code> - An Order 3/2 A-Stable fast solver which is good for mildy stiff equations</p></li></ul><p>without oscillations at low tolerances. Note that this method is prone to instability in the  presence of oscillations, so use with caution.</p><ul><li><p><code>ROS3P</code> - 3rd order A-stable and stiffly stable (Index-1 DAE compatible) Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</p></li><li><p><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</p></li><li><p><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</p></li><li><p><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</p></li><li><p><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</p></li><li><p><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</p></li><li><p><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially "anti-L-stable" but efficient.</p></li><li><p><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</p></li><li><p><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p></li><li><p><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p></li><li><p><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</p></li><li><p><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. Work in progress.</p></li></ul><h4><a class="nav-anchor" href="#Extra-Options-1" id="Extra-Options-1">Extra Options</a></h4><p>The following methods allow for specification of <code>linsolve</code>: the linear solver which is used:</p><ul><li><p><code>Rosenbrock23</code></p></li><li><p><code>Rosenbrock32</code></p></li><li><p><code>ROS3P</code></p></li><li><p><code>Rodas3</code></p></li><li><p><code>RosShamp4</code></p></li><li><p><code>Veldd4</code></p></li><li><p><code>Velds4</code></p></li><li><p><code>GRK4T</code></p></li><li><p><code>GRK4A</code></p></li><li><p><code>Ros4LStab</code></p></li><li><p><code>Rodas4</code></p></li><li><p><code>Rodas42</code></p></li><li><p><code>Rodas4P</code></p></li><li><p><code>Rodas5</code></p></li></ul><p>For more information on specifying the linear solver, see <a href="features/linear_nonlinear.html">the manual page on solver specification</a>.</p><p>The following methods allow for specification of <code>nlsolve</code>: the nonlinear solver which is used:</p><ul><li><p><code>ImplicitEuler</code></p></li><li><p><code>Trapezoid</code></p></li></ul><p>Note that performance overload information (Jacobians etc.) are not used in this mode. For more information on specifying the nonlinear solver, see <a href="features/linear_nonlinear.html">the manual page on solver specification</a>.</p><p>Additionally, the following methods have extra differentiation controls:</p><ul><li><p><code>Rosenbrock23</code></p></li><li><p><code>Rosenbrock32</code></p></li><li><p><code>ROS3P</code></p></li><li><p><code>Rodas3</code></p></li><li><p><code>RosShamp4</code></p></li><li><p><code>Veldd4</code></p></li><li><p><code>Velds4</code></p></li><li><p><code>GRK4T</code></p></li><li><p><code>GRK4A</code></p></li><li><p><code>Ros4LStab</code></p></li><li><p><code>Rodas4</code></p></li><li><p><code>Rodas42</code></p></li><li><p><code>Rodas4P</code></p></li><li><p><code>Rodas5</code></p></li><li><p><code>ImplicitEuler</code></p></li><li><p><code>Trapezoid</code></p></li></ul><p>In each of these, <code>autodiff</code> can be set to turn on/off autodifferentiation, and <code>chunk_size</code> can be used to set the chunksize of the Dual numbers (see the <a href="http://www.juliadiff.org/ForwardDiff.jl/advanced_usage.html#configuring-chunk-size">documentation for ForwardDiff.jl for details</a>). In addition, the Rosenbrock methods can set <code>diff_type</code>, which is the type of numerical differentiation that is used (when autodifferentiation is disabled). The choices are <code>:central</code> or <code>:forward</code>.</p><p>Examples:</p><pre><code class="language-julia">sol = solve(prob,Rosenbrock23()) # Standard, uses autodiff
sol = solve(prob,Rosenbrock23(chunk_size=10)) # Autodiff with chunksize of 10
sol = solve(prob,Rosenbrock23(autodiff=false)) # Numerical differentiation with central differencing
sol = solve(prob,Rosenbrock23(autodiff=false,diff_type=:forward)) # Numerical differentiation with forward differencing</code></pre><h3><a class="nav-anchor" href="#Tableau-Method-1" id="Tableau-Method-1">Tableau Method</a></h3><p>Additionally, there is the tableau method:</p><ul><li><p><code>ExplicitRK</code> - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus</p></li></ul><p>are specified via the keyword argument <code>tab=tableau</code>. The default tableau is   for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.</p><p>Example usage:</p><pre><code class="language-julia">alg = ExplicitRK(tableau=constructDormandPrince())
solve(prob,alg)</code></pre><h3><a class="nav-anchor" href="#CompositeAlgorithm-1" id="CompositeAlgorithm-1">CompositeAlgorithm</a></h3><p>One unique feature of OrdinaryDiffEq.jl is the <code>CompositeAlgorithm</code>, which allows you to, with very minimal overhead, design a multimethod which switches between chosen algorithms as needed. The syntax is <code>CompositeAlgorthm(algtup,choice_function)</code> where <code>algtup</code> is a tuple of OrdinaryDiffEq.jl algorithms, and <code>choice_function</code> is a function which declares which method to use in the following step. For example, we can design a multimethod which uses <code>Tsit5()</code> but switches to <code>Vern7()</code> whenever <code>dt</code> is too small:</p><pre><code class="language-julia">choice_function(integrator) = (Int(integrator.dt&lt;0.001) + 1)
alg_switch = CompositeAlgorithm((Tsit5(),Vern7()),choice_function)</code></pre><p>The <code>choice_function</code> takes in an <code>integrator</code> and thus all of the features available in the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> can be used in the choice function.</p><h2><a class="nav-anchor" href="#Sundials.jl-1" id="Sundials.jl-1">Sundials.jl</a></h2><p>The Sundials suite is built around multistep methods. These methods are more efficient than other methods when the cost of the function calculations is really high, but for less costly functions the cost of nurturing the timestep overweighs the benefits. However, the BDF method is a classic method for stiff equations and "generally works".</p><ul><li><p><code>CVODE_BDF</code> - CVode Backward Differentiation Formula (BDF) solver.</p></li><li><p><code>CVODE_Adams</code> - CVode Adams-Moulton solver.</p></li></ul><p>The Sundials algorithms all come with a 3rd order Hermite polynomial interpolation. Note that the constructors for the Sundials algorithms take two main arguments:</p><ul><li><p><code>method</code> - This is the method for solving the implicit equation. For BDF this defaults to <code>:Newton</code> while for Adams this defaults to <code>:Functional</code>. These choices match the recommended pairing in the Sundials.jl manual. However, note that using the <code>:Newton</code> method may take less iterations but requires more memory than the <code>:Function</code> iteration approach.</p></li><li><p><code>linearsolver</code> - This is the linear solver which is used in the <code>:Newton</code> method.</p></li></ul><p>The choices for the linear solver are:</p><ul><li><p><code>:Dense</code> - A dense linear solver.</p></li><li><p><code>:Band</code> - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via <code>jac_upper</code> and <code>jac_lower</code>.</p></li><li><p><code>:Diagonal</code> - This method is specialized for diagonal Jacobians.</p></li><li><p><code>:BCG</code> - A Biconjugate gradient method.</p></li><li><p><code>:TFQMR</code> - A TFQMR method.</p></li></ul><p>Example:</p><pre><code class="language-julia">CVODE_BDF() # BDF method using Newton + Dense solver
CVODE_BDF(method=:Functional) # BDF method using Functional iterations
CVODE_BDF(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
CVODE_BDF(linear_solver=:BCG) # Biconjugate gradient method                                   </code></pre><p>All of the additional options are available. The full constructor is:</p><pre><code class="language-julia">CVODE_BDF(;method=:Newton,linear_solver=:Dense,
          jac_upper=0,jac_lower=0,non_zero=0,krylov_dim=0,
          stability_limit_detect=false,
          max_hnil_warns = 10,
          max_order = 5,
          max_error_test_failures = 7,
          max_nonlinear_iters = 3,
          max_convergence_failures = 10)

CVODE_Adams(;method=:Functional,linear_solver=:None,
            jac_upper=0,jac_lower=0,krylov_dim=0,
            stability_limit_detect=false,
            max_hnil_warns = 10,
            max_order = 12,
            max_error_test_failures = 7,
            max_nonlinear_iters = 3,
            max_convergence_failures = 10)</code></pre><p>See <a href="https://computation.llnl.gov/sites/default/files/public/cv_guide.pdf">the Sundials manual</a> for details on the additional options.</p><h2><a class="nav-anchor" href="#ODE.jl-1" id="ODE.jl-1">ODE.jl</a></h2><ul><li><p><code>ode23</code> - Bogacki-Shampine's order 2/3 Runge-Kutta  method</p></li><li><p><code>ode45</code> - A Dormand-Prince order 4/5 Runge-Kutta method</p></li><li><p><code>ode23s</code> - A modified Rosenbrock order 2/3 method due to Shampine</p></li><li><p><code>ode78</code> - A Fehlburg order 7/8 Runge-Kutta method</p></li><li><p><code>ode4</code> - The classic Runge-Kutta order 4 method</p></li><li><p><code>ode4ms</code> - A fixed-step, fixed order Adams-Bashforth-Moulton methodâ </p></li><li><p><code>ode4s</code> - A 4th order Rosenbrock method due to Shampine</p></li></ul><p>â : Does not step to the interval endpoint. This can cause issues with discontinuity detection, and <a href="features/diffeq_arrays.html">discrete variables need to be updated appropriately</a>.</p><h2><a class="nav-anchor" href="#ODEInterface.jl-1" id="ODEInterface.jl-1">ODEInterface.jl</a></h2><p>The ODEInterface algorithms are the classic Hairer Fortran algorithms. While the non-stiff algorithms are superseded by the more featured and higher performance Julia implementations from OrdinaryDiffEq.jl, the stiff solvers such as <code>radau</code> are some of the most efficient methods available (but are restricted for use on arrays of Float64).</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use ODEInterfaceDiffEq.jl:</p><pre><code class="language-julia">Pkg.add("ODEInterfaceDiffEq")
using ODEInterfaceDiffEq</code></pre><ul><li><p><code>dopri5</code> - Hairer's classic implementation of the Dormand-Prince 4/5 method.</p></li><li><p><code>dop853</code> - Explicit Runge-Kutta 8(5,3) by Dormand-Prince.</p></li><li><p><code>odex</code> - GBS extrapolation-algorithm based on the midpoint rule.</p></li><li><p><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</p></li><li><p><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</p></li><li><p><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</p></li><li><p><code>rodas</code> - Rosenbrock 4(3) method.</p></li></ul><h2><a class="nav-anchor" href="#LSODA.jl-1" id="LSODA.jl-1">LSODA.jl</a></h2><p>This setup provides a wrapper to the algorithm LSODA, a well-known method which uses switching to solve both stiff and non-stiff equations.</p><ul><li><p><code>lsoda</code> - The LSODA wrapper algorithm.</p></li></ul><p>Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use LSODA.jl:</p><pre><code class="language-julia">Pkg.add("LSODA")
using LSODA</code></pre><h2><a class="nav-anchor" href="#List-of-Supplied-Tableaus-1" id="List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></h2><p>A large variety of tableaus have been supplied by default via DiffEqDevTools.jl. The list of tableaus can be found in <a href="https://juliadiffeq.github.io/DiffEqDevDocs.jl/latest/internals/tableaus.html">the developer docs</a>. For the most useful and common algorithms, a hand-optimized version is supplied in OrdinaryDiffEq.jl which is recommended for general uses (i.e. use <code>DP5</code> instead of <code>ExplicitRK</code> with <code>tableau=constructDormandPrince()</code>). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exists). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the <a href="https://github.com/JuliaDiffEq/DiffEqDevTools.jl/blob/master/src/ode_tableaus.jl">premade tableau source code</a>. Tableau docstrings should have appropriate citations (if not, file an issue).</p><p>Plot recipes are provided which will plot the stability region for a given tableau.</p><footer><hr/><a class="previous" href="discrete_solve.html"><span class="direction">Previous</span><span class="title">Discrete Solvers</span></a><a class="next" href="refined_ode_solve.html"><span class="direction">Next</span><span class="title">Refined ODE Solvers</span></a></footer></article></body></HTML>