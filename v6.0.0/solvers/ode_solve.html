<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>ODE Solvers Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/solvers/ode_solve/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/problem.html">Problem interface</a></li><li><a class="toctext" href="../basics/faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="discrete_solve.html">Discrete Solvers</a></li><li class="current"><a class="toctext" href="ode_solve.html">ODE Solvers</a><ul class="internal"><li><a class="toctext" href="#Recommended-Methods-1">Recommended Methods</a></li><li><a class="toctext" href="#Translations-from-MATLAB/Python/R-1">Translations from MATLAB/Python/R</a></li><li><a class="toctext" href="#Full-List-of-Methods-1">Full List of Methods</a></li></ul></li><li><a class="toctext" href="dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation and Bayesian Analysis</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="toctext" href="../analysis/global_sensitivity.html">Global Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/neural_networks.html">Neural Networks</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Solver Algorithms</li><li><a href="ode_solve.html">ODE Solvers</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/solvers/ode_solve.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ODE Solvers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#ODE-Solvers-1" id="ODE-Solvers-1">ODE Solvers</a></h1><p><code>solve(prob::ODEProblem,alg;kwargs)</code></p><p>Solves the ODE defined by <code>prob</code> using the algorithm <code>alg</code>. If no algorithm is given, a default algorithm will be chosen.</p><h2><a class="nav-anchor" href="#Recommended-Methods-1" id="Recommended-Methods-1">Recommended Methods</a></h2><p>It is suggested that you try choosing an algorithm using the <code>alg_hints</code> keyword argument. However, in some cases you may want something specific, or you may just be curious. This guide is to help you choose the right algorithm.</p><h3><a class="nav-anchor" href="#Unknown-Stiffness-Problems-1" id="Unknown-Stiffness-Problems-1">Unknown Stiffness Problems</a></h3><p>When the stiffness of the problem is unknown, it is recommended you use a stiffness detection and auto-switching algorithm. These methods are multi-paradigm and allow for efficient solution of both stiff and non-stiff problems. The cost for auto-switching is very minimal but the choices are restrained and so they are a good go-to method when applicable.</p><p>For default tolerances, <code>AutoTsit5(Rosenbrock23())</code> is a good choice. For lower tolerances, using <code>AutoVern7</code> or <code>AutoVern9</code> with <code>Rodas4</code>, <code>KenCarp4</code>, or <code>Rodas5</code> can all be good choices depending on the problem. For very large systems (<code>&gt;1000 ODEs?</code>), consider using <code>lsoda</code>.</p><h3><a class="nav-anchor" href="#Non-Stiff-Problems-1" id="Non-Stiff-Problems-1">Non-Stiff Problems</a></h3><p>For non-stiff problems, the native OrdinaryDiffEq.jl algorithms are vastly more efficient than the other choices. For most non-stiff problems, we recommend <code>Tsit5</code>. When more robust error control is required, <code>BS5</code> is a good choice. If at moderate tolerances an the interpolation error is very important, consider the <code>OwrenZen5</code> method. For fast solving at higher tolerances, we recommend <code>BS3</code> (or <code>OwrenZen3</code> if the interpolation error is important). For high accuracy but with the range of <code>Float64</code> (<code>~1e-8-1e-12</code>), we recommend <code>Vern6</code>, <code>Vern7</code>, or <code>Vern8</code> as efficient choices.</p><p>For high accuracy non-stiff solving (<code>BigFloat</code> and tolerances like <code>&lt;1e-12</code>), we recommend the <code>Vern9</code> method. If a high-order method is needed with a high order interpolant, then you should choose <code>Vern9</code> which is Order 9 with an Order 9 interpolant. If you need extremely high accuracy (<code>&lt;1e-30</code>?) and do not need an interpolant, try the <code>Feagin12</code> or <code>Feagin14</code> methods. Note that the Feagin methods are the only high-order optimized methods which do not include a high-order interpolant (they do include a 3rd order Hermite interpolation if needed). Note that these high order RK methods are more robust than the high order Adams-Bashforth methods to discontinuities and achieve very high precision, and are much more efficient than the extrapolation methods. However, the <code>VCABM</code> method can be a good choice for high accuracy when the system of equations is very large (<code>&gt;1,000</code> ODEs?), the function calculation is very expensive, or the solution is very smooth.</p><p>If strict error bounds are needed, then adaptive methods with defect controls are required. Defect controls use an error measurement on the interpolating polynomial to make the error estimate better capture the error over the full interval. For medium accuracy calculations, <code>RK4</code> is a good choice.</p><h3><a class="nav-anchor" href="#Stiff-Problems-1" id="Stiff-Problems-1">Stiff Problems</a></h3><p>For stiff problems at high tolerances (<code>&gt;1e-2</code>?) it is recommended that you use <code>Rosenbrock23</code> or <code>TRBDF2</code>. These are robust to oscillations and massive stiffness is needed, though are only efficient when low accuracy is needed. <code>Rosenbrock23</code> is more efficient for small systems where re-evaluating and re-factorizing the Jacobian is not too costly, and for sufficiently large systems <code>TRBDF2</code> will be more efficient. <code>ABDF2</code> can be the most efficient the largest systems or most expensive <code>f</code>.</p><p>At medium tolerances (<code>&gt;1e-8</code>?) it is recommended you use <code>Rodas5</code>, <code>Rodas4P</code> (the former is more efficient but the later is more reliable), <code>Kvaerno5</code>, or <code>KenCarp4</code>. As native DifferentialEquations.jl solvers, many Julia numeric types (such as BigFloats, <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">ArbFloats</a>, or <a href="https://github.com/stevengj/DecFP.jl">DecFP</a>) will work. When the equation is defined via the <code>@ode_def</code> macro, these will be the most efficient.</p><p>For faster solving at low tolerances (<code>&lt;1e-9</code>) but when <code>Vector{Float64}</code> is used, use <code>radau</code>.</p><p>For asymptotically large systems of ODEs (<code>N&gt;1000</code>?) where <code>f</code> is very costly and the complex eigenvalues are minimal (low oscillations), in that case <code>CVODE_BDF</code> will be the most efficient but requires <code>Vector{Float64}</code>. <code>CVODE_BDF</code> will also do surprisingly well if the solution is smooth. However, this method can be less stiff than other methods and stuff may fail at low accuracy situations. Another good choice for this regime is <code>lsoda</code>.</p><h4><a class="nav-anchor" href="#Special-Properties-of-Stiff-Integrators-1" id="Special-Properties-of-Stiff-Integrators-1">Special Properties of Stiff Integrators</a></h4><p><code>ImplicitMidpoint</code> is a symmetric and symplectic integrator. <code>Trapezoid</code> is a symmetric (almost symplectic) integrator with adaptive timestepping. <code>ImplicitEuler</code> is an extension to the common algorithm with adaptive timestepping and efficient quasi-Newton Jacobian re-usage which is fully strong-stability presurving (SSP) for hyperbolic PDEs.</p><p>Notice that <code>Rodas4</code> loses accuracy on discretizations of nonlinear parabolic PDEs, and thus it's suggested you replace it with <code>Rodas4P</code> in those situations which is 3rd order. <code>ROS3P</code> is only third order and achieves 3rd order on such problems and can thus be more efficient in this case.</p><h2><a class="nav-anchor" href="#Translations-from-MATLAB/Python/R-1" id="Translations-from-MATLAB/Python/R-1">Translations from MATLAB/Python/R</a></h2><p>For users familiar with MATLAB/Python/R, good translations of the standard library methods are as follows:</p><ul><li><code>ode23</code> â&gt; <code>BS3()</code></li><li><code>ode45</code>/<code>dopri5</code> â&gt; <code>DP5()</code>, though in most cases <code>Tsit5()</code> is more efficient</li><li><code>ode23s</code> â&gt; <code>Rosenbrock23()</code>, though in most cases <code>Rodas4()</code> is more efficient</li><li><code>ode113</code> â&gt; <code>VCABM()</code>, though in many cases <code>Vern7()</code> is more efficient</li><li><code>dop853</code> â&gt; <code>DP8()</code>, though in most cases <code>Vern7()</code> is more efficient</li><li><code>ode15s</code>/<code>vode</code> â&gt; <code>QNDF()</code>, though in many cases <code>CVODE_BDF()</code>, <code>Rodas4()</code> or <code>radau()</code> are more efficient</li><li><code>ode23t</code> â&gt; <code>Trapezoid()</code> for efficiency and <code>GenericTrapezoid()</code> for robustness</li><li><code>ode23tb</code> â&gt; <code>TRBDF2</code></li><li><code>lsoda</code> â&gt; <code>lsoda()</code> (requires <code>]add LSODA; using LSODA</code>)</li><li><code>ode15i</code> â&gt; <code>IDA()</code>, though in many cases <code>Rodas4()</code> can handle the DAE and is significantly more efficient</li></ul><h2><a class="nav-anchor" href="#Full-List-of-Methods-1" id="Full-List-of-Methods-1">Full List of Methods</a></h2><h3><a class="nav-anchor" href="#OrdinaryDiffEq.jl-1" id="OrdinaryDiffEq.jl-1">OrdinaryDiffEq.jl</a></h3><p>Unless otherwise specified, the OrdinaryDiffEq algorithms all come with a 3rd order Hermite polynomial interpolation. The algorithms denoted as having a "free" interpolation means that no extra steps are required for the interpolation. For the non-free higher order interpolating functions, the extra steps are computed lazily (i.e. not during the solve).</p><p>The OrdinaryDiffEq.jl algorithms achieve the highest performance for non-stiff equations while being the most generic: accepting the most Julia-based types, allow for sophisticated event handling, etc. On stiff ODEs these algorithms again consistently among the top. OrdinaryDiffEq.jl is recommended for most ODE problems.</p><h4><a class="nav-anchor" href="#Runge-Kutta-Methods-for-Non-Stiff-Equations-1" id="Runge-Kutta-Methods-for-Non-Stiff-Equations-1">Runge-Kutta Methods for Non-Stiff Equations</a></h4><ul><li><code>Euler</code>- The canonical forward Euler method. Fixed timestep only.</li><li><code>Midpoint</code> - The second order midpoint method. Uses embedded Euler method for adaptivity.</li><li><code>Heun</code> - The second order Heun's method. Uses embedded Euler method for adaptivity.</li><li><code>Ralston</code> - The optimized second order midpoint method. Uses embedded Euler. method for adaptivity.</li><li><code>RK4</code> - The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval.</li><li><code>BS3</code> - Bogacki-Shampine 3/2 method.</li><li><code>OwrenZen3</code> - Owren-Zennaro optimized interpolantion 3/2 method (free 3th order interpolant).</li><li><code>OwrenZen4</code> - Owren-Zennaro optimized interpolantion 4/3 method (free 4th order interpolant).</li><li><code>OwrenZen5</code> - Owren-Zennaro optimized interpolantion 5/4 method (free 5th order interpolant).</li><li><code>DP5</code> - Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant).</li><li><code>Tsit5</code> - Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant).</li><li><code>Anas5(w)</code> - 4th order Runge-Kutta method designed for periodic problems. Requires a periodicity estimate <code>w</code> which when accurate the method becomes 5th order (and is otherwise 4th order with less error for better estimates).</li><li><code>TanYam7</code> - Tanaka-Yamashita 7 Runge-Kutta method.</li><li><code>DP8</code> - Hairer's 8/5/3 adaption of the Dormand-Prince Runge-Kutta method. (7th order interpolant).</li><li><code>TsitPap8</code> - Tsitouras-Papakostas 8/7 Runge-Kutta method.</li><li><code>Feagin10</code> - Feagin's 10th-order Runge-Kutta method.</li><li><code>Feagin12</code> - Feagin's 12th-order Runge-Kutta method.</li><li><code>Feagin14</code> - Feagin's 14th-order Runge-Kutta method.</li></ul><p>Example usage:</p><pre><code class="language-julia">alg = Tsit5()
solve(prob,alg)  </code></pre><p>Additionally, the following algorithms have a lazy interpolant:</p><ul><li><code>BS5</code> - Bogacki-Shampine 5/4 Runge-Kutta method. (lazy 5th order interpolant).</li><li><code>Vern6</code> - Verner's "Most Efficient" 6/5 Runge-Kutta method. (lazy 6th order interpolant).</li><li><code>Vern7</code> - Verner's "Most Efficient" 7/6 Runge-Kutta method. (lazy 7th order interpolant).</li><li><code>Vern8</code> - Verner's "Most Efficient" 8/7 Runge-Kutta method. (lazy 8th order interpolant)</li><li><code>Vern9</code> - Verner's "Most Efficient" 9/8 Runge-Kutta method. (lazy 9th order interpolant)</li></ul><p>These methods require a few extra steps in order to compute the high order interpolation, but these steps are only taken when the interpolation is used. These methods when lazy assume that the parameter vector <code>p</code> will be unchanged between the moment of the interval solving and the interpolation. If <code>p</code> is changed in a ContinuousCallback, or in a DiscreteCallback and the continuous solution is used after the full solution, then set <code>lazy=false</code>.</p><p>Example:</p><pre><code class="language-julia">solve(prob,Vern7()) # lazy by default
solve(prob,Vern7(lazy=false))</code></pre><h4><a class="nav-anchor" href="#Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1" id="Explicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1">Explicit Strong-Stability Preserving Runge-Kutta Methods for Hyperbolic PDEs (Conservation Laws)</a></h4><ul><li><code>SSPRK22</code> - The two-stage, second order strong stability preserving (SSP) method of Shu and Osher (SSP coefficient 1, free 2nd order SSP interpolant). Fixed timestep only.</li><li><code>SSPRK33</code> - The three-stage, third order strong stability preserving (SSP) method of Shu and Osher (SSP coefficient 1, free 2nd order SSP interpolant). Fixed timestep only.</li><li><code>SSPRK53</code> - The five-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 2.65, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK63</code> - The six-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 3.518, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK73</code> - The seven-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 4.2879, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK83</code> - The eight-stage, third order strong stability preserving (SSP) method of Ruuth (SSP coefficient 5.107, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK432</code> - A  3/2 adaptive strong stability preserving (SSP) method with five stages (SSP coefficient 2, free 2nd order SSP interpolant).</li><li><code>SSPRK932</code> - A  3/2 adaptive strong stability preserving (SSP) method with nine stages (SSP coefficient 6, free 3rd order Hermite interpolant).</li><li><code>SSPRK54</code> - The five-stage, fourth order strong stability preserving (SSP) method of Spiteri and Ruuth (SSP coefficient 1.508, 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRK104</code> - The ten-stage, fourth order strong stability preserving method of Ketcheson (SSP coefficient 6, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRKMSVS32</code> - 3-stage, 2nd order SSP-optimal linear multistep method. (SSP coefficent 0.5, 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>SSPRKMSVS43</code> - 4-stage, 3rd order SSP-optimal linear multistep method. (SSP coefficent 0.33, 3rd order Hermite interpolant). Fixed timestep only.</li></ul><p>The SSP coefficients of the methods can be queried as <code>ssp_coefficient(alg)</code>. All explicit SSP methods take two optional arguments <code>SSPXY(stage_limiter!, step_limiter!)</code>, where <code>stage_limiter!</code> and <code>step_limiter</code> are functions taking arguments of the form <code>limiter!(u, f, t)</code>. Here, <code>u</code> is the new solution value (updated inplace) after an explicit Euler stage / the whole time step , <code>f</code> the time derivative function (semidiscretisation for PDEs), and <code>t</code> the current time. These limiters can be used to enforce physical constraints, e.g. the positivity preserving limiters of Zhang and Shu (Zhang, Xiangxiong, and Chi-Wang Shu. "Maximum-principle-satisfying and positivity-preserving high-order schemes for conservation laws: survey and new developments." Proceedings of the Royal Society of London A: Mathematical, Physical and Engineering Sciences. The Royal Society, 2011.).</p><h4><a class="nav-anchor" href="#Low-Storage-Methods-1" id="Low-Storage-Methods-1">Low-Storage Methods</a></h4><ul><li><code>ORK256</code> - 5-stage, second order low-storage method for wave propogation equations. Fixed timestep only.</li><li><code>SSPRK53_2N1</code> and <code>SSPRK53_2N2</code> - 5-stage, third order low-storage methods with large SSP coefficients. (SSP coefficient 2.18 and 2.15, free 3rd order Hermite interpolant). Fixed timestep only.</li><li><code>CarpenterKennedy2N54</code> - The five-stage, fourth order low-storage method of Carpenter and Kennedy (free 3rd order Hermite interpolant). Fixed timestep only. Designed for hyperbolic PDEs (stability properties).</li><li><code>NDBLSRK144</code> - 14-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.</li><li><code>NDBLSRK144</code> - 12-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.</li><li><code>CFRLDDRK64</code> - 6-stage, fourth order low-storage, low-dissipation, low-dispersion scheme. Fixed timestep only.</li><li><code>RK46NL</code> - 6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.</li></ul><h4><a class="nav-anchor" href="#Explicit-Multistep-Methods-1" id="Explicit-Multistep-Methods-1">Explicit Multistep Methods</a></h4><p>Methods using the approximation at more than one previous mesh point to determine the approximation at the next point are called multistep methods. These methods tend to be more efficient as the size of the system or the cost of <code>f</code> increases.</p><h5><a class="nav-anchor" href="#Adams-Bashforth-Explicit-Methods-1" id="Adams-Bashforth-Explicit-Methods-1">Adams-Bashforth Explicit Methods</a></h5><p>These methods require a choice of <code>dt</code>.</p><ul><li><code>AB3</code> - The 3-step third order multistep method. Ralston's Second Order Method is used to calculate starting values.</li><li><code>AB4</code> - The 4-step fourth order multistep method. Runge-Kutta method of order 4 is used to calculate starting values.  </li><li><code>AB5</code> - The 5-step fifth order multistep method. Runge-Kutta method of order 4 is used to calculate starting values.  </li><li><code>ABM32</code> - It is third order method. In <code>ABM32</code>, <code>AB3</code> works as predictor and Adams Moulton 2-steps method works as Corrector. Ralston's Second Order Method is used to calculate starting values.  </li><li><code>ABM43</code> - It is fourth order method. In <code>ABM43</code>, <code>AB4</code> works as predictor and Adams Moulton 3-steps method works as Corrector. Runge-Kutta method of order 4 is used to calculate starting values.  </li><li><code>ABM54</code> - It is fifth order method. In <code>ABM54</code>, <code>AB5</code> works as predictor and Adams Moulton 4-steps method works as Corrector. Runge-Kutta method of order 4 is used to calculate starting values.</li></ul><h5><a class="nav-anchor" href="#Adaptive-step-size-Adams-explicit-Methods-1" id="Adaptive-step-size-Adams-explicit-Methods-1">Adaptive step size Adams explicit Methods</a></h5><ul><li><code>VCAB3</code> - The 3rd order Adams method. Bogacki-Shampine 3/2 method is used to calculate starting values.  </li><li><code>VCAB4</code> - The 4th order Adams method. Runge-Kutta 4 is used to calculate starting values.  </li><li><code>VCAB5</code> - The 5th order Adams method. Runge-Kutta 4 is used to calculate starting values.</li><li><code>VCABM3</code> - The 3rd order Adams-Moulton method. Bogacki-Shampine 3/2 method is used to calculate starting values.  </li><li><code>VCABM4</code> - The 4th order Adams-Moulton method. Runge-Kutta 4 is used to calculate starting values.  </li><li><code>VCABM5</code> - The 5th order Adams-Moulton method. Runge-Kutta 4 is used to calculate starting values.</li><li><code>VCABM</code> - An adaptive order adaptive time Adams Moulton method. It uses an order adaptivity algorithm is derived from Shampine's DDEABM.</li><li><code>AN5</code> - An adaptive 5th order fixed-leading coefficient Adams method in Nordsieck form.</li><li><code>JVODE_Adams</code> - An adaptive time adaptive order fixed-leading coefficient Adams method in Nordsieck form. The order adaptivity algorithm is derived from Sundials' <code>CVODE_Adams</code>. In development.</li></ul><h4><a class="nav-anchor" href="#Methods-for-Stiff-Equations-1" id="Methods-for-Stiff-Equations-1">Methods for Stiff Equations</a></h4><h5><a class="nav-anchor" href="#SDIRK-Methods-1" id="SDIRK-Methods-1">SDIRK Methods</a></h5><ul><li><code>ImplicitEuler</code> - A 1st order implicit solver. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory. Strong-stability preserving (SSP).</li><li><code>ImplicitMidpoint</code> - A second order A-stable symplectic and symmetric implicit solver. Good for highly stiff equations which need symplectic integration.</li><li><code>Trapezoid</code> - A second order A-L-stable symmetric ESDIRK method. "Almost symplectic" without numerical dampening. Also known as Crank-Nicholson when applied to PDEs. Adaptive timestepping via divided differences on the memory. Good for highly stiff equations which are non-oscillatory.</li><li><code>TRBDF2</code> - A second order A-B-L-S-stable one-step ESDIRK method. Includes stiffness-robust error estimates for accurate adaptive timestepping, smoothed derivatives for highly stiff and oscillatory problems.</li><li><code>GenericImplicitEuler</code> - A 1st order A-B-L-stable implicit solver with adaptive timestepping through a divided differences estimate via memory. Strong-stability preserving (SSP). Uses an external nonlinear solver. Defaults to trust region dogleg with full Newton, making it more robust to numerical instability at the cost of being less efficient.</li><li><code>GenericTrapezoid</code> - A second order A-stable symplectic implicit solver. Also known as Crank-Nicholson when applied to PDEs. Adaptive timestepping via divided differences on the memory. Good for highly stiff equations which are non-oscillatory. Uses an external nonlinear solver. Defaults to trust region dogleg with full Newton, making it more robust to numerical instability at the cost of being less efficient.</li><li><code>SDIRK2</code> - An A-B-L stable 2nd order SDIRK method</li><li><code>Kvaerno3</code> - An A-L stable stiffly-accurate 3rd order ESDIRK method</li><li><code>KenCarp3</code> - An A-L stable stiffly-accurate 3rd order ESDIRK method with splitting</li><li><code>Cash4</code> - An A-L stable 4th order SDIRK method</li><li><code>Hairer4</code> - An A-L stable 4rd order SDIRK method</li><li><code>Hairer42</code> - An A-L stable 4rd order SDIRK method</li><li><code>Kvaerno4</code> - An A-L stable stiffly-accurate 4rd order ESDIRK method</li><li><code>KenCarp4</code> - An A-L stable stiffly-accurate 4rd order ESDIRK method with splitting</li><li><code>Kvaerno5</code> - An A-L stable stiffly-accurate 5rd order ESDIRK method</li><li><code>KenCarp5</code> - An A-L stable stiffly-accurate 5rd order ESDIRK method with splitting</li></ul><h5><a class="nav-anchor" href="#Fully-Implicit-Runge-Kutta-Methods-(FIRK)-1" id="Fully-Implicit-Runge-Kutta-Methods-(FIRK)-1">Fully-Implicit Runge-Kutta Methods (FIRK)</a></h5><ul><li><code>Radau5</code> - An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.</li></ul><h5><a class="nav-anchor" href="#Rosenbrock-Methods-1" id="Rosenbrock-Methods-1">Rosenbrock Methods</a></h5><ul><li><code>Rosenbrock23</code> - An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</li><li><code>Rosenbrock32</code> - An Order 3/2 A-Stable Rosenbrock-W method which is good for mildy stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</li><li><code>ROS3P</code> - 3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</li><li><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</li><li><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</li><li><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</li><li><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</li><li><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</li><li><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially "anti-L-stable" but efficient.</li><li><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</li><li><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</li><li><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method. Currently has a Hermite interpolant because its stiff-aware 3rd order interpolant is not yet implemented.</li></ul><h5><a class="nav-anchor" href="#Stabilized-Explicit-Methods-1" id="Stabilized-Explicit-Methods-1">Stabilized Explicit Methods</a></h5><ul><li><code>ROCK2</code> - Second order stabilized Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li><li><code>ROCK4</code> - Fourth order stabilized Runge-Kutta method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.</li></ul><h5><a class="nav-anchor" href="#Exponential-Methods-for-Linear-and-Affine-Problems-1" id="Exponential-Methods-for-Linear-and-Affine-Problems-1">Exponential Methods for Linear and Affine Problems</a></h5><ul><li><code>LinearExponential</code> - Exact solution formula for linear, time-independent problems. Expects the right hand side function to be a <a href="features/diffeq_operator.html"><code>AbstractDiffEqOperator</code></a>.</li></ul><p>Options:</p><ul><li><code>krylov</code> - symbol. One of<ul><li>:off (default) - cache the operator beforehand. Requires <code>Matrix(A)</code> method defined for the operator <code>A</code>.</li><li>:simple - uses simple Krylov approximations with fixed subspace size <code>m</code>.</li><li>:adaptive - uses adaptive Krylov approximations with internal timestepping.</li></ul></li><li><code>m</code> - integer, default: <code>30</code>. Controls the size of Krylov subsapce if <code>krylov=:simple</code>, and the initial subspace size if <code>krylov=:adaptive</code>.</li><li><code>iop</code> - integer, default: <code>0</code>. If not zero, determines the length of the incomplete orthogonalization procedure (IOP) <a href="#footnote-1">[1]</a>. Note that if the linear operator/jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.</li></ul><h5><a class="nav-anchor" href="#Exponential-Runge-Kutta-Methods-1" id="Exponential-Runge-Kutta-Methods-1">Exponential Runge-Kutta Methods</a></h5><p>These methods are all fixed timestepping only.</p><ul><li><code>LawsonEuler</code> - First order exponential Euler scheme.</li><li><code>NorsettEuler</code> - First order exponential-RK scheme. Alias: <code>ETD1</code>.</li><li><code>ETD2</code> - Second order Exponential Time Differencing method (in development).</li><li><code>ETDRK2</code> - 2nd order exponential-RK scheme.</li><li><code>ETDRK3</code> - 3rd order exponential-RK scheme.</li><li><code>ETDRK4</code> - 4th order exponential-RK scheme.</li><li><code>HochOst4</code> - 4th order exponential-RK scheme with stiff order 4.</li></ul><p>The methods are intended for semilinear problems constructed by <a href="../types/split_ode_types.html"><code>SplitODEProblem</code></a> or <code>SplitODEFunction</code>. They can also be used for a general nonlinear problem, in which case the jacobian of the right hand side is used as the linear operator in each time step.</p><p>Except for <code>ETD2</code>, all methods come with these options, which can be set in the methods' constructor:</p><ul><li><code>krylov</code> - boolean, default: <code>false</code>. Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.</li><li><code>m</code> - integer, default: <code>30</code>. Controls the size of Krylov subsapce.</li><li><code>iop</code> - integer, default: <code>0</code>. If not zero, determines the length of the incomplete orthogonalization procedure (IOP) <a href="#footnote-1">[1]</a>. Note that if the linear operator/jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.</li><li><code>autodiff</code> and <code>chunksize</code>: autodiff control if problem is not semilinear and explicit jacobian is not given. See <a href="#Extra-Options-1">Extra Options</a> for more details.</li></ul><h5><a class="nav-anchor" href="#Adaptive-Exponential-Rosenbrock-Methods-1" id="Adaptive-Exponential-Rosenbrock-Methods-1">Adaptive Exponential Rosenbrock Methods</a></h5><ul><li><code>Exprb32</code> - 3rd order adaptive Exponential-Rosenbrock scheme.</li><li><code>Exprb43</code> - 4th order adaptive Exponential-Rosenbrock scheme.</li></ul><p>The exponential rosenbrock methods cannot be applied to semilinear problems. Options for the solvers are the same as <a href="#Exponential-Runge-Kutta-Methods-1">Exponential Runge-Kutta Methods</a> except that Krylov approximation is always used.</p><h5><a class="nav-anchor" href="#Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)-1" id="Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)-1">Exponential Propagation Iterative Runge-Kutta Methods (EPIRK)</a></h5><p>These methods are all fixed timestepping only.</p><ul><li><code>Exp4</code> - 4th order EPIRK scheme.</li><li><code>EPIRK4s3A</code> - 4th order EPIRK scheme with stiff order 4.</li><li><code>EPIRK4s3B</code> - 4th order EPIRK scheme with stiff order 4.</li><li><code>EPIRK5P1</code> - 5th order EPIRK scheme.</li><li><code>EPIRK5P2</code> - 5th order EPIRK scheme.</li><li><code>EPIRK5s3</code> - 5th order "horizontal" EPIRK scheme with stiff order 5. Broken.</li><li><code>EXPRB53s3</code>- 5th order EPIRK scheme with stiff order 5.</li></ul><p>Options:</p><ul><li><code>adaptive_krylov</code> - boolean, default: <code>true</code>. Determines if the adaptive Krylov algorithm with timestepping of Neisen &amp; Wright is used.</li><li><code>m</code> - integer, default: <code>30</code>. Controls the size of Krylov subsapce, or the size for the first step if <code>adaptive_krylov=true</code>.</li><li><code>iop</code> - integer, default: <code>0</code>. If not zero, determines the length of the incomplete orthogonalization procedure (IOP) <a href="#footnote-1">[1]</a>. Note that if the linear operator/jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.</li><li><code>autodiff</code> and <code>chunksize</code>: autodiff control if problem is not semilinear and explicit jacobian is not given. See <a href="#Extra-Options-1">Extra Options</a> for more details.</li></ul><p>It should be noted that many of the methods are still at an experimental stage of development, and thus should be used with caution.</p><h5><a class="nav-anchor" href="#Multistep-Methods-1" id="Multistep-Methods-1">Multistep Methods</a></h5><p>Quasi-constant stepping is the time stepping strategy which matches the classic GEAR, LSODE,  and <code>ode15s</code> integrators. The variable-coefficient methods match the ideas of the classic EPISODE integrator and early VODE designs. The Fixed Leading Coefficient (FLC) methods match the behavior of the classic VODE and Sundials CVODE integrator.</p><ul><li><code>QNDF1</code> - An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter <code>kappa</code> defaults to Shampine's accuracy-optimal <code>-0.1850</code>.</li><li><code>QBDF1</code> - An adaptive order 1 L-stable BDF method. This is equivalent to implicit Euler but using the BDF error estimator.</li><li><code>ABDF2</code> - An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.</li><li><code>QNDF</code> - An adaptive order quasi-constant timestep NDF method. Utilizes Shampine's accuracy-optimal <code>kappa</code> values as defaults (has a keyword argument for a tuple of <code>kappa</code> coefficients).</li><li><code>QBDF</code> - An adaptive order quasi-constant timestep BDF method.</li><li><code>JVODE_BDF</code> - An adaptive time adaptive order fixed-leading coefficient BDF method in Nordsieck form. In development.</li><li><code>MEBDF2</code> - The second order Modified Extended BDF method, which has improved stability properties over the standard BDF. Fixed timestep only.</li></ul><h5><a class="nav-anchor" href="#Implicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1" id="Implicit-Strong-Stability-Preserving-Runge-Kutta-Methods-for-Hyperbolic-PDEs-(Conservation-Laws)-1">Implicit Strong-Stability Preserving Runge-Kutta Methods for Hyperbolic PDEs (Conservation Laws)</a></h5><ul><li><code>SSPSDIRK2</code> - A second order A-L stable symplectic SDIRK method with the strong stability preserving (SSP) property (SSP coefficient 2). Fixed timestep only.</li></ul><h5><a class="nav-anchor" href="#Extra-Options-1" id="Extra-Options-1">Extra Options</a></h5><p>All of the Rosenbrock and SDIRK methods allow for specification of <code>linsolve</code>: the linear solver which is used. For more information on specifying the linear solver, see <a href="features/linear_nonlinear.html">the manual page on solver specification</a>.</p><p>The following methods allow for specification of <code>nlsolve</code>: the nonlinear solver which is used:</p><ul><li><code>GenericImplicitEuler</code></li><li><code>GenericTrapezoid</code></li></ul><p>Note that performance overload information (Jacobians etc.) are not used in this mode. This can control autodifferentiation of the Jacobian as well. For more information on specifying the nonlinear solver, see <a href="features/linear_nonlinear.html">the manual page on solver specification</a>.</p><p>Additionally, the Rosenbrock and SDIRK methods have differentiation controls. In each of these, <code>autodiff</code> can be set to turn on/off autodifferentiation, and <code>chunk_size</code> can be used to set the chunksize of the Dual  numbers (see the <a href="http://www.juliadiff.org/ForwardDiff.jl/advanced_usage.html#configuring-chunk-size">documentation for ForwardDiff.jl for details</a>). In addition, the Rosenbrock and SDIRK methods can set <code>diff_type</code>, which is the type of numerical differentiation that is used (when autodifferentiation is disabled). The choices are <code>Val{:central}</code>, <code>Val{:forward}</code> or <code>Val{:complex}</code>.</p><p>Examples:</p><pre><code class="language-julia">sol = solve(prob,Rosenbrock23()) # Standard, uses autodiff
sol = solve(prob,Rosenbrock23(chunk_size=10)) # Autodiff with chunksize of 10
sol = solve(prob,Rosenbrock23(autodiff=false)) # Numerical differentiation with central differencing
sol = solve(prob,Rosenbrock23(autodiff=false,diff_type=Val{:forward})) # Numerical differentiation with forward differencing</code></pre><h4><a class="nav-anchor" href="#Tableau-Method-1" id="Tableau-Method-1">Tableau Method</a></h4><p>Additionally, there is the tableau method:</p><ul><li><code>ExplicitRK</code> - A general Runge-Kutta solver which takes in a tableau. Can be adaptive. Tableaus are specified via the keyword argument <code>tab=tableau</code>. The default tableau is for Dormand-Prince 4/5. Other supplied tableaus can be found in the Supplied Tableaus section.</li></ul><p>Example usage:</p><pre><code class="language-julia">alg = ExplicitRK(tableau=constructDormandPrince())
solve(prob,alg)</code></pre><h4><a class="nav-anchor" href="#CompositeAlgorithm-1" id="CompositeAlgorithm-1">CompositeAlgorithm</a></h4><p>One unique feature of OrdinaryDiffEq.jl is the <code>CompositeAlgorithm</code>, which allows you to, with very minimal overhead, design a multimethod which switches between chosen algorithms as needed. The syntax is <code>CompositeAlgorithm(algtup,choice_function)</code> where <code>algtup</code> is a tuple of OrdinaryDiffEq.jl algorithms, and <code>choice_function</code> is a function which declares which method to use in the following step. For example, we can design a multimethod which uses <code>Tsit5()</code> but switches to <code>Vern7()</code> whenever <code>dt</code> is too small:</p><pre><code class="language-julia">choice_function(integrator) = (Int(integrator.dt&lt;0.001) + 1)
alg_switch = CompositeAlgorithm((Tsit5(),Vern7()),choice_function)</code></pre><p>The <code>choice_function</code> takes in an <code>integrator</code> and thus all of the features available in the <a href="../basics/integrator.html#Integrator-Interface-1">Integrator Interface</a> can be used in the choice function.</p><p>A helper algorithm was created for building 2-method automatic switching for stiffness detection algorithms. This is the <code>AutoSwitch</code> algorithm with the following options:</p><pre><code class="language-julia">AutoSwitch(nonstiffalg::nAlg, stiffalg::sAlg;
           maxstiffstep=10, maxnonstiffstep=3,
           nonstifftol::T=9//10, stifftol::T=9//10,
           dtfac=2.0, stiffalgfirst=false)</code></pre><p>The <code>nonstiffalg</code> must have an appropriate stiffness estimate built into the method. The <code>stiffalg</code> can receive its estimate from the Jacobian calculation. <code>maxstiffstep</code> is the number of stiffness detects before switching to the stiff algorithm and <code>maxnonstiffstep</code> is vice versa. <code>nonstifftol</code> and <code>stifftol</code> are the tolerances associated with the stiffness comparison against the stability region. <code>dtfac</code> is the factor that <code>dt</code> is changed when switching: multiplied when going from non-stiff to stiff and divided when going stiff to non-stiff. <code>stiffalgfirst</code> denotes whether the first step should use the stiff algorithm.</p><h5><a class="nav-anchor" href="#Pre-Built-Stiffness-Detecting-and-Auto-Switching-Algorithms-1" id="Pre-Built-Stiffness-Detecting-and-Auto-Switching-Algorithms-1">Pre-Built Stiffness Detecting and Auto-Switching Algorithms</a></h5><p>These methods require a <code>Autoalg(stiffalg)</code> to be chosen as the method to switch to when the ODE is stiff. It can be any of the OrdinaryDiffEq.jl one-step stiff methods and has all of the arguments of the <code>AutoSwitch</code> algorithm.</p><ul><li><code>AutoTsit5</code> - <code>Tsit5</code> with automated switching.</li><li><code>AutoDP5</code> - <code>DP5</code> with automated switching.</li><li><code>AutoVern6</code> - <code>Vern6</code> with automated switching.</li><li><code>AutoVern7</code> - <code>Vern7</code> with automated switching.</li><li><code>AutoVern8</code> - <code>Vern8</code> with automated switching.</li><li><code>AutoVern9</code> - <code>Vern9</code> with automated switching.</li></ul><p>Example:</p><pre><code class="language-julia">tsidas_alg = AutoTsit5(Rodas5())
sol = solve(prob,tsidas_alg)

tsidas_alg = AutoTsit5(Rodas5(),nonstifftol = 11/10)</code></pre><p>Is the <code>Tsit5</code> method with automatic switching to <code>Rodas5</code>.</p><h3><a class="nav-anchor" href="#Sundials.jl-1" id="Sundials.jl-1">Sundials.jl</a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use Sundials.jl:</p><pre><code class="language-julia">]add Sundials
using Sundials</code></pre><p>The Sundials suite is built around multistep methods. These methods are more efficient than other methods when the cost of the function calculations is really high, but for less costly functions the cost of nurturing the timestep overweighs the benefits. However, the BDF method is a classic method for stiff equations and "generally works".</p><ul><li><code>CVODE_BDF</code> - CVode Backward Differentiation Formula (BDF) solver.</li><li><code>CVODE_Adams</code> - CVode Adams-Moulton solver.</li><li><code>ARKODE</code> - Explicit and ESDIRK Runge-Kutta methods of orders 2-8 depending on choice of options.</li></ul><p>The Sundials algorithms all come with a 3rd order Hermite polynomial interpolation. Note that the constructors for the Sundials algorithms take two main arguments:</p><ul><li><code>method</code> - This is the method for solving the implicit equation. For BDF this defaults to <code>:Newton</code> while for Adams this defaults to <code>:Functional</code>. These choices match the recommended pairing in the Sundials.jl manual. However, note that using the <code>:Newton</code> method may take less iterations but requires more memory than the <code>:Function</code> iteration approach.</li><li><code>linearsolver</code> - This is the linear solver which is used in the <code>:Newton</code> method.</li></ul><p>The choices for the linear solver are:</p><ul><li><code>:Dense</code> - A dense linear solver.</li><li><code>:Band</code> - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via <code>jac_upper</code> and <code>jac_lower</code>.</li><li><code>:Diagonal</code> - This method is specialized for diagonal Jacobians.</li><li><code>:GMRES</code> - A GMRES method. Recommended first choice Krylov method</li><li><code>:BCG</code> - A Biconjugate gradient method.</li><li><code>:PCG</code> - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li><code>:TFQMR</code> - A TFQMR method.</li><li><code>:KLU</code> - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the <code>ODEProblem</code> type.</li></ul><p>Example:</p><pre><code class="language-julia">CVODE_BDF() # BDF method using Newton + Dense solver
CVODE_BDF(method=:Functional) # BDF method using Functional iterations
CVODE_BDF(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
CVODE_BDF(linear_solver=:BCG) # Biconjugate gradient method                                   </code></pre><p>The main options for <code>ARKODE</code> are the choice between explicit and implicit and the method order, given via:</p><pre><code class="language-julia">ARKODE(Sundials.Explicit()) # Solve with explicit tableau of default order 4
ARKODE(Sundials.Implicit(),order = 3) # Solve with explicit tableau of order 3</code></pre><p>The order choices for explicit are 2 through 8 and for implicit 3 through 5. Specific methods can also be set through the <code>etable</code> and <code>itable</code> options for explicit and implicit tableaus respectively. The available tableaus are:</p><p><code>etable</code>:</p><ul><li><code>HEUN_EULER_2_1_2</code>: 2nd order Heun's method</li><li><code>BOGACKI_SHAMPINE_4_2_3</code>:</li><li><code>ARK324L2SA_ERK_4_2_3</code>: explicit portion of Kennedy and Carpenter's 3rd order method</li><li><code>ZONNEVELD_5_3_4</code>: 4th order explicit method</li><li><code>ARK436L2SA_ERK_6_3_4</code>: explicit portion of Kennedy and Carpenter's 4th order method</li><li><code>SAYFY_ABURUB_6_3_4</code>: 4th order explicit method</li><li><code>CASH_KARP_6_4_5</code>: 5th order explicit method</li><li><code>FEHLBERG_6_4_5</code>: Fehlberg's classic 5th order method</li><li><code>DORMAND_PRINCE_7_4_5</code>: the classic 5th order Dormand-Prince method</li><li><code>ARK548L2SA_ERK_8_4_5</code>: explicit portion of Kennedy and Carpenter's 5th order method</li><li><code>VERNER_8_5_6</code>: Verner's classic 5th order method</li><li><code>FEHLBERG_13_7_8</code>: Fehlberg's 8th order method</li></ul><p><code>itable</code>:</p><ul><li><code>SDIRK_2_1_2</code>: An A-B-stable 2nd order SDIRK method</li><li><code>BILLINGTON_3_3_2</code>: A second order method with a 3rd order error predictor of less stability</li><li><code>TRBDF2_3_3_2</code>: The classic TR-BDF2 method</li><li><code>KVAERNO_4_2_3</code>: an L-stable 3rd order ESDIRK method</li><li><code>ARK324L2SA_DIRK_4_2_3</code>: implicit portion of Kennedy and Carpenter's 3th order method</li><li><code>CASH_5_2_4</code>: Cash's 4th order L-stable SDIRK method</li><li><code>CASH_5_3_4</code>: Cash's 2nd 4th order L-stable SDIRK method</li><li><code>SDIRK_5_3_4</code>: Hairer's 4th order SDIRK method</li><li><code>KVAERNO_5_3_4</code>: Kvaerno's 4th order ESDIRK method</li><li><code>ARK436L2SA_DIRK_6_3_4</code>: implicit portion of Kennedy and Carpenter's 4th order method</li><li><code>KVAERNO_7_4_5</code>: Kvaerno's 5th order ESDIRK method</li><li><code>ARK548L2SA_DIRK_8_4_5</code>: implicit portion of Kennedy and Carpenter's 5th order method</li></ul><p>These can be set for example via:</p><pre><code class="language-julia">ARKODE(Sundials.Explicit(),etable = Sundials.DORMAND_PRINCE_7_4_5)
ARKODE(Sundials.Implicit(),itable = Sundials.KVAERNO_4_2_3)</code></pre><p>All of the additional options are available. The full constructor is:</p><pre><code class="language-julia">CVODE_BDF(;method=:Newton,linear_solver=:Dense,
          jac_upper=0,jac_lower=0,
          stored_upper = jac_upper + jac_lower,
          non_zero=0,krylov_dim=0,
          stability_limit_detect=false,
          max_hnil_warns = 10,
          max_order = 5,
          max_error_test_failures = 7,
          max_nonlinear_iters = 3,
          max_convergence_failures = 10)

CVODE_Adams(;method=:Functional,linear_solver=:None,
            jac_upper=0,jac_lower=0,
            stored_upper = jac_upper + jac_lower,
            krylov_dim=0,
            stability_limit_detect=false,
            max_hnil_warns = 10,
            max_order = 12,
            max_error_test_failures = 7,
            max_nonlinear_iters = 3,
            max_convergence_failures = 10)

ARKODE(stiffness=Sundials.Implicit();
      method=:Newton,linear_solver=:Dense,
      jac_upper=0,jac_lower=0,stored_upper = jac_upper+jac_lower,
      non_zero=0,krylov_dim=0,
      max_hnil_warns = 10,
      max_error_test_failures = 7,
      max_nonlinear_iters = 3,
      max_convergence_failures = 10,
      predictor_method = 0,
      nonlinear_convergence_coefficient = 0.1,
      dense_order = 3,
      order = 4,
      set_optimal_params = false,
      crdown = 0.3,
      dgmax = 0.2,
      rdiv = 2.3,
      msbp = 20,
      adaptivity_method = 0
      )</code></pre><p>See <a href="https://computation.llnl.gov/sites/default/files/public/cv_guide.pdf">the CVODE manual</a> and the <a href="https://computation.llnl.gov/sites/default/files/public/ark_guide.pdf">ARKODE manual</a> for details on the additional options.</p><h3><a class="nav-anchor" href="#ODEInterface.jl-1" id="ODEInterface.jl-1">ODEInterface.jl</a></h3><p>The ODEInterface algorithms are the classic Fortran algorithms. While the non-stiff algorithms are superseded by the more featured and higher performance Julia implementations from OrdinaryDiffEq.jl, the stiff solvers such as <code>radau</code> are some of the most efficient methods available (but are restricted for use on arrays of Float64).</p><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use ODEInterfaceDiffEq.jl:</p><pre><code class="language-julia">]add ODEInterfaceDiffEq
using ODEInterfaceDiffEq</code></pre><ul><li><code>dopri5</code> - Hairer's classic implementation of the Dormand-Prince 4/5 method.</li><li><code>dop853</code> - Explicit Runge-Kutta 8(5,3) by Dormand-Prince.</li><li><code>odex</code> - GBS extrapolation-algorithm based on the midpoint rule.</li><li><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</li><li><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</li><li><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</li><li><code>rodas</code> - Rosenbrock 4(3) method.</li><li><code>ddeabm</code> - Adams-Bashforth-Moulton Predictor-Corrector method (order between 1 and 12)</li><li><code>ddebdf</code> - Backward Differentiation Formula (orders between 1 and 5)</li></ul><p>Note that while the output only has a linear interpolation, a higher order interpolation is used for intermediate dense output for <code>saveat</code> and for event handling.</p><h3><a class="nav-anchor" href="#LSODA.jl-1" id="LSODA.jl-1">LSODA.jl</a></h3><p>This setup provides a wrapper to the algorithm LSODA, a well-known method which uses switching to solve both stiff and non-stiff equations.</p><ul><li><code>lsoda</code> - The LSODA wrapper algorithm.</li></ul><p>Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use LSODA.jl:</p><pre><code class="language-julia">]add LSODA
using LSODA</code></pre><h3><a class="nav-anchor" href="#ODE.jl-1" id="ODE.jl-1">ODE.jl</a></h3><ul><li><code>ode23</code> - Bogacki-Shampine's order 2/3 Runge-Kutta  method</li><li><code>ode45</code> - A Dormand-Prince order 4/5 Runge-Kutta method</li><li><code>ode23s</code> - A modified Rosenbrock order 2/3 method due to Shampine</li><li><code>ode78</code> - A Fehlburg order 7/8 Runge-Kutta method</li><li><code>ode4</code> - The classic Runge-Kutta order 4 method</li><li><code>ode4ms</code> - A fixed-step, fixed order Adams-Bashforth-Moulton methodâ </li><li><code>ode4s</code> - A 4th order Rosenbrock method due to Shampine</li></ul><p>â : Does not step to the interval endpoint. This can cause issues with discontinuity detection, and <a href="features/diffeq_arrays.html">discrete variables need to be updated appropriately</a>.</p><h3><a class="nav-anchor" href="#MATLABDiffEq.jl-1" id="MATLABDiffEq.jl-1">MATLABDiffEq.jl</a></h3><p>These algorithms require that the problem was defined using a <code>ParameterizedFunction</code> via the <code>@ode_def</code> macro. Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use MATLABDiffEq.jl:</p><pre><code class="language-julia">Pkg.clone("https://github.com/JuliaDiffEq/MATLABDiffEq.jl")
using MATLABDiffEq</code></pre><p>This requires a licensed MATLAB installation. The available methods are:</p><ul><li><code>ode23</code></li><li><code>ode45</code></li><li><code>ode113</code></li><li><code>ode23s</code></li><li><code>ode23t</code></li><li><code>ode23tb</code></li><li><code>ode15s</code></li><li><code>ode15i</code></li></ul><p>For more information on these algorithms, see <a href="https://www.mathworks.com/help/matlab/math/choose-an-ode-solver.html">the MATLAB documentation</a>.</p><h3><a class="nav-anchor" href="#GeometricIntegrators.jl-1" id="GeometricIntegrators.jl-1">GeometricIntegrators.jl</a></h3><h5><a class="nav-anchor" href="#Note:-This-package-currently-segfaults-on-non-Linux-Julia-v1.0!-1" id="Note:-This-package-currently-segfaults-on-non-Linux-Julia-v1.0!-1">Note: This package currently segfaults on non-Linux Julia v1.0!</a></h5><p>GeometricIntegrators.jl is a set of fixed timestep algorithms written in Julia. Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use GeometricIntegratorsDiffEq.jl:</p><pre><code class="language-julia">Pkg.clone("https://github.com/JuliaDiffEq/GeometricIntegratorsDiffEq.jl")
using GeometricIntegratorsDiffEq</code></pre><ul><li><code>GIEuler</code> - 1st order Euler method</li><li><code>GIMidpoint</code> - 2nd order explicit midpoint method</li><li><code>GIHeun</code> - 2nd order Heun's method</li><li><code>GIKutta</code> - 3rd order Kutta's method</li><li><code>GIERK4</code> - standard 4th order Runge-Kutta</li><li><code>GIERK438</code> - 4th order Runge-Kutta, 3/8's rule</li><li><code>GIImplicitEuler</code> - 1st order implicit Euler method</li><li><code>GIImplicitMidpoint</code> - 2nd order implicit midpoint method</li><li><code>GIRadIIA2</code> - 2-stage order 3 Radau-IIA</li><li><code>GIRadIIA3</code> - 3-stage order 5 Radau-IIA</li><li><code>GISRK3</code> - 3-stage order 4 symmetric Runge-Kutta method</li><li><code>GIGLRK(s)</code> - Gauss-Legendre Runge-Kutta method of order 2s</li></ul><p>Note that all of these methods require the user supplies <code>dt</code>.</p><h3><a class="nav-anchor" href="#BridgeDiffEq.jl-1" id="BridgeDiffEq.jl-1">BridgeDiffEq.jl</a></h3><p>Bridge.jl is a set of fixed timestep algorithms written in Julia. These methods are made and optimized for out-of-place functions on immutable (static vector) types. Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use BridgeDiffEq.jl:</p><pre><code class="language-julia">Pkg.clone("https://github.com/JuliaDiffEq/BridgeDiffEq.jl")
using BridgeDiffEq</code></pre><ul><li><code>BridgeR3</code> - 3rd order Ralston method</li><li><code>BridgeBS3</code> - 3rd order Bogacki-Shampine method</li></ul><h3><a class="nav-anchor" href="#TaylorIntegration.jl-1" id="TaylorIntegration.jl-1">TaylorIntegration.jl</a></h3><p>TaylorIntegration.jl is a pure-Julia implementation of an adaptive order Taylor series method for high accuracy integration of ODEs. These methods are optimized when the absolute tolerance is required to be very low. Note that this setup is not automatically included with DifferentialEquaitons.jl. To use the following algorithms, you must install and use TaylorIntegration.jl:</p><pre><code class="language-julia">]add TaylorIntegration
using TaylorIntegration</code></pre><ul><li><code>TaylorMethod(order)</code> - Taylor integration method with maximal <code>order</code> (required)</li></ul><h3><a class="nav-anchor" href="#List-of-Supplied-Tableaus-1" id="List-of-Supplied-Tableaus-1">List of Supplied Tableaus</a></h3><p>A large variety of tableaus have been supplied by default via DiffEqDevTools.jl. The list of tableaus can be found in <a href="https://juliadiffeq.github.io/DiffEqDevDocs.jl/latest/internals/tableaus.html">the developer docs</a>. For the most useful and common algorithms, a hand-optimized version is supplied in OrdinaryDiffEq.jl which is recommended for general uses (i.e. use <code>DP5</code> instead of <code>ExplicitRK</code> with <code>tableau=constructDormandPrince()</code>). However, these serve as a good method for comparing between tableaus and understanding the pros/cons of the methods. Implemented are every published tableau (that I know exists). Note that user-defined tableaus also are accepted. To see how to define a tableau, checkout the <a href="https://github.com/JuliaDiffEq/DiffEqDevTools.jl/blob/master/src/ode_tableaus.jl">premade tableau source code</a>. Tableau docstrings should have appropriate citations (if not, file an issue).</p><p>Plot recipes are provided which will plot the stability region for a given tableau.</p><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Koskela, A. (2015). Approximating the matrix exponential of an advection-diffusion operator using the incomplete orthogonalization method. In Numerical Mathematics and Advanced Applications-ENUMATH 2013 (pp. 345-353). Springer, Cham.</p></div><footer><hr/><a class="previous" href="discrete_solve.html"><span class="direction">Previous</span><span class="title">Discrete Solvers</span></a><a class="next" href="dynamical_solve.html"><span class="direction">Next</span><span class="title">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</span></a></footer></article></body></HTML>