<!DOCTYPE html><HTML lang="en"><head><meta charset="UTF-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>DAE Solvers Â· DifferentialEquations.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-90474609-3', 'auto');
ga('send', 'pageview', {'page': location.pathname + location.search + location.hash});
</script><link href="https://docs.sciml.ai/stable/solvers/dae_solve/" rel="canonical"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script data-main="../../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" data-theme-name="documenter-dark" href="../../assets/themes/documenter-dark.css" rel="stylesheet" type="text/css"/><link class="docs-theme-link" data-theme-name="documenter-light" data-theme-primary="" href="../../assets/themes/documenter-light.css" rel="stylesheet" type="text/css"/><script src="../../assets/themeswap.js"></script><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img alt="DifferentialEquations.jl logo" src="../../assets/logo.png"/></a><div class="docs-package-name"><span class="docs-autofit">DifferentialEquations.jl</span></div><form action="../../search/" class="docs-search"><input class="docs-search-query" id="documenter-search-query" name="q" placeholder="Search docs" type="text"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/ode_example/">Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/advanced_ode_example/">Solving Stiff Equations</a></li><li><a class="tocitem" href="../../tutorials/sde_example/">Stochastic Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/rode_example/">Random Ordinary Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dde_example/">Delay Differential Equations</a></li><li><a class="tocitem" href="../../tutorials/dae_example/">Differential Algebraic Equations</a></li><li><a class="tocitem" href="../../tutorials/discrete_stochastic_example/">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="tocitem" href="../../tutorials/jump_diffusion/">Jump Diffusion Equations</a></li><li><a class="tocitem" href="../../tutorials/bvp_example/">Boundary Value Problems</a></li><li><a class="tocitem" href="../../tutorials/additional/">Additional Tutorials</a></li></ul></li><li><span class="tocitem">Basics</span><ul><li><a class="tocitem" href="../../basics/overview/">Overview of DifferentialEquations.jl</a></li><li><a class="tocitem" href="../../basics/common_solver_opts/">Common Solver Options</a></li><li><a class="tocitem" href="../../basics/solution/">Solution Handling</a></li><li><a class="tocitem" href="../../basics/plot/">Plot Functions</a></li><li><a class="tocitem" href="../../basics/integrator/">Integrator Interface</a></li><li><a class="tocitem" href="../../basics/problem/">Problem Interface</a></li><li><a class="tocitem" href="../../basics/faq/">Frequently Asked Questions</a></li><li><a class="tocitem" href="../../basics/compatibility_chart/">Solver Compatibility Chart</a></li></ul></li><li><span class="tocitem">Problem Types</span><ul><li><a class="tocitem" href="../../types/discrete_types/">Discrete Problems</a></li><li><a class="tocitem" href="../../types/ode_types/">ODE Problems</a></li><li><a class="tocitem" href="../../types/dynamical_types/">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="tocitem" href="../../types/split_ode_types/">Split ODE Problems</a></li><li><a class="tocitem" href="../../types/steady_state_types/">Steady State Problems</a></li><li><a class="tocitem" href="../../types/bvp_types/">BVP Problems</a></li><li><a class="tocitem" href="../../types/sde_types/">SDE Problems</a></li><li><a class="tocitem" href="../../types/rode_types/">RODE Problems</a></li><li><a class="tocitem" href="../../types/dde_types/">DDE Problems</a></li><li><a class="tocitem" href="../../types/dae_types/">DAE Problems</a></li><li><a class="tocitem" href="../../types/jump_types/">Jump Problems</a></li></ul></li><li><span class="tocitem">Solver Algorithms</span><ul><li><a class="tocitem" href="../discrete_solve/">Discrete Solvers</a></li><li><a class="tocitem" href="../ode_solve/">ODE Solvers</a></li><li><a class="tocitem" href="../dynamical_solve/">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="tocitem" href="../split_ode_solve/">Split ODE Solvers</a></li><li><a class="tocitem" href="../steady_state_solve/">Steady State Solvers</a></li><li><a class="tocitem" href="../bvp_solve/">BVP Solvers</a></li><li><a class="tocitem" href="../jump_solve/">Jump Problem and Jump Diffusion Solvers</a></li><li><a class="tocitem" href="../sde_solve/">SDE Solvers</a></li><li><a class="tocitem" href="../rode_solve/">RODE Solvers</a></li><li><a class="tocitem" href="../dde_solve/">DDE Solvers</a></li><li class="is-active"><a class="tocitem" href="">DAE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Recommended-Methods-1"><span>Recommended Methods</span></a></li><li><a class="tocitem" href="#dae_solve_full-1"><span>Full List of Methods</span></a></li></ul></li><li><a class="tocitem" href="../benchmarks/">Solver Benchmarks</a></li></ul></li><li><span class="tocitem">Additional Features</span><ul><li><a class="tocitem" href="../../features/performance_overloads/">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="tocitem" href="../../features/diffeq_arrays/">DiffEq-Specific Array Types</a></li><li><a class="tocitem" href="../../features/diffeq_operator/">DiffEqOperators</a></li><li><a class="tocitem" href="../../features/noise_process/">Noise Processes</a></li><li><a class="tocitem" href="../../features/linear_nonlinear/">Specifying (Non)Linear Solvers</a></li><li><a class="tocitem" href="../../features/callback_functions/">Event Handling and Callback Functions</a></li><li><a class="tocitem" href="../../features/callback_library/">Callback Library</a></li><li><a class="tocitem" href="../../features/ensemble/">Parallel Ensemble Simulations</a></li><li><a class="tocitem" href="../../features/io/">I/O: Saving and Loading Solution Data</a></li><li><a class="tocitem" href="../../features/low_dep/">Low Dependency Usage</a></li><li><a class="tocitem" href="../../features/progress_bar/">Progress Bar Integration</a></li></ul></li><li><span class="tocitem">Analysis Tools</span><ul><li><a class="tocitem" href="../../analysis/parameterized_functions/">ParameterizedFunctions</a></li><li><a class="tocitem" href="../../analysis/parameter_estimation/">Parameter Estimation and Bayesian Analysis</a></li><li><a class="tocitem" href="../../analysis/bifurcation/">Bifurcation Analysis</a></li><li><a class="tocitem" href="../../analysis/sensitivity/">Local Sensitivity Analysis (Automatic Differentiation)</a></li><li><a class="tocitem" href="../../analysis/global_sensitivity/">Global Sensitivity Analysis</a></li><li><a class="tocitem" href="../../analysis/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../analysis/neural_networks/">Neural Networks</a></li><li><a class="tocitem" href="../../analysis/dev_and_test/">Algorithm Development and Testing</a></li></ul></li><li><span class="tocitem">Domain Modeling Tools</span><ul><li><a class="tocitem" href="../../models/multiscale/">Multi-Scale Models</a></li><li><a class="tocitem" href="../../models/physical/">Physical Models</a></li><li><a class="tocitem" href="../../models/financial/">Financial Models</a></li><li><a class="tocitem" href="../../models/biological/">Chemical Reaction Models</a></li><li><a class="tocitem" href="../../models/external_modeling/">External Modeling Packages</a></li></ul></li><li><span class="tocitem">APIs</span><ul><li><a class="tocitem" href="../../apis/diffeqbio/">DiffEqBiological.jl API</a></li></ul></li><li><span class="tocitem">Extra Details</span><ul><li><a class="tocitem" href="../../extras/timestepping/">Timestepping Method Descriptions</a></li><li><a class="tocitem" href="../../extras/sensitivity_math/">Mathematics of Sensitivity Analysis</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solver Algorithms</a></li><li class="is-active"><a href="">DAE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="">DAE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/DiffEqDocs.jl/blob/master/docs/src/solvers/dae_solve.md" title="Edit on GitHub"><span class="docs-icon fab">ï</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" href="#" id="documenter-settings-button" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" href="#" id="documenter-sidebar-button"></a></div></header><article class="content" id="documenter-page"><h1 id="DAE-Solvers-1"><a class="docs-heading-anchor" href="#DAE-Solvers-1">DAE Solvers</a><a class="docs-heading-anchor-permalink" href="#DAE-Solvers-1" title="Permalink"></a></h1><h2 id="Recommended-Methods-1"><a class="docs-heading-anchor" href="#Recommended-Methods-1">Recommended Methods</a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods-1" title="Permalink"></a></h2><p>For medium to low accuracy small numbers of DAEs in constant mass matrices form, the  <code>Rosenbrock23</code> and <code>Rodas5</code> methods are good choices which will get good efficiency if the mass matrix is constant. <code>Rosenbrock23</code> is better for low accuracy (error tolerance <code>&lt;1e-4</code>) and <code>Rodas5</code> is better for high accuracy. Another choice at high accuracy is <code>RadauIIA5</code>.</p><p>If the mass matrices are not constant, the Rosenbrock methods are not applicable. In that case, <code>RadauIIA5</code> or BDF methods like <code>QBDF</code> tend to perform well, with <code>RadauIIA5</code> doing best for high accuracy.</p><p>If the problem cannot be defined in mass matrix form, the recommended method for performance is <code>IDA</code> from the Sundials.jl package if you are solving problems with <code>Float64</code>. If Julia types are required, currently <code>DABDF2</code> is the best method.</p><h2 id="dae_solve_full-1"><a class="docs-heading-anchor" href="#dae_solve_full-1">Full List of Methods</a><a class="docs-heading-anchor-permalink" href="#dae_solve_full-1" title="Permalink"></a></h2><h4 id="Initialization-Schemes-1"><a class="docs-heading-anchor" href="#Initialization-Schemes-1">Initialization Schemes</a><a class="docs-heading-anchor-permalink" href="#Initialization-Schemes-1" title="Permalink"></a></h4><p>For all OrdinaryDiffEq.jl methods, an initialization scheme can be set with a common keyword argument <code>initializealg</code>. The choices are:</p><ul><li><code>BrownFullBasicInit</code>: For Index-1 DAEs implicit DAEs and and semi-explicit DAEs in mass matrix form. Keeps the differential variables constant. Requires <code>du0</code> when used on a <code>DAEProblem</code>.</li><li><code>ShampineCollocationInit</code>: For Index-1 DAEs implicit DAEs and and semi-explicit DAEs in mass matrix form. Changes both the differential and algebraic variables.</li></ul><h3 id="OrdinaryDiffEq.jl-(Implicit-ODE)-1"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-(Implicit-ODE)-1">OrdinaryDiffEq.jl (Implicit ODE)</a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-(Implicit-ODE)-1" title="Permalink"></a></h3><p>These methods from OrdinaryDiffEq are for <code>DAEProblem</code> specifications.</p><ul><li><code>DImplicitEuler</code> - 1st order A-L and stiffly stable adaptive implicit Euler</li><li><code>DABDF2</code> - 2nd order A-L stable adaptive BDF method.</li></ul><h3 id="OrdinaryDiffEq.jl-(Mass-Matrix)-1"><a class="docs-heading-anchor" href="#OrdinaryDiffEq.jl-(Mass-Matrix)-1">OrdinaryDiffEq.jl (Mass Matrix)</a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEq.jl-(Mass-Matrix)-1" title="Permalink"></a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><h4 id="Rosenbrock-Methods-1"><a class="docs-heading-anchor" href="#Rosenbrock-Methods-1">Rosenbrock Methods</a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-Methods-1" title="Permalink"></a></h4><p>Note that the Rosenbrock methods only support constant mass matrices.</p><ul><li><code>ROS3P</code> - 3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</li><li><code>Rodas3</code> - 3rd order A-stable and stiffly stable Rosenbrock method.</li><li><code>RosShamp4</code>- An A-stable 4th order Rosenbrock method.</li><li><code>Veldd4</code> - A 4th order D-stable Rosenbrock method.</li><li><code>Velds4</code> - A 4th order A-stable Rosenbrock method.</li><li><code>GRK4T</code> - An efficient 4th order Rosenbrock method.</li><li><code>GRK4A</code> - An A-stable 4th order Rosenbrock method. Essentially "anti-L-stable" but efficient.</li><li><code>Ros4LStab</code> - A 4th order L-stable Rosenbrock method.</li><li><code>Rodas4</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas42</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</li><li><code>Rodas4P</code> - A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</li><li><code>Rodas5</code> - A 5th order A-stable stiffly stable Rosenbrock method. Currently has a Hermite interpolant because its stiff-aware 3rd order interpolant is not yet implemented.</li></ul><h4 id="Rosenbrock-W-Methods-1"><a class="docs-heading-anchor" href="#Rosenbrock-W-Methods-1">Rosenbrock-W Methods</a><a class="docs-heading-anchor-permalink" href="#Rosenbrock-W-Methods-1" title="Permalink"></a></h4><p>Note that the Rosenbrock methods only support constant mass matrices.</p><ul><li><code>Rosenbrock23</code> - An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</li><li><code>Rosenbrock32</code> - An Order 3/2 A-Stable Rosenbrock-W method which is good for mildy stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</li><li><code>RosenbrockW6S4OS</code> - A 4th order L-stable Rosenbrock-W method (fixed step only).</li><li><code>ROS34PW1a</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW1b</code> - A 4th order L-stable Rosenbrock-W method.</li><li><code>ROS34PW2</code> - A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</li><li><code>ROS34PW3</code> - A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</li></ul><h4 id="FIRK-Methods-1"><a class="docs-heading-anchor" href="#FIRK-Methods-1">FIRK Methods</a><a class="docs-heading-anchor-permalink" href="#FIRK-Methods-1" title="Permalink"></a></h4><ul><li><code>RadauIIA5</code> - An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency.</li></ul><h4 id="SDIRK-Methods-1"><a class="docs-heading-anchor" href="#SDIRK-Methods-1">SDIRK Methods</a><a class="docs-heading-anchor-permalink" href="#SDIRK-Methods-1" title="Permalink"></a></h4><ul><li><code>ImplicitEuler</code> - Stage order 1. A-B-L-stable. Adaptive timestepping through a divided differences estimate via memory. Strong-stability presurving (SSP).</li><li><code>ImplicitMidpoint</code> - Stage order 1. Symplectic. Good for when symplectic integration is required.</li><li><code>Trapezoid</code> - A second order A-stable symmetric ESDIRK method. "Almost symplectic" without numerical dampening. Also known as Crank-Nicolson when applied to PDEs. Adaptive timestepping via divided differences on the memory. Good for highly stiff equations which are non-oscillatory.</li></ul><h4 id="Multistep-Methods-1"><a class="docs-heading-anchor" href="#Multistep-Methods-1">Multistep Methods</a><a class="docs-heading-anchor-permalink" href="#Multistep-Methods-1" title="Permalink"></a></h4><p>Quasi-constant stepping is the time stepping strategy which matches the classic GEAR, LSODE,  and <code>ode15s</code> integrators. The variable-coefficient methods match the ideas of the classic EPISODE integrator and early VODE designs. The Fixed Leading Coefficient (FLC) methods match the behavior of the classic VODE and Sundials CVODE integrator.</p><ul><li><code>QNDF1</code> - An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter <code>kappa</code> defaults to Shampine's accuracy-optimal <code>-0.1850</code>.</li><li><code>QBDF1</code> - An adaptive order 1 L-stable BDF method. This is equivalent to implicit Euler but using the BDF error estimator.</li><li><code>ABDF2</code> - An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.</li><li><code>QNDF2</code> - An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.</li><li><code>QBDF2</code> - An adaptive order 2 L-stable BDF method using quasi-constant timesteps.</li><li><code>QNDF</code> - An adaptive order quasi-constant timestep NDF method. Utilizes Shampine's accuracy-optimal <code>kappa</code> values as defaults (has a keyword argument for a tuple of <code>kappa</code> coefficients).</li><li><code>QBDF</code> - An adaptive order quasi-constant timestep BDF method.</li></ul><h3 id="Sundials.jl-1"><a class="docs-heading-anchor" href="#Sundials.jl-1">Sundials.jl</a><a class="docs-heading-anchor-permalink" href="#Sundials.jl-1" title="Permalink"></a></h3><p>Note that this setup is not automatically included with DifferentialEquations.jl. To use the following algorithms, you must install and use Sundials.jl:</p><pre><code class="language-julia">]add Sundials
using Sundials</code></pre><ul><li><code>IDA</code> - This is the IDA method from the Sundials.jl package.</li></ul><p>Note that the constructors for the Sundials algorithms take a main argument:</p><ul><li><p><code>linearsolver</code> - This is the linear solver which is used in the Newton iterations. The choices are:</p><ul><li><code>:Dense</code> - A dense linear solver.</li><li><code>:Band</code> - A solver specialized for banded Jacobians. If used, you must set the position of the upper and lower non-zero diagonals via <code>jac_upper</code> and <code>jac_lower</code>.</li><li><code>:LapackDense</code> - A version of the dense linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than <code>:Dense</code> on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li><code>:LapackBand</code> - A version of the banded linear solver that uses the Julia-provided OpenBLAS-linked LAPACK for multithreaded operations. This will be faster than <code>:Band</code> on larger systems but has noticable overhead on smaller (&lt;100 ODE) systems.</li><li><code>:GMRES</code> - A GMRES method. Recommended first choice Krylov method</li><li><code>:BCG</code> - A Biconjugate gradient method.</li><li><code>:PCG</code> - A preconditioned conjugate gradient method. Only for symmetric linear systems.</li><li><code>:TFQMR</code> - A TFQMR method.</li><li><code>:KLU</code> - A sparse factorization method. Requires that the user specifies a Jacobian. The Jacobian must be set as a sparse matrix in the <code>ODEProblem</code> type.</li></ul></li></ul><p>Example:</p><pre><code class="language-julia">IDA() # Newton + Dense solver
IDA(linear_solver=:Band,jac_upper=3,jac_lower=3) # Banded solver with nonzero diagonals 3 up and 3 down
IDA(linear_solver=:BCG) # Biconjugate gradient method                                   </code></pre><p>All of the additional options are available. The constructor is:</p><pre><code class="language-julia">IDA(;linear_solver=:Dense,jac_upper=0,jac_lower=0,krylov_dim=0,
    max_order = 5,
    max_error_test_failures = 7,
    max_nonlinear_iters = 3,
    nonlinear_convergence_coefficient = 0.33,
    nonlinear_convergence_coefficient_ic = 0.0033,
    max_num_steps_ic = 5,
    max_num_jacs_ic = 4,
    max_num_iters_ic = 10,
    max_num_backs_ic = 100,
    use_linesearch_ic = true,
    max_convergence_failures = 10,
    init_all = false,
    prec = nothing, psetup = nothing, prec_side = 0)</code></pre><p>See <a href="https://computation.llnl.gov/sites/default/files/public/ida_guide.pdf">the Sundials manual</a> for details on the additional options. The option <code>init_all</code> controls the initial condition consistency routine. If the initial conditions are inconsistant (i.e. they do not satisfy the implicit equation), <code>init_all=false</code> means that the algebraic variables and derivatives will be modified in order to satisfy the DAE. If <code>init_all=true</code>, all initial conditions will be modified to satify the DAE.</p><p>Note that here <code>prec</code> is a preconditioner function <code>prec(z,r,p,t,y,fy,gamma,delta,lr)</code> where:</p><ul><li><code>z</code>: the computed output vector</li><li><code>r</code>: the right-hand side vector of the linear system</li><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>du</code>: the current value of <code>f(u,p,t)</code></li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li><li><code>delta</code>: the iterative method tolerance</li><li><code>lr</code>: a flag for whether <code>lr=1</code> (left) or <code>lr=2</code> (right) preconditioning</li></ul><p>and <code>psetup</code> is the preconditioner setup function for pre-computing Jacobian information. Where:</p><ul><li><code>p</code>: the parameters</li><li><code>t</code>: the current independent variable</li><li><code>resid</code>: the current residual</li><li><code>u</code>: the current state</li><li><code>du</code>: the current derivative of the state</li><li><code>gamma</code>: the <code>gamma</code> of <code>W = M - gamma*J</code></li></ul><p><code>psetup</code> is optional when <code>prec</code> is set.</p><h3 id="DASKR.jl-1"><a class="docs-heading-anchor" href="#DASKR.jl-1">DASKR.jl</a><a class="docs-heading-anchor-permalink" href="#DASKR.jl-1" title="Permalink"></a></h3><p>DASKR.jl is not automatically included by DifferentialEquations.jl. To use this algorithm, you will need to install and use the package:</p><pre><code class="language-julia">]add DASKR
using DASKR</code></pre><ul><li><code>daskr</code> - This is a wrapper for the well-known DASKR algorithm.</li></ul><p>All additional options are available. The constructor is:</p><pre><code class="language-julia">function daskr(;linear_solver=:Dense,
                  jac_upper=0,jac_lower=0,max_order = 5,
                  non_negativity_enforcement = 0,
                  non_negativity_enforcement_array = nothing,
                  max_krylov_iters = nothing,
                  num_krylov_vectors = nothing,
                  max_number_krylov_restarts = 5,
                  krylov_convergence_test_constant = 0.05,
                  exclude_algebraic_errors = false)</code></pre><p>Choices for the linear solver are:</p><ul><li><code>:Dense</code></li><li><code>:Banded</code></li><li><code>:SPIGMR</code>, a Krylov method</li></ul><h3 id="DASSL.jl-1"><a class="docs-heading-anchor" href="#DASSL.jl-1">DASSL.jl</a><a class="docs-heading-anchor-permalink" href="#DASSL.jl-1" title="Permalink"></a></h3><ul><li><code>dassl</code> - A native Julia implementation of the DASSL algorithm.</li></ul><h3 id="ODEInterfaceDiffEq.jl-1"><a class="docs-heading-anchor" href="#ODEInterfaceDiffEq.jl-1">ODEInterfaceDiffEq.jl</a><a class="docs-heading-anchor-permalink" href="#ODEInterfaceDiffEq.jl-1" title="Permalink"></a></h3><p>These methods require the DAE to be an <code>ODEProblem</code> in mass matrix form. For extra options for the solvers, see the ODE solver page.</p><ul><li><code>seulex</code> - Extrapolation-algorithm based on the linear implicit Euler method.</li><li><code>radau</code> - Implicit Runge-Kutta (Radau IIA) of variable order between 5 and 13.</li><li><code>radau5</code> - Implicit Runge-Kutta method (Radau IIA) of order 5.</li><li><code>rodas</code> - Rosenbrock 4(3) method.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dde_solve/">Â« DDE Solvers</a><a class="docs-footer-nextpage" href="../benchmarks/">Solver Benchmarks Â»</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label></p><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div><p></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 15 July 2020 13:11">Wednesday 15 July 2020</span>. Using Julia version 1.1.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></HTML>