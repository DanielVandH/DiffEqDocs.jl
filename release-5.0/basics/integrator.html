<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>Integrator Interface Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/basics/integrator/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search" id="search-form"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/bvp_example.html">Boundary Value Problems</a></li><li><a class="toctext" href="../tutorials/additional.html">Additional Tutorials</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="solution.html">Solution Handling</a></li><li><a class="toctext" href="plot.html">Plot Functions</a></li><li class="current"><a class="toctext" href="integrator.html">Integrator Interface</a><ul class="internal"><li><a class="toctext" href="#Initialization-and-Stepping-1">Initialization and Stepping</a></li><li><a class="toctext" href="#Handing-Integrators-1">Handing Integrators</a></li><li><a class="toctext" href="#Function-Interface-1">Function Interface</a></li><li><a class="toctext" href="#Additional-Options-1">Additional Options</a></li><li><a class="toctext" href="#Plot-Recipe-1">Plot Recipe</a></li></ul></li><li><a class="toctext" href="problem.html">Problem interface</a></li><li><a class="toctext" href="faq.html">Frequently Asked Questions</a></li><li><a class="toctext" href="compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/dynamical_types.html">Dynamical, Hamiltonian and 2nd Order ODE Problems</a></li><li><a class="toctext" href="../types/split_ode_types.html">Split ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/bvp_types.html">BVP Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/dynamical_solve.html">Dynamical, Hamiltonian, and 2nd Order ODE Solvers</a></li><li><a class="toctext" href="../solvers/split_ode_solve.html">Split ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/bvp_solve.html">BVP Solvers</a></li><li><a class="toctext" href="../solvers/jump_solve.html">Jump Problem Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/benchmarks.html">Solver Benchmarks</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">DiffEqFunctions (Jacobians, Gradients, etc.) and Jacobian Types</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/diffeq_operator.html">DiffEqOperators</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li><a class="toctext" href="../analysis/parameterized_functions.html">ParameterizedFunctions</a></li><li><a class="toctext" href="../analysis/parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="../analysis/bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="../analysis/sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="../analysis/uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="../analysis/dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/physical.html">Physical Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Chemical Reaction Models</a></li><li><a class="toctext" href="../models/external_modeling.html">External Modeling Packages</a></li></ul></li><li><span class="toctext">Extra Details</span><ul><li><a class="toctext" href="../extras/timestepping.html">Timestepping Method Descriptions</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Basics</li><li><a href="integrator.html">Integrator Interface</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/blob/master/docs/src/basics/integrator.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Integrator Interface</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#Integrator-Interface-1" id="Integrator-Interface-1">Integrator Interface</a></h1><p>The integrator interface gives one the ability to interactively step through the numerical solving of a differential equation. Through this interface, one can easily monitor results, modify the problem during a run, and dynamically continue solving as one sees fit.</p><h2><a class="nav-anchor" href="#Initialization-and-Stepping-1" id="Initialization-and-Stepping-1">Initialization and Stepping</a></h2><p>To initialize an integrator, use the syntax:</p><pre><code class="language-julia">integrator = init(prob,alg;kwargs...)</code></pre><p>The keyword args which are accepted are the same <a href="common_solver_opts.html#Common-Solver-Options-1">Common Solver Options</a> used by <code>solve</code> and the returned value is an <code>integrator</code> which satisfies <code>typeof(integrator)&lt;:DEIntegrator</code>. One can manually choose to step via the <code>step!</code> command:</p><pre><code class="language-julia">step!(integrator)</code></pre><p>which will take one successful step. Additonally:</p><pre><code class="language-julia">step!(integrator,dt[,stop_at_tdt=false])</code></pre><p>passing a <code>dt</code> will make the integrator keep stepping until <code>integrator.t+dt</code>, and setting <code>stop_at_tdt=true</code> will add a <code>tstop</code> to force it to step to <code>integrator.t+dt</code></p><p>To check whether or not the integration step was successful, you can call <code>check_error(integrator)</code> which returns one of the <a href="solution.html#Return-Codes-(RetCodes)-1">Return Codes (RetCodes)</a>.</p><p>This type also implements an iterator interface, so one can step <code>n</code> times  (or to the last <code>tstop</code>) using the <code>take</code> iterator:</p><pre><code class="language-julia">for i in take(integrator,n) end</code></pre><p>One can loop to the end by using <code>solve!(integrator)</code> or using the iterator interface:</p><pre><code class="language-julia">for i in integrator end</code></pre><p>In addition, some helper iterators are provided to help monitor the solution. For example, the <code>tuples</code> iterator lets you view the values:</p><pre><code class="language-julia">for (u,t) in tuples(integrator)
  @show u,t
end</code></pre><p>and the <code>intervals</code> iterator lets you view the full interval:</p><pre><code class="language-julia">for (tprev,uprev,u,t) in intervals(integrator)
  @show tprev,t
end</code></pre><p>Additionally, you can make the iterator return specific time points via the <code>TimeChoiceIterator</code>:</p><pre><code class="language-julia">ts = linspace(0,1,11)
for (u,t) in TimeChoiceIterator(integrator,ts)
  @show u,t
end</code></pre><p>Lastly, one can dynamically control the "endpoint". The initialization simply makes <code>prob.tspan[2]</code> the last value of <code>tstop</code>, and many of the iterators are made to stop at the final <code>tstop</code> value. However, <code>step!</code> will always take a step, and one can dynamically add new values of <code>tstops</code> by modifiying the variable in the options field: <code>add_tstop!(integrator,new_t)</code>.</p><p>Finally, to solve to the last <code>tstop</code>, call <code>solve!(integrator)</code>. Doing <code>init</code> and then <code>solve!</code> is equivalent to <code>solve</code>.</p><h2><a class="nav-anchor" href="#Handing-Integrators-1" id="Handing-Integrators-1">Handing Integrators</a></h2><p>The <code>integrator&lt;:DEIntegrator</code> type holds all of the information for the intermediate solution of the differential equation. Useful fields are:</p><ul><li><p><code>t</code> - time of the proposed step</p></li><li><p><code>u</code> - value at the proposed step</p></li><li><p><code>p</code> - user-provided data</p></li><li><p><code>opts</code> - common solver options</p></li><li><p><code>alg</code> - the algorithm associated with the solution</p></li><li><p><code>f</code> - the function being solved</p></li><li><p><code>sol</code> - the current state of the solution</p></li><li><p><code>tprev</code> - the last timepoint</p></li><li><p><code>uprev</code> - the value at the last timepoint</p></li></ul><p>The <code>p</code> is the data which is provided by the user as a keyword arg in <code>init</code>. <code>opts</code> holds all of the common solver options, and can be mutated to change the solver characteristics. For example, to modify the absolute tolerance for the future timesteps, one can do:</p><pre><code class="language-julia">integrator.opts.abstol = 1e-9</code></pre><p>The <code>sol</code> field holds the current solution. This current solution includes the interpolation function if available, and thus <code>integrator.sol(t)</code> lets one interpolate efficiently over the whole current solution. Additionally, a a "current interval interpolation function" is provided on the <code>integrator</code> type via <code>integrator(t)</code>. This uses only the solver information from the interval <code>[tprev,t]</code> to compute the interpolation, and is allowed to extrapolate beyond that interval.</p><h3><a class="nav-anchor" href="#Note-about-mutating-1" id="Note-about-mutating-1">Note about mutating</a></h3><p>Be cautious: one should not directly mutate the <code>t</code> and <code>u</code> fields of the integrator. Doing so will destroy the accuracy of the interpolator and can harm certain algorithms. Instead if one wants to introduce discontinuous changes, one should use the <a href="../features/callback_functions.html#Event-Handling-and-Callback-Functions-1">Event Handling and Callback Functions</a>. Modifications within a callback <code>affect!</code> surrounded by saves provides an error-free handling of the discontinuity.</p><p>As low-level alternative to the callbacks, one can use <code>set_t!</code>, <code>set_u!</code> and <code>set_ut!</code> to mutate integrator states.  Note that certain integrators may not have efficient ways to modify <code>u</code> and <code>t</code>.  In such case, <code>set_*!</code> are as inefficient as <code>reinit!</code>.</p><ul><li><p><code>set_t!(integrator, t)</code>: Set current time point of the <code>integrator</code> to <code>t</code>.</p></li><li><p><code>set_u!(integrator, u)</code>: Set current state of the <code>integrator</code> to <code>u</code>.</p></li><li><p><code>set_ut!(integrator, u, t)</code>: Set current state of the <code>integrator</code> to <code>u</code> and <code>t</code>.</p></li></ul><h3><a class="nav-anchor" href="#Integrator-vs-Solution-1" id="Integrator-vs-Solution-1">Integrator vs Solution</a></h3><p>The integrator and the solution have very different actions because they have very different meanings. The <code>typeof(sol) &lt;: DESolution</code> type is a type with  history: it stores all of the (requested) timepoints and interpolates/acts using the values closest in time. On the other hand, the <code>typeof(integrator)&lt;:DEIntegrator</code> type is a  local object. It only knows the times of the interval it currently spans,  the current caches and values, and the current state of the solver  (the current options, tolerances, etc.). These serve very different purposes:</p><ul><li><p>The <code>integrator</code>'s interpolation can extrapolate, both forward and backward in in time. This is used to estimate events and is internally used for predictions.</p></li><li><p>The <code>integrator</code> is fully mutable upon iteration. This means that every time an iterator affect is used, it will take timesteps from the current time. This means that <code>first(integrator)!=first(integrator)</code> since the <code>integrator</code> will step once to evaluate the left and then step once more (not backtracking). This allows the iterator to keep dynamically stepping, though one should note that it may violate some immutablity assumptions commonly made about iterators.</p></li></ul><p>If one wants the solution object, then one can find it in <code>integrator.sol</code>.</p><h2><a class="nav-anchor" href="#Function-Interface-1" id="Function-Interface-1">Function Interface</a></h2><p>In addition to the type interface, a function interface is provided which allows for safe modifications of the integrator type, and allows for uniform usage throughout the ecosystem (for packages/algorithms which implement the functions). The following functions make up the interface:</p><h3><a class="nav-anchor" href="#Saving-Controls-1" id="Saving-Controls-1">Saving Controls</a></h3><ul><li><p><code>savevalues!(integrator)</code>: Adds the current state to the <code>sol</code>.</p></li></ul><h3><a class="nav-anchor" href="#Caches-1" id="Caches-1">Caches</a></h3><ul><li><p><code>get_tmp_cache(integrator)</code>: Returns a tuple of internal cache vectors which are safe to use as temporary arrays. This should be used for integrator interface and callbacks which need arrays to write into in order to be non-allocating. The length of the tuple is dependent on the method.</p></li><li><p><code>user_cache(integrator)</code>: Returns an iterator over the user-facing cache arrays.</p></li><li><p><code>u_cache(integrator)</code>:  Returns an iterator over the cache arrays for <code>u</code> in the method. This can be used to change internal values as needed.</p></li><li><p><code>du_cache(integrator)</code>:  Returns an iterator over the cache arrays for rate quantities the method. This can be used to change internal values as needed.</p></li><li><p><code>full_cache(integrator)</code>:  Returns an iterator over the cache arrays of the method. This can be used to change internal values as needed.</p></li></ul><h3><a class="nav-anchor" href="#Stepping-Controls-1" id="Stepping-Controls-1">Stepping Controls</a></h3><ul><li><p><code>u_modified!(integrator,bool)</code>: Bool which states whether a change to <code>u</code> occurred, allowing the solver to handle the discontinuity. By default, this is assumed to be true if a callback is used. This will result in the re-calculation of the derivative at <code>t+dt</code>, which is not necessary if the algorithm is FSAL and <code>u</code> does not experience a discontinuous change at the end of the interval. Thus if <code>u</code> is unmodified in a callback, a single call to the derivative calculation can be eliminated by <code>u_modified!(integrator,false)</code>.</p></li><li><p><code>get_proposed_dt(integrator)</code>:  Gets the proposed <code>dt</code> for the next timestep.</p></li><li><p><code>set_proposed_dt!(integrator,dt)</code>:  Sets the proposed <code>dt</code> for the next timestep.</p></li><li><p><code>set_proposed_dt!(integrator,integrator2)</code>:  Sets the timestepping of <code>integrator</code> to match that of <code>integrator2</code>. Note that due to PI control and step acceleration this is more than matching the factors in most cases.</p></li><li><p><code>proposed_dt(integrator)</code>: Returns the <code>dt</code> of the proposed step.</p></li><li><p><code>terminate!(integrator)</code>: Terminates the integrator by emptying <code>tstops</code>. This can be used in events and callbacks to immediately end the solution process.</p></li><li><p><code>change_t_via_interpolation!(integrator,t,modify_save_endpoint=Val{false})</code>: This option lets one modify the current <code>t</code> and changes all of the corresponding values using the local interpolation. If the current solution has already been saved, one can provide the optional value <code>modify_save_endpoint</code> to also modify the endpoint of <code>sol</code> in the same manner.</p></li><li><p><code>add_tstop!(integrator,t)</code>: Adds a <code>tstop</code> at time <code>t</code>.</p></li><li><p><code>add_saveat!(integrator,t)</code>: Adds a <code>saveat</code> time point at <code>t</code>.</p></li></ul><h3><a class="nav-anchor" href="#Resizing-1" id="Resizing-1">Resizing</a></h3><ul><li><p><code>resize!(integrator,k)</code>: Resizes the DE to a size <code>k</code>. This chops off the end of the array, or adds blank values at the end, depending on whether <code>k&gt;length(integrator.u)</code>.</p></li><li><p><code>resize_non_user_cache!(integrator,k)</code>: Resizes the non-user facing caches to be compatible with a DE of size <code>k</code>. This includes resizing Jacobian caches. Note that in many cases, <code>resize!</code> simple resizes <code>user_cache</code> variables and then calls this function. This finer control is required for some <code>AbstractArray</code> operations.</p></li><li><p><code>deleteat_non_user_cache!(integrator,idxs)</code>: <code>deleteat!</code>s the non-user facing caches at indices <code>idxs</code>. This includes resizing Jacobian caches. Note that in many cases, <code>deleteat!</code> simple <code>deleteat!</code>s <code>user_cache</code> variables and then calls this function. This finer control is required for some <code>AbstractArray</code> operations.</p></li><li><p><code>addat_non_user_cache!(integrator,idxs)</code>: <code>addat!</code>s the non-user facing caches at indices <code>idxs</code>. This includes resizing Jacobian caches. Note that in many cases, <code>addat!</code> simple <code>addat!</code>s <code>user_cache</code> variables and then calls this function. This finer control is required for some <code>AbstractArray</code> operations.</p></li><li><p><code>deleteat!(integrator,idxs)</code>: Shrinks the ODE by deleting the <code>idxs</code> components.</p></li><li><p><code>addat!(integrator,idxs)</code>: Grows the ODE by adding the <code>idxs</code> components. Must be contiguous indices.</p></li></ul><h3><a class="nav-anchor" href="#Reinit-1" id="Reinit-1">Reinit</a></h3><p>The reinit function lets you restart the integration at a new value. The full function is of the form:</p><pre><code class="language-julia">reinit!(integrator::ODEIntegrator,u0 = integrator.sol.prob.u0;
  t0 = integrator.sol.prob.tspan[1], tf = integrator.sol.prob.tspan[2],
  erase_sol = true,
  tstops = integrator.opts.tstops_cache,
  saveat = integrator.opts.saveat_cache,
  d_discontinuities = integrator.opts.d_discontinuities_cache,
  reset_dt = (integrator.dtcache == zero(integrator.dt)) &amp;&amp; integrator.opts.adaptive,
  reinit_callbacks = true, initialize_save = true,
  reinit_cache = true)</code></pre><p><code>u0</code> is the value to start at. The starting time point and end point can be changed via <code>t0</code> and <code>tf</code>. <code>erase_sol</code> allows one to start with no other values in the solution, or keep the previous solution. <code>tstops</code>, <code>d_discontinuities</code>, and <code>saveat</code> are reset as well, but can be ignored. <code>reset_dt</code> is a boolean for whether to reset the current value of <code>dt</code> using the automatic <code>dt</code> determination algorithm. <code>reinit_callbacks</code> is whether to run the callback initializations again (and <code>initialize_save</code> is for that). <code>reinit_cache</code> is whether to re-run the cache initialization function (i.e. resetting FSAL, not allocating vectors) which should usually be true for correctness.</p><p>Additionally, once can access <code>auto_dt_reset!(integrator::ODEIntegrator)</code> which will run the auto <code>dt</code> initialization algorithm.</p><h3><a class="nav-anchor" href="#Misc-1" id="Misc-1">Misc</a></h3><ul><li><p><code>get_du(integrator)</code>: Returns the derivative at <code>t</code>.</p></li><li><p><code>get_du!(out,integrator)</code>: Write the current derivative at <code>t</code> into <code>out</code>.</p></li><li><p><code>check_error(integrator)</code>: Checks error conditions and updates the retcode.</p></li></ul><h4><a class="nav-anchor" href="#Note-1" id="Note-1">Note</a></h4><p>Note that not all of these functions will be implemented for every algorithm. Some have hard limitations. For example, Sundials.jl cannot resize problems. When a function is not limited, an error will be thrown.</p><h2><a class="nav-anchor" href="#Additional-Options-1" id="Additional-Options-1">Additional Options</a></h2><p>The following options can additionally be specified in <code>init</code> (or be mutated in the <code>opts</code>) for further control of the integrator:</p><ul><li><p><code>advance_to_tstop</code>: This makes <code>step!</code> continue to the next value in <code>tstop</code>.</p></li><li><p><code>stop_at_next_tstop</code>: This forces the iterators to stop at the next value of <code>tstop</code>.</p></li></ul><p>For example, if one wants to iterate but only stop at specific values, one can choose:</p><pre><code class="language-julia">integrator = init(prob,Tsit5();dt=1//2^(4),tstops=[0.5],advance_to_tstop=true)
for (u,t) in tuples(integrator)
  @test t â [0.5,1.0]
end</code></pre><p>which will only enter the loop body at the values in <code>tstops</code> (here, <code>prob.tspan[2]==1.0</code> and thus there are two values of <code>tstops</code> which are hit). Addtionally, one can <code>solve!</code> only to <code>0.5</code> via:</p><pre><code class="language-julia">integrator = init(prob,Tsit5();dt=1//2^(4),tstops=[0.5])
integrator.opts.stop_at_next_tstop = true
solve!(integrator)</code></pre><h2><a class="nav-anchor" href="#Plot-Recipe-1" id="Plot-Recipe-1">Plot Recipe</a></h2><p>Like the <code>DESolution</code> type, a plot recipe is provided for the <code>DEIntegrator</code> type. Since the <code>DEIntegrator</code> type is a local state type on the current interval, <code>plot(integrator)</code> returns the solution on the current interval. The same options for the plot recipe are provided as for <code>sol</code>, meaning one can choose variables via the <code>vars</code> keyword argument, or change the <code>plotdensity</code> / turn on/off <code>denseplot</code>.</p><p>Additionally, since the <code>integrator</code> is an iterator, this can be used in the Plots.jl <code>animate</code> command to iteratively build an animation of the solution while solving the differential equation.</p><p>For an example of manually chaining together the iterator interface and plotting, one should try the following:</p><pre><code class="language-julia">using DifferentialEquations, DiffEqProblemLibrary, Plots

# Linear ODE which starts at 0.5 and solves from t=0.0 to t=1.0
prob = ODEProblem((u,p,t)-&gt;1.01u,0.5,(0.0,1.0))

using Plots
integrator = init(prob,Tsit5();dt=1//2^(4),tstops=[0.5])
pyplot(show=true)
plot(integrator)
for i in integrator
  display(plot!(integrator,vars=(0,1),legend=false))
end
step!(integrator); plot!(integrator,vars=(0,1),legend=false)
savefig("iteratorplot.png")</code></pre><p><img alt="Iterator Plot" src="../assets/iteratorplot.png"/></p><footer><hr/><a class="previous" href="plot.html"><span class="direction">Previous</span><span class="title">Plot Functions</span></a><a class="next" href="problem.html"><span class="direction">Next</span><span class="title">Problem interface</span></a></footer></article></body></HTML>