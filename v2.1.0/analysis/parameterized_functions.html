<!DOCTYPE html><HTML lang="en"><head><meta charset="utf-8"/><meta content="width=device-width, initial-scale=1.0" name="viewport"/><title>ParameterizedFunctions Â· DifferentialEquations.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script data-main="../assets/documenter.js" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="https://docs.juliadiffeq.org/stable/analysis/parameterized_functions/index.html" rel="canonical"/><script data-is-old-version="">document.addEventListener("DOMContentLoaded", function(){
    const div = document.createElement('div');
    div.setAttribute('style', 'position: fixed; bottom: 1em; right: 1em; z-index: 999; background-color: #ffaf9c; color: rgba(0, 0, 0, 0.7); border: 1px solid #d54625; border-radius: 4px; padding: 2em; text-align: center');
    const closer = document.createElement('div');
    closer.setAttribute('style', 'position: absolute; top: 0; right: 5px; padding: 5px; cursor: pointer; width: 12px; height: 12px;')
    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', () => {
        document.body.removeChild(div)
    })
    const href = documenterBaseURL + '/../stable'
    div.innerHTML = 'This is an old version of the documentation. <br> Click <a href="' + href + '">here</a> to go to the newest version.';
    div.appendChild(closer)
    document.body.appendChild(div);
});
</script><script data-outdated-warner="">function maybeAddWarning () {
    const head = document.getElementsByTagName('head')[0];

    // Add a noindex meta tag (unless one exists) so that search engines don't index this version of the docs.
    if (document.body.querySelector('meta[name="robots"]') === null) {
        const meta = document.createElement('meta');
        meta.name = 'robots';
        meta.content = 'noindex';

        head.appendChild(meta);
    };

    // Add a stylesheet to avoid inline styling
    const style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode('.outdated-warning-overlay {  position: fixed;  top: 0;  left: 0;  right: 0;  box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);  z-index: 999;  background-color: #ffaba7;  color: rgba(0, 0, 0, 0.7);  border-bottom: 3px solid #da0b00;  padding: 10px 35px;  text-align: center;  font-size: 15px; }  .outdated-warning-overlay .outdated-warning-closer {    position: absolute;    top: calc(50% - 10px);    right: 18px;    cursor: pointer;    width: 12px; }  .outdated-warning-overlay a {    color: #2e63b8; }    .outdated-warning-overlay a:hover {      color: #363636; }'));
    head.appendChild(style);

    const div = document.createElement('div');
    div.classList.add('outdated-warning-overlay');
    const closer = document.createElement('div');
    closer.classList.add('outdated-warning-closer');

    // Icon by font-awesome (license: https://fontawesome.com/license, link: https://fontawesome.com/icons/times?style=solid)
    closer.innerHTML = '<svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="times" class="svg-inline--fa fa-times fa-w-11" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"></path></svg>';
    closer.addEventListener('click', function () {
        document.body.removeChild(div);
    });
    let href = '/stable';
    if (window.documenterBaseURL) {
        href = window.documenterBaseURL + '/../stable';
    }
    div.innerHTML = 'This is an old version of the documentation. <br> <a href="' + href + '">Go to the newest version</a>.';
    div.appendChild(closer);
    document.body.appendChild(div);
};

if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', maybeAddWarning);
} else {
    maybeAddWarning();
};
</script></head><body><nav class="toc"><a href="../index.html"><img alt="DifferentialEquations.jl logo" class="logo" src="../assets/logo.png"/></a><h1>DifferentialEquations.jl</h1><select id="version-selector" onchange="window.location.href=this.value" style="visibility: hidden"></select><form action="../search.html" class="search"><input id="search-query" name="q" placeholder="Search docs" type="text"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../tutorials/ode_example.html">Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/sde_example.html">Stochastic Differential Equations</a></li><li><a class="toctext" href="../tutorials/rode_example.html">Random Ordinary Differential Equations</a></li><li><a class="toctext" href="../tutorials/dde_example.html">Delay Differential Equations</a></li><li><a class="toctext" href="../tutorials/dae_example.html">Differential Algebraic Equations</a></li><li><a class="toctext" href="../tutorials/discrete_stochastic_example.html">Discrete Stochastic (Gillespie) Equations</a></li><li><a class="toctext" href="../tutorials/jump_diffusion.html">Jump Diffusion Equations</a></li><li><a class="toctext" href="../tutorials/fempoisson_example.html">Poisson Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femheat_example.html">Heat Equation Finite Element Method</a></li><li><a class="toctext" href="../tutorials/femstochastic_example.html">Stochastic Finite Element Method</a></li></ul></li><li><span class="toctext">Basics</span><ul><li><a class="toctext" href="../basics/overview.html">Overview of DifferentialEquations.jl</a></li><li><a class="toctext" href="../basics/common_solver_opts.html">Common Solver Options</a></li><li><a class="toctext" href="../basics/solution.html">Solution Handling</a></li><li><a class="toctext" href="../basics/plot.html">Plot Functions</a></li><li><a class="toctext" href="../basics/integrator.html">Integrator Interface</a></li><li><a class="toctext" href="../basics/compatibility_chart.html">Solver Compatibility Chart</a></li></ul></li><li><span class="toctext">Problem Types</span><ul><li><a class="toctext" href="../types/discrete_types.html">Discrete Problems</a></li><li><a class="toctext" href="../types/ode_types.html">ODE Problems</a></li><li><a class="toctext" href="../types/steady_state_types.html">Steady State Problems</a></li><li><a class="toctext" href="../types/sde_types.html">SDE Problems</a></li><li><a class="toctext" href="../types/rode_types.html">RODE Problems</a></li><li><a class="toctext" href="../types/dde_types.html">DDE Problems</a></li><li><a class="toctext" href="../types/dae_types.html">DAE Problems</a></li><li><a class="toctext" href="../types/jump_types.html">Jump Problems</a></li><li><a class="toctext" href="../types/fem_types.html">FEM Problems</a></li></ul></li><li><span class="toctext">Solver Algorithms</span><ul><li><a class="toctext" href="../solvers/discrete_solve.html">Discrete Solvers</a></li><li><a class="toctext" href="../solvers/ode_solve.html">ODE Solvers</a></li><li><a class="toctext" href="../solvers/refined_ode_solve.html">Refined ODE Solvers</a></li><li><a class="toctext" href="../solvers/steady_state_solve.html">Steady State Solvers</a></li><li><a class="toctext" href="../solvers/sde_solve.html">SDE Solvers</a></li><li><a class="toctext" href="../solvers/rode_solve.html">RODE Solvers</a></li><li><a class="toctext" href="../solvers/dde_solve.html">DDE Solvers</a></li><li><a class="toctext" href="../solvers/dae_solve.html">DAE Solvers</a></li><li><a class="toctext" href="../solvers/fempoisson_solve.html">FEM Poisson Solvers</a></li><li><a class="toctext" href="../solvers/femheat_solve.html">FEM Heat Solvers</a></li></ul></li><li><span class="toctext">Additional Features</span><ul><li><a class="toctext" href="../features/performance_overloads.html">Performance Overloads</a></li><li><a class="toctext" href="../features/diffeq_arrays.html">DiffEq-Specific Array Types</a></li><li><a class="toctext" href="../features/noise_process.html">Noise Processes</a></li><li><a class="toctext" href="../features/linear_nonlinear.html">Specifying (Non)Linear Solvers</a></li><li><a class="toctext" href="../features/callback_functions.html">Event Handling and Callback Functions</a></li><li><a class="toctext" href="../features/callback_library.html">Callback Library</a></li><li><a class="toctext" href="../features/monte_carlo.html">Parallel Monte Carlo Simulations</a></li><li><a class="toctext" href="../features/io.html">I/O: Saving and Loading Solution Data</a></li><li><a class="toctext" href="../features/low_dep.html">Low Dependency Usage</a></li><li><a class="toctext" href="../features/mesh.html">Meshes</a></li><li><a class="toctext" href="../features/progress_bar.html">Juno Progress Bar Integration</a></li></ul></li><li><span class="toctext">Analysis Tools</span><ul><li class="current"><a class="toctext" href="parameterized_functions.html">ParameterizedFunctions</a><ul class="internal"><li><a class="toctext" href="#The-AbstractParameterizedFunction-Interface-1">The AbstractParameterizedFunction Interface</a></li><li><a class="toctext" href="#ParameterizedFunction-Constructor-1">ParameterizedFunction Constructor</a></li><li><a class="toctext" href="#Function-Definition-Macros-1">Function Definition Macros</a></li><li><a class="toctext" href="#Finite-Element-Method-Macros-1">Finite Element Method Macros</a></li></ul></li><li><a class="toctext" href="parameter_estimation.html">Parameter Estimation</a></li><li><a class="toctext" href="bifurcation.html">Bifurcation Analysis</a></li><li><a class="toctext" href="sensitivity.html">Sensitivity Analysis</a></li><li><a class="toctext" href="uncertainty_quantification.html">Uncertainty Quantification</a></li><li><a class="toctext" href="dev_and_test.html">Algorithm Development and Testing</a></li></ul></li><li><span class="toctext">Domain Modeling Tools</span><ul><li><a class="toctext" href="../models/multiscale.html">Multi-Scale Models</a></li><li><a class="toctext" href="../models/financial.html">Financial Models</a></li><li><a class="toctext" href="../models/biological.html">Biological Models</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Analysis Tools</li><li><a href="parameterized_functions.html">ParameterizedFunctions</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiffEq/DiffEqDocs.jl/tree/d7651ffe5951aa2a9ca0796fada7c4d97f2dcba9/docs/src/analysis/parameterized_functions.md"><span class="fa">ï</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>ParameterizedFunctions</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" href="#ParameterizedFunctions-1" id="ParameterizedFunctions-1">ParameterizedFunctions</a></h1><h2><a class="nav-anchor" href="#The-AbstractParameterizedFunction-Interface-1" id="The-AbstractParameterizedFunction-Interface-1">The AbstractParameterizedFunction Interface</a></h2><p><code>AbstractParameterizedFunction</code>s are ways for functions to hold parameters in ways that the solvers can directly solve the function, yet parameter estimation routines can access and change these values as needed. The interface has the following functions:</p><pre><code class="language-julia">param_values(pf::AbstractParameterizedFunction) = # Get the values of the parameters
num_params(pf::AbstractParameterizedFunction) = # Get the number of the parameters
set_param_values!(pf::AbstractParameterizedFunction,params) = # Set the parameter values using an AbstractArray</code></pre><p><code>AbstractParameterizedFunction</code>s can be constructed in the two ways below.</p><h2><a class="nav-anchor" href="#ParameterizedFunction-Constructor-1" id="ParameterizedFunction-Constructor-1">ParameterizedFunction Constructor</a></h2><p>The easiest way to make a <code>ParameterizedFunction</code> is to use the constructor:</p><pre><code class="language-julia">pf = ParameterizedFunction(f,params)</code></pre><p>The form for <code>f</code> is <code>f(t,u,params,du)</code> where <code>params</code> is any type which defines the parameters (it does not have to be an array, and it can be any user-defined type as well). The resulting <code>ParameterizedFunction</code> has the function call <code>pf(t,u,params,du)</code> which matches the original function, and a call <code>pf(t,u,du)</code> which uses internal parameters which can be used with a differential equation solver. Note that the internal parameters can be modified at any time via the field: <code>pf.p = ...</code>.</p><p>An additional version exists for <code>f(t,u,params)</code> which will then act as the not in-place version <code>f(t,u)</code> in the differential equation solvers.</p><p>Note that versions exist for the other types of differential equations as well. There are</p><pre><code class="language-julia">pf = DAEParameterizedFunction(f,params)
pf = DDEParameterizedFunction(f,params)</code></pre><p>for DAEs and DDEs respectively. For DAEs, the in-place syntax is <code>f(t,u,params,du,out)</code> and the not in-place syntax is <code>f(t,u,params,du)</code>. For DDEs, the in-place syntax is <code>f(t,u,h,params,du)</code> and the not in-place syntax is <code>f(t,u,h,params)</code></p><h3><a class="nav-anchor" href="#Examples-using-the-Constructor-1" id="Examples-using-the-Constructor-1">Examples using the Constructor</a></h3><pre><code class="language-julia">pf_func = function (t,u,p,du)
  du[1] = p[1] * u[1] - p[2] * u[1]*u[2]
  du[2] = -3 * u[2] + u[1]*u[2]
end

pf = ParameterizedFunction(pf_func,[1.5,1.0])</code></pre><p>And now <code>pf</code> can be used in the differential equation solvers and the ecosystem functionality which requires explicit parameters (parameter estimation, etc.).</p><p>Note that the not in-place version works the same:</p><pre><code class="language-julia">pf_func2 = function (t,u,p)
  [p[1] * u[1] - p[2] * u[1]*u[2];-3 * u[2] + u[1]*u[2]]
end

pf2 = ParameterizedFunction(pf_func2,[1.5,1.0])</code></pre><h2><a class="nav-anchor" href="#Function-Definition-Macros-1" id="Function-Definition-Macros-1">Function Definition Macros</a></h2><p>DifferentialEquations.jl provides a set of macros for more easily and legibly defining your differential equations. It exploits the standard notation for mathematically writing differential equations and the notation for "punching differential equations into the computer"; effectively doing the translation step for you. This is best shown by an example. Say we want to solve the <a href="http://www.radford.edu/~thompson/vodef90web/problems/demosnodislin/Single/DemoRobertson/demorobertson.pdf">ROBER model</a>. Using the <code>@ode_def</code> macro from ParameterizedFunctions.jl, we can do this by writing:</p><pre><code class="language-julia">using ParameterizedFunctions
f = @ode_def ROBERExample begin
  dyâ = -kâ*yâ+kâ*yâ*yâ
  dyâ =  kâ*yâ-kâ*yâ^2-kâ*yâ*yâ
  dyâ =  kâ*yâ^2
end kâ=&gt;0.04 kâ=&gt;3e7 kâ=&gt;1e4</code></pre><p>This looks just like pseudocode! The macro will expand this to the "standard form", i.e. the ugly computer form:</p><pre><code class="language-julia">f = (t,u,du) -&gt; begin
  du[1] = -0.04*u[1] + 1e4*u[2]*u[3]
  du[2] = 0.04*u[1] - 3e7*u[2]^2 - 1e4*u[2]*u[3]
  du[3] = 3e7*u[2]^2
end</code></pre><p>Note that one doesn't need to use numbered variables: DifferentialEquations.jl will number the variables for you. For example, the following defines the function for the Lotka-Volterra model:</p><pre><code class="language-julia">f = @ode_def LotkaVolterraExample begin
  dx = a*x - b*x*y
  dy = -c*y + d*x*y
end a=&gt;1.5 b=&gt;1.0 c=&gt;3.0 d=1.0</code></pre><h3><a class="nav-anchor" href="#Extra-Features-1" id="Extra-Features-1">Extra Features</a></h3><p>Functions defined using the <code>@ode_def</code> macro come with many other features. For example, since we used <code>=&gt;</code> for <code>a</code>, <code>b</code>, and <code>c</code>, these parameters are explicitly saved. That is, one can do:</p><pre><code class="language-julia">f.a = 0.2</code></pre><p>to change the parameter <code>f</code> to <code>0.2</code>. We can create a new function with new parameters using the name we gave the macro:</p><pre><code class="language-julia">g = LotkaVolterraExample(a=0.3,b=20.3)</code></pre><p>In this case, <code>c</code> will default to the value we gave it in the macro.</p><p>Since the parameters are explicit, these functions can be used to analyze how the parameters affect the model. Thus ParameterizedFunctions, when coupled with the solvers, forms the backbone of functionality such as parameter estimation, parameter sensitivity analysis, and bifurcation analysis.</p><h3><a class="nav-anchor" href="#Extra-Little-Tricks-1" id="Extra-Little-Tricks-1">Extra Little Tricks</a></h3><p>There are some extra little tricks you can do. Since <code>@ode_def</code> is a macro, you cannot directly make the parameters something that requires a runtime value. Thus the following will error:</p><pre><code class="language-julia">vec = rand(1,4)
f = @ode_def LotkaVolterraExample begin
dx = ax - bxy
dy = -cy + dxy
end a=&gt;vec[1] b=&gt;vec[2] c=&gt;vec[3] d=vec[4]</code></pre><p>To do the same thing, instead initialize it with values of the same type, and simply replace them:</p><pre><code class="language-julia">vec = rand(1,4)
f = @ode_def LotkaVolterraExample begin
dx = ax - bxy
dy = -cy + dxy
end a=&gt;1.0 b=&gt;1.0 c=&gt;1.0 d=vec[4]
f.a,f.b,f.c = vec[1:3]</code></pre><p>Notice that when using <code>=</code>, it can inline expressions. It can even inline expressions of time, like <code>d=3*t</code> or <code>d=2Ï</code>. However, do not use something like <code>d=3*x</code> as that will fail to transform the <code>x</code>.</p><p>In addition, one can also use their own function inside of the macro. For example:</p><pre><code class="language-julia">f(x,y,d) = erf(x*y/d)
NJ = @ode_def FuncTest begin
  dx = a*x - b*x*y
  dy = -c*y + f(x,y,d)
end a=&gt;1.5 b=&gt;1 c=3 d=4</code></pre><p>will do fine. The symbolic derivatives will not work unless you define a derivative for <code>f</code>.</p><h3><a class="nav-anchor" href="#Extra-Optimizations-1" id="Extra-Optimizations-1">Extra Optimizations</a></h3><p>Because the ParameterizedFunction defined by the macro holds the definition at a symbolic level, optimizations are provided by SymEngine. Using the symbolic calculator, in-place functions for many things such as Jacobians, Hessians, etc. are symbolically pre-computed. In addition, functions for the inverse Jacobian, Hessian, etc. are also pre-computed. In addition, parameter gradients and Jacobians are also used.</p><p>Normally these will be computed fast enough that the user doesn't have to worry. However, in some cases you may want to restrict the number of functions (or get rid of a warning). Macros like <code>@ode_def_nohes</code> turn off the Hessian calculations, and <code>@ode_def_noinvjac</code> turns off the Jacobian inversion. For more information, please see the <a href="https://github.com/JuliaDiffEq/ParameterizedFunctions.jl">ParameterizedFunctions.jl documentation</a>.</p><h2><a class="nav-anchor" href="#Finite-Element-Method-Macros-1" id="Finite-Element-Method-Macros-1">Finite Element Method Macros</a></h2><p>The other macro which is currently provided is the <code>@fem_def</code> macro. This macro is for parsing and writing FEM functions. For example, in the FEM methods you have to use <code>x[:,1]</code> instead of <code>x</code> and <code>x[:,2]</code> instead of <code>y</code>. The macro will automatically do this replacement, along with adding in parameters. Since FEM functions are more general, we also have to give it the function signature. Using the macro looks like this:</p><pre><code class="language-julia">f  = @fem_def (x) DataFunction begin
  sin(Î±.*x).*cos(Î±.*y)
end Î±=&gt;Ï

a = 2Ï
b = 8Ï*Ï
gD = @fem_def (x) DirichletBC begin
  sin(Î±.*x).*cos(Î±.*y)/Î²
end Î±=&gt;a Î²=&gt;b</code></pre><p>This is equivalent to the definition:</p><pre><code class="language-julia">f(x) = sin(2Ï.*x[:,1]).*cos(2Ï.*x[:,2])
gD(x) = sin(2Ï.*x[:,1]).*cos(2Ï.*x[:,2])/(8Ï*Ï)</code></pre><p>The true power comes in when dealing with nonlinear equations. The second argument, which we skipped over as <code>()</code>, is for listing the variables you wish to define the equation by. Mathematically you may be using <code>u</code>,<code>v</code>,<code>w</code>, etc., but for array-based algorithms you need to use <code>u[:,1]</code>,<code>u[:,2]</code>,etc. To avoid obfuscated code, the <code>@fem_def</code> macro does this conversion. For example:</p><pre><code class="language-julia">l = @fem_def (t,x,u) begin
  du = ones(length(u))-Î±*u
  dv = ones(length(v))-v
end Î±=&gt;0.5</code></pre><p>says there are two equations, one for <code>u</code>: (<code>ones(length(u))-Î±*u</code>) and one for <code>v</code>: <code>(ones(length(v))-v)</code>. This expands to the equation:</p><pre><code class="language-julia">l = (t,x,u)  -&gt; [ones(size(x,1))-.5u[:,1]   ones(size(x,1))-u[:,2]]</code></pre><p>When you have 10+ variables, using <code>@fem_def</code> leads to code which is much easier to read!</p><footer><hr/><a class="previous" href="../features/progress_bar.html"><span class="direction">Previous</span><span class="title">Juno Progress Bar Integration</span></a><a class="next" href="parameter_estimation.html"><span class="direction">Next</span><span class="title">Parameter Estimation</span></a></footer></article></body></HTML>